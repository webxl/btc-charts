diff --git a/dist/nivo-line.cjs.js b/dist/nivo-line.cjs.js
index aa95e68988ba82064d489cd268a9fd4562c7e674..5340c87774f147e7963e9f2c6f0e161af6581b1b 100644
--- a/dist/nivo-line.cjs.js
+++ b/dist/nivo-line.cjs.js
@@ -1,2 +1,2 @@
-"use strict";var e=require("react"),o=require("@nivo/core"),t=require("@nivo/colors"),i=require("@nivo/axes"),n=require("@nivo/legends"),r=require("@nivo/tooltip"),a=require("d3-shape"),l=require("@nivo/scales"),s=require("lodash/uniqueId"),u=require("react/jsx-runtime"),c=require("@react-spring/web"),d=require("@nivo/voronoi");function h(){return h=Object.assign?Object.assign.bind():function(e){for(var o=1;o<arguments.length;o++){var t=arguments[o];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i])}return e},h.apply(this,arguments)}var v=e.memo((function(e){var o=e.point;return u.jsx(r.BasicTooltip,{id:u.jsxs("span",{children:["x: ",u.jsx("strong",{children:o.data.xFormatted}),", y:"," ",u.jsx("strong",{children:o.data.yFormatted})]}),enableChip:!0,color:o.serieColor})})),p=e.memo((function(e){var t=e.slice,i=e.axis,n=o.useTheme(),a="x"===i?"y":"x";return u.jsx(r.TableTooltip,{rows:t.points.map((function(e){return[u.jsx(r.Chip,{color:e.serieColor,style:n.tooltip.chip},"chip"),e.serieId,u.jsx("span",{style:n.tooltip.tableCellValue,children:e.data[a+"Formatted"]},"value")]}))})})),f={curve:"linear",xScale:{type:"point"},yScale:{type:"linear",min:0,max:"auto"},layers:["grid","markers","axes","areas","crosshair","lines","points","slices","mesh","legends"],axisBottom:{},axisLeft:{},enableGridX:!0,enableGridY:!0,enablePoints:!0,pointSize:6,pointColor:{from:"color"},pointBorderWidth:0,pointBorderColor:{theme:"background"},enablePointLabel:!1,pointLabel:"yFormatted",colors:{scheme:"nivo"},enableArea:!1,areaBaselineValue:0,areaOpacity:.2,areaBlendMode:"normal",lineWidth:2,legends:[],isInteractive:!0,tooltip:v,enableSlices:!1,debugSlices:!1,sliceTooltip:p,debugMesh:!1,enableCrosshair:!0,crosshairType:"bottom-left"},m=h({},f,{enablePointLabel:!1,useMesh:!1,enableTouchCrosshair:!1,animate:!0,motionConfig:"gentle",defs:[],fill:[],role:"img"}),x=h({},f,{pixelRatio:"undefined"!=typeof window&&window.devicePixelRatio||1}),g=function(t){var i=t.curve;return e.useMemo((function(){return a.line().defined((function(e){return null!==e.x&&null!==e.y})).x((function(e){return e.x})).y((function(e){return e.y})).curve(o.curveFromProp(i))}),[i])},b=function(t){var i=t.curve,n=t.yScale,r=t.areaBaselineValue;return e.useMemo((function(){return a.area().defined((function(e){return null!==e.x&&null!==e.y})).x((function(e){return e.x})).y1((function(e){return e.y})).curve(o.curveFromProp(i)).y0(n(r))}),[i,n,r])},y=function(o){var t=o.componentId,i=o.enableSlices,n=o.points,r=o.width,a=o.height;return e.useMemo((function(){if(!1===i)return[];if("x"===i){var e=new Map;return n.forEach((function(o){null!==o.data.x&&null!==o.data.y&&(e.has(o.x)?e.get(o.x).push(o):e.set(o.x,[o]))})),Array.from(e.entries()).sort((function(e,o){return e[0]-o[0]})).map((function(e,o,i){var n,l,s=e[0],u=e[1],c=i[o-1],d=i[o+1];return n=c?s-(s-c[0])/2:s,l=d?s-n+(d[0]-s)/2:r-n,{id:"slice:"+t+":"+s,x0:n,x:s,y0:0,y:0,width:l,height:a,points:u.reverse()}}))}if("y"===i){var o=new Map;return n.forEach((function(e){null!==e.data.x&&null!==e.data.y&&(o.has(e.y)?o.get(e.y).push(e):o.set(e.y,[e]))})),Array.from(o.entries()).sort((function(e,o){return e[0]-o[0]})).map((function(e,o,t){var i,n,l=e[0],s=e[1],u=t[o-1],c=t[o+1];return i=u?l-(l-u[0])/2:l,n=c?l-i+(c[0]-l)/2:a-i,{id:l,x0:0,x:0,y0:i,y:l,width:r,height:n,points:s.reverse()}}))}}),[t,i,a,n,r])},C="line",S=function(i){var n=i.data,r=i.xScale,a=void 0===r?m.xScale:r,u=i.xFormat,c=i.yScale,d=void 0===c?m.yScale:c,v=i.yFormat,p=i.width,f=i.height,x=i.colors,S=void 0===x?m.colors:x,M=i.curve,T=void 0===M?m.curve:M,k=i.areaBaselineValue,w=void 0===k?m.areaBaselineValue:k,j=i.pointColor,E=void 0===j?m.pointColor:j,L=i.pointBorderColor,B=void 0===L?m.pointBorderColor:L,W=i.enableSlices,P=void 0===W?m.enableSlicesTooltip:W,G=e.useState(s(C))[0],F=o.useValueFormatter(u),O=o.useValueFormatter(v),V=t.useOrdinalColorScale(S,"id"),I=o.useTheme(),R=t.useInheritedColor(E,I),q=t.useInheritedColor(B,I),A=e.useState([]),Y=A[0],D=A[1],X=e.useMemo((function(){return l.computeXYScalesForSeries(n.filter((function(e){return-1===Y.indexOf(e.id)})),a,d,p,f)}),[n,Y,a,d,p,f]),H=X.xScale,z=X.yScale,_=X.series,N=e.useMemo((function(){var e=n.map((function(e){return{id:e.id,label:e.id,color:V(e)}})),o=e.map((function(e){return h({},_.find((function(o){return o.id===e.id})),{color:e.color})})).filter((function(e){return Boolean(e.id)}));return{legendData:e.map((function(e){return h({},e,{hidden:!o.find((function(o){return o.id===e.id}))})})).reverse(),series:o}}),[n,_,V]),U=N.legendData,Q=N.series,J=e.useCallback((function(e){D((function(o){return o.indexOf(e)>-1?o.filter((function(o){return o!==e})):[].concat(o,[e])}))}),[]),K=function(o){var t=o.series,i=o.getPointColor,n=o.getPointBorderColor,r=o.formatX,a=o.formatY;return e.useMemo((function(){return t.reduce((function(e,o){return[].concat(e,o.data.filter((function(e){return null!==e.position.x&&null!==e.position.y})).map((function(t,l){var s={id:o.id+"."+l,index:e.length+l,serieId:o.id,serieColor:o.color,x:t.position.x,y:t.position.y};return s.color=i(o),s.borderColor=n(s),s.data=h({},t.data,{xFormatted:r(t.data.x),yFormatted:a(t.data.y)}),s})))}),[])}),[t,i,n,r,a])}({series:Q,getPointColor:R,getPointBorderColor:q,formatX:F,formatY:O}),Z=y({componentId:G,enableSlices:P,points:K,width:p,height:f});return{legendData:U,toggleSerie:J,lineGenerator:g({curve:T}),areaGenerator:b({curve:T,yScale:z,areaBaselineValue:w}),getColor:V,series:Q,xScale:H,yScale:z,slices:Z,points:K}},M=function(e){var t=e.areaBlendMode,i=e.areaOpacity,n=e.color,r=e.fill,a=e.path,l=o.useMotionConfig(),s=l.animate,d=l.config,h=o.useAnimatedPath(a),v=c.useSpring({color:n,config:d,immediate:!s});return u.jsx(c.animated.path,{d:h,fill:r||v.color,fillOpacity:i,strokeWidth:0,style:{mixBlendMode:t}})},T=e.memo((function(e){var o=e.areaGenerator,t=e.areaOpacity,i=e.areaBlendMode,n=e.lines.slice(0).reverse();return u.jsx("g",{children:n.map((function(e){return u.jsx(M,h({path:o(e.data.map((function(e){return e.position})))},h({areaOpacity:t,areaBlendMode:i},e)),e.id)}))})})),k=e.memo((function(t){var i=t.lineGenerator,n=t.points,r=t.color,a=t.thickness,l=e.useMemo((function(){return i(n)}),[i,n]),s=o.useAnimatedPath(l);return u.jsx(c.animated.path,{d:s,fill:"none",strokeWidth:a,stroke:r})})),w=e.memo((function(e){var o=e.lines,t=e.lineGenerator,i=e.lineWidth;return o.slice(0).reverse().map((function(e){var o=e.id,n=e.data,r=e.color;return u.jsx(k,{id:o,points:n.map((function(e){return e.position})),lineGenerator:t,color:r,thickness:i},o)}))})),j=e.memo((function(o){var t=o.slice,i=o.slices,n=o.axis,a=o.debug,l=o.tooltip,s=o.isCurrent,c=o.setCurrent,d=o.onMouseEnter,h=o.onMouseMove,v=o.onMouseLeave,p=o.onClick,f=o.onTouchStart,m=o.onTouchMove,x=o.onTouchEnd,g=r.useTooltip(),b=g.showTooltipFromEvent,y=g.hideTooltip,C=e.useCallback((function(o){b(e.createElement(l,{slice:t,axis:n}),o,"right"),c(t),d&&d(t,o)}),[b,l,t,n,c,d]),S=e.useCallback((function(o){b(e.createElement(l,{slice:t,axis:n}),o,"right"),h&&h(t,o)}),[b,l,t,n,h]),M=e.useCallback((function(e){y(),c(null),v&&v(t,e)}),[y,c,v,t]),T=e.useCallback((function(e){p&&p(t,e)}),[t,p]),k=e.useCallback((function(o){b(e.createElement(l,{slice:t,axis:n}),o,"right"),c(t),f&&f(t,o)}),[n,f,c,b,t,l]),w=e.useCallback((function(o){var r=o.touches[0],a=document.elementFromPoint(r.clientX,r.clientY),s=null==a?void 0:a.getAttribute("data-ref");if(s){var u=i.find((function(e){return e.id===s}));u&&(b(e.createElement(l,{slice:u,axis:n}),o,"right"),c(u))}m&&m(t,o)}),[n,m,c,b,t,i,l]),j=e.useCallback((function(e){y(),c(null),x&&x(t,e)}),[y,c,x,t]);return u.jsx("rect",{x:t.x0,y:t.y0,width:t.width,height:t.height,stroke:"red",strokeWidth:a?1:0,strokeOpacity:.75,fill:"red",fillOpacity:s&&a?.35:0,onMouseEnter:C,onMouseMove:S,onMouseLeave:M,onClick:T,onTouchStart:k,onTouchMove:w,onTouchEnd:j,"data-ref":t.id})})),E=e.memo((function(e){var o=e.slices,t=e.axis,i=e.debug,n=e.height,r=e.tooltip,a=e.current,l=e.setCurrent,s=e.onMouseEnter,c=e.onMouseMove,d=e.onMouseLeave,h=e.onClick,v=e.onTouchStart,p=e.onTouchMove,f=e.onTouchEnd;return o.map((function(e){return u.jsx(j,{slice:e,slices:o,axis:t,debug:i,height:n,tooltip:r,setCurrent:l,isCurrent:null!==a&&a.id===e.id,onMouseEnter:s,onMouseMove:c,onMouseLeave:d,onClick:h,onTouchStart:v,onTouchMove:p,onTouchEnd:f},e.id)}))})),L=e.memo((function(e){var t=e.points,i=e.symbol,n=e.size,r=e.borderWidth,a=e.enableLabel,l=e.label,s=e.labelYOffset,c=o.useTheme(),d=o.getLabelGenerator(l),h=t.slice(0).reverse().map((function(e){return{id:e.id,x:e.x,y:e.y,datum:e.data,fill:e.color,stroke:e.borderColor,label:a?d(e):null}}));return u.jsx("g",{children:h.map((function(e){return u.jsx(o.DotsItem,{x:e.x,y:e.y,datum:e.datum,symbol:i,size:n,color:e.fill,borderWidth:r,borderColor:e.stroke,label:e.label,labelYOffset:s,theme:c},e.id)}))})})),B=e.memo((function(o){var t=o.points,i=o.width,n=o.height,a=o.margin,l=o.setCurrent,s=o.onMouseEnter,c=o.onMouseMove,h=o.onMouseLeave,v=o.onClick,p=o.onTouchStart,f=o.onTouchMove,m=o.onTouchEnd,x=o.tooltip,g=o.debug,b=o.enableTouchCrosshair,y=r.useTooltip(),C=y.showTooltipAt,S=y.hideTooltip,M=e.useCallback((function(o,t){C(e.createElement(x,{point:o}),[o.x+a.left,o.y+a.top],"top"),s&&s(o,t)}),[C,x,s,a]),T=e.useCallback((function(o,t){C(e.createElement(x,{point:o}),[o.x+a.left,o.y+a.top],"top"),c&&c(o,t)}),[C,x,a.left,a.top,c]),k=e.useCallback((function(e,o){S(),h&&h(e,o)}),[S,h]),w=e.useCallback((function(e,o){v&&v(e,o)}),[v]),j=e.useCallback((function(o,t){C(e.createElement(x,{point:o}),[o.x+a.left,o.y+a.top],"top"),p&&p(o,t)}),[a.left,a.top,p,C,x]),E=e.useCallback((function(o,t){C(e.createElement(x,{point:o}),[o.x+a.left,o.y+a.top],"top"),f&&f(o,t)}),[a.left,a.top,f,C,x]),L=e.useCallback((function(e,o){S(),m&&m(e,o)}),[m,S]);return u.jsx(d.Mesh,{nodes:t,width:i,height:n,setCurrent:l,onMouseEnter:M,onMouseMove:T,onMouseLeave:k,onClick:w,onTouchStart:j,onTouchMove:E,onTouchEnd:L,enableTouchCrosshair:b,debug:g})})),W=o.withContainer((function(a){var l=a.data,s=a.xScale,c=void 0===s?{type:"point"}:s,d=a.xFormat,f=a.yScale,m=void 0===f?{type:"linear",min:0,max:"auto"}:f,x=a.yFormat,g=a.layers,b=void 0===g?["grid","markers","axes","areas","crosshair","lines","points","slices","mesh","legends"]:g,y=a.curve,C=void 0===y?"linear":y,M=a.areaBaselineValue,k=void 0===M?0:M,j=a.colors,W=void 0===j?{scheme:"nivo"}:j,P=a.margin,G=a.width,F=a.height,O=a.axisTop,V=a.axisRight,I=a.axisBottom,R=void 0===I?{}:I,q=a.axisLeft,A=void 0===q?{}:q,Y=a.enableGridX,D=void 0===Y||Y,X=a.enableGridY,H=void 0===X||X,z=a.gridXValues,_=a.gridYValues,N=a.lineWidth,U=void 0===N?2:N,Q=a.enableArea,J=void 0!==Q&&Q,K=a.areaOpacity,Z=void 0===K?.2:K,$=a.areaBlendMode,ee=void 0===$?"normal":$,oe=a.enablePoints,te=void 0===oe||oe,ie=a.pointSymbol,ne=a.pointSize,re=void 0===ne?6:ne,ae=a.pointColor,le=void 0===ae?{from:"color"}:ae,se=a.pointBorderWidth,ue=void 0===se?0:se,ce=a.pointBorderColor,de=void 0===ce?{theme:"background"}:ce,he=a.enablePointLabel,ve=void 0!==he&&he,pe=a.pointLabel,fe=void 0===pe?"data.yFormatted":pe,me=a.pointLabelYOffset,xe=a.defs,ge=void 0===xe?[]:xe,be=a.fill,ye=void 0===be?[]:be,Ce=a.markers,Se=a.legends,Me=void 0===Se?[]:Se,Te=a.isInteractive,ke=void 0===Te||Te,we=a.useMesh,je=void 0!==we&&we,Ee=a.debugMesh,Le=void 0!==Ee&&Ee,Be=a.onMouseEnter,We=a.onMouseMove,Pe=a.onMouseLeave,Ge=a.onClick,Fe=a.onTouchStart,Oe=a.onTouchMove,Ve=a.onTouchEnd,Ie=a.tooltip,Re=void 0===Ie?v:Ie,qe=a.enableSlices,Ae=void 0!==qe&&qe,Ye=a.debugSlices,De=void 0!==Ye&&Ye,Xe=a.sliceTooltip,He=void 0===Xe?p:Xe,ze=a.enableCrosshair,_e=void 0===ze||ze,Ne=a.crosshairType,Ue=void 0===Ne?"bottom-left":Ne,Qe=a.enableTouchCrosshair,Je=void 0!==Qe&&Qe,Ke=a.role,Ze=void 0===Ke?"img":Ke,$e=o.useDimensions(G,F,P),eo=$e.margin,oo=$e.innerWidth,to=$e.innerHeight,io=$e.outerWidth,no=$e.outerHeight,ro=S({data:l,xScale:c,xFormat:d,yScale:m,yFormat:x,width:oo,height:to,colors:W,curve:C,areaBaselineValue:k,pointColor:le,pointBorderColor:de,enableSlices:Ae}),ao=ro.legendData,lo=ro.toggleSerie,so=ro.lineGenerator,uo=ro.areaGenerator,co=ro.series,ho=ro.xScale,vo=ro.yScale,po=ro.slices,fo=ro.points,mo=o.useTheme(),xo=t.useInheritedColor(le,mo),go=t.useInheritedColor(de,mo),bo=e.useState(null),yo=bo[0],Co=bo[1],So=e.useState(null),Mo=So[0],To=So[1],ko={grid:u.jsx(i.Grid,{theme:mo,width:oo,height:to,xScale:D?ho:null,yScale:H?vo:null,xValues:z,yValues:_},"grid"),markers:u.jsx(o.CartesianMarkers,{markers:Ce,width:oo,height:to,xScale:ho,yScale:vo,theme:mo},"markers"),axes:u.jsx(i.Axes,{xScale:ho,yScale:vo,width:oo,height:to,theme:mo,top:O,right:V,bottom:R,left:A},"axes"),areas:null,lines:u.jsx(w,{lines:co,lineGenerator:so,lineWidth:U},"lines"),slices:null,points:null,crosshair:null,mesh:null,legends:Me.map((function(e,o){return u.jsx(n.BoxLegendSvg,h({},e,{containerWidth:oo,containerHeight:to,data:e.data||ao,theme:mo,toggleSerie:e.toggleSerie?lo:void 0}),"legend."+o)}))},wo=o.bindDefs(ge,co,ye);return J&&(ko.areas=u.jsx(T,{areaGenerator:uo,areaOpacity:Z,areaBlendMode:ee,lines:co},"areas")),ke&&!1!==Ae&&(ko.slices=u.jsx(E,{slices:po,axis:Ae,debug:De,height:to,tooltip:He,current:Mo,setCurrent:To,onMouseEnter:Be,onMouseMove:We,onMouseLeave:Pe,onClick:Ge,onTouchStart:Fe,onTouchMove:Oe,onTouchEnd:Ve},"slices")),te&&(ko.points=u.jsx(L,{points:fo,symbol:ie,size:re,color:xo,borderWidth:ue,borderColor:go,enableLabel:ve,label:fe,labelYOffset:me},"points")),ke&&_e&&(null!==yo&&(ko.crosshair=u.jsx(r.Crosshair,{width:oo,height:to,x:yo.x,y:yo.y,type:Ue},"crosshair")),null!==Mo&&(ko.crosshair=u.jsx(r.Crosshair,{width:oo,height:to,x:Mo.x,y:Mo.y,type:Ae},"crosshair"))),ke&&je&&!1===Ae&&(ko.mesh=u.jsx(B,{points:fo,width:oo,height:to,margin:eo,current:yo,setCurrent:Co,onMouseEnter:Be,onMouseMove:We,onMouseLeave:Pe,onClick:Ge,onTouchStart:Fe,onTouchMove:Oe,onTouchEnd:Ve,tooltip:Re,enableTouchCrosshair:Je,debug:Le},"mesh")),u.jsx(o.SvgWrapper,{defs:wo,width:io,height:no,margin:eo,role:Ze,children:b.map((function(o,t){return"function"==typeof o?u.jsx(e.Fragment,{children:o(h({},a,{innerWidth:oo,innerHeight:to,series:co,slices:po,points:fo,xScale:ho,yScale:vo,lineGenerator:so,areaGenerator:uo,currentPoint:yo,setCurrentPoint:Co,currentSlice:Mo,setCurrentSlice:To}))},t):ko[o]}))})})),P=o.withContainer((function(t){var a=e.useRef(null),l=t.width,s=t.height,c=t.margin,p=t.pixelRatio,f=void 0===p?"undefined"!=typeof window&&window.devicePixelRatio||1:p,m=t.data,x=t.xScale,g=void 0===x?{type:"point"}:x,b=t.xFormat,y=t.yScale,C=void 0===y?{type:"linear",min:0,max:"auto"}:y,M=t.yFormat,T=t.curve,k=void 0===T?"linear":T,w=t.layers,j=void 0===w?["grid","markers","axes","areas","crosshair","lines","points","slices","mesh","legends"]:w,E=t.colors,L=void 0===E?{scheme:"nivo"}:E,B=t.lineWidth,W=void 0===B?2:B,P=t.enableArea,G=void 0!==P&&P,F=t.areaBaselineValue,O=void 0===F?0:F,V=t.areaOpacity,I=void 0===V?.2:V,R=t.enablePoints,q=void 0===R||R,A=t.pointSize,Y=void 0===A?6:A,D=t.pointColor,X=void 0===D?{from:"color"}:D,H=t.pointBorderWidth,z=void 0===H?0:H,_=t.pointBorderColor,N=void 0===_?{theme:"background"}:_,U=t.enableGridX,Q=void 0===U||U,J=t.gridXValues,K=t.enableGridY,Z=void 0===K||K,$=t.gridYValues,ee=t.axisTop,oe=t.axisRight,te=t.axisBottom,ie=void 0===te?{}:te,ne=t.axisLeft,re=void 0===ne?{}:ne,ae=t.legends,le=void 0===ae?[]:ae,se=t.isInteractive,ue=void 0===se||se,ce=t.debugMesh,de=void 0!==ce&&ce,he=t.onMouseLeave,ve=t.onClick,pe=t.tooltip,fe=void 0===pe?v:pe,me=t.canvasRef,xe=o.useDimensions(l,s,c),ge=xe.margin,be=xe.innerWidth,ye=xe.innerHeight,Ce=xe.outerWidth,Se=xe.outerHeight,Me=o.useTheme(),Te=e.useState(null),ke=Te[0],we=Te[1],je=S({data:m,xScale:g,xFormat:b,yScale:C,yFormat:M,width:be,height:ye,colors:L,curve:k,areaBaselineValue:O,pointColor:X,pointBorderColor:N}),Ee=je.lineGenerator,Le=je.areaGenerator,Be=je.series,We=je.xScale,Pe=je.yScale,Ge=je.points,Fe=d.useVoronoiMesh({points:Ge,width:be,height:ye,debug:de}),Oe=Fe.delaunay,Ve=Fe.voronoi;e.useEffect((function(){me&&(me.current=a.current),a.current.width=Ce*f,a.current.height=Se*f;var e=a.current.getContext("2d");e.scale(f,f),e.fillStyle=Me.background,e.fillRect(0,0,Ce,Se),e.translate(ge.left,ge.top),j.forEach((function(o){if("function"==typeof o&&o({ctx:e,innerWidth:be,innerHeight:ye,series:Be,points:Ge,xScale:We,yScale:Pe,lineWidth:W,lineGenerator:Ee,areaGenerator:Le,currentPoint:ke,setCurrentPoint:we}),"grid"===o&&Me.grid.line.strokeWidth>0&&(e.lineWidth=Me.grid.line.strokeWidth,e.strokeStyle=Me.grid.line.stroke,Q&&i.renderGridLinesToCanvas(e,{width:be,height:ye,scale:We,axis:"x",values:J}),Z&&i.renderGridLinesToCanvas(e,{width:be,height:ye,scale:Pe,axis:"y",values:$})),"axes"===o&&i.renderAxesToCanvas(e,{xScale:We,yScale:Pe,width:be,height:ye,top:ee,right:oe,bottom:ie,left:re,theme:Me}),"areas"===o&&!0===G){e.save(),e.globalAlpha=I,Le.context(e);for(var t=Be.length-1;t>=0;t--)e.fillStyle=Be[t].color,e.beginPath(),Le(Be[t].data.map((function(e){return e.position}))),e.fill();e.restore()}if("lines"===o&&(Ee.context(e),Be.forEach((function(o){e.strokeStyle=o.color,e.lineWidth=W,e.beginPath(),Ee(o.data.map((function(e){return e.position}))),e.stroke()}))),"points"===o&&!0===q&&Y>0&&Ge.forEach((function(o){e.fillStyle=o.color,e.beginPath(),e.arc(o.x,o.y,Y/2,0,2*Math.PI),e.fill(),z>0&&(e.strokeStyle=o.borderColor,e.lineWidth=z,e.stroke())})),"mesh"===o&&!0===de&&(d.renderVoronoiToCanvas(e,Ve),ke&&d.renderVoronoiCellToCanvas(e,Ve,ke.index)),"legends"===o){var r=Be.map((function(e){return{id:e.id,label:e.id,color:e.color}})).reverse();le.forEach((function(o){n.renderLegendToCanvas(e,h({},o,{data:o.data||r,containerWidth:be,containerHeight:ye,theme:Me}))}))}}))}),[a,Ce,Se,j,Me,Ee,Be,We,Pe,Q,J,Z,$,ee,oe,ie,re,le,Ge,q,Y,ke]);var Ie=e.useCallback((function(e){var t=o.getRelativeCursor(a.current,e),i=t[0],n=t[1];if(!o.isCursorInRect(ge.left,ge.top,be,ye,i,n))return null;var r=Oe.find(i-ge.left,n-ge.top);return Ge[r]}),[a,ge,be,ye,Oe]),Re=r.useTooltip(),qe=Re.showTooltipFromEvent,Ae=Re.hideTooltip,Ye=e.useCallback((function(o){var t=Ie(o);we(t),t?qe(e.createElement(fe,{point:t}),o):Ae()}),[Ie,we,qe,Ae,fe]),De=e.useCallback((function(e){Ae(),we(null),ke&&he&&he(ke,e)}),[Ae,we,he]),Xe=e.useCallback((function(e){if(ve){var o=Ie(e);o&&ve(o,e)}}),[Ie,ve]);return u.jsx("canvas",{ref:a,width:Ce*f,height:Se*f,style:{width:Ce,height:Se,cursor:ue?"auto":"normal"},onMouseEnter:ue?Ye:void 0,onMouseMove:ue?Ye:void 0,onMouseLeave:ue?De:void 0,onClick:ue?Xe:void 0})})),G=e.forwardRef((function(e,o){return u.jsx(P,h({},e,{canvasRef:o}))})),F=e.forwardRef((function(e,t){return u.jsx(o.ResponsiveWrapper,{children:function(o){var i=o.width,n=o.height;return u.jsx(G,h({width:i,height:n},e,{ref:t}))}})}));exports.LINE_UNIQUE_ID_PREFIX=C,exports.Line=W,exports.LineCanvas=G,exports.LineCanvasDefaultProps=x,exports.LineDefaultProps=m,exports.ResponsiveLine=function(e){return u.jsx(o.ResponsiveWrapper,{children:function(o){var t=o.width,i=o.height;return u.jsx(W,h({width:t,height:i},e))}})},exports.ResponsiveLineCanvas=F,exports.useAreaGenerator=b,exports.useLine=S,exports.useLineGenerator=g,exports.useSlices=y;
+"use strict";var e=require("react"),o=require("@nivo/core"),i=require("@nivo/colors"),t=require("@nivo/axes"),n=require("@nivo/legends"),r=require("@nivo/tooltip"),a=require("d3-shape"),l=require("@nivo/scales"),s=require("lodash/uniqueId"),u=require("react/jsx-runtime"),c=require("@react-spring/web"),d=require("@nivo/voronoi");function h(){return h=Object.assign?Object.assign.bind():function(e){for(var o=1;o<arguments.length;o++){var i=arguments[o];for(var t in i)Object.prototype.hasOwnProperty.call(i,t)&&(e[t]=i[t])}return e},h.apply(this,arguments)}var v=e.memo((function(e){var o=e.point;return u.jsx(r.BasicTooltip,{id:u.jsxs("span",{children:["x: ",u.jsx("strong",{children:o.data.xFormatted}),", y:"," ",u.jsx("strong",{children:o.data.yFormatted})]}),enableChip:!0,color:o.serieColor})})),p=e.memo((function(e){var i=e.slice,t=e.axis,n=o.useTheme(),a="x"===t?"y":"x";return u.jsx(r.TableTooltip,{rows:i.points.map((function(e){return[u.jsx(r.Chip,{color:e.serieColor,style:n.tooltip.chip},"chip"),e.serieId,u.jsx("span",{style:n.tooltip.tableCellValue,children:e.data[a+"Formatted"]},"value")]}))})})),f={curve:"linear",xScale:{type:"point"},yScale:{type:"linear",min:0,max:"auto"},layers:["grid","markers","axes","areas","crosshair","lines","points","slices","mesh","legends"],axisBottom:{},axisLeft:{},enableGridX:!0,enableGridY:!0,enablePoints:!0,pointSize:6,pointColor:{from:"color"},pointBorderWidth:0,pointBorderColor:{theme:"background"},enablePointLabel:!1,pointLabel:"yFormatted",colors:{scheme:"nivo"},enableArea:!1,areaBaselineValue:0,areaOpacity:.2,areaBlendMode:"normal",lineWidth:2,legends:[],isInteractive:!0,tooltip:v,enableSlices:!1,debugSlices:!1,sliceTooltip:p,debugMesh:!1,enableCrosshair:!0,crosshairType:"bottom-left"},m=h({},f,{enablePointLabel:!1,useMesh:!1,enableTouchCrosshair:!1,animate:!0,motionConfig:"gentle",defs:[],fill:[],role:"img",initialHiddenIds:[]}),x=h({},f,{pixelRatio:"undefined"!=typeof window&&window.devicePixelRatio||1}),g=function(i){var t=i.curve;return e.useMemo((function(){return a.line().defined((function(e){return null!==e.x&&null!==e.y})).x((function(e){return e.x})).y((function(e){return e.y})).curve(o.curveFromProp(t))}),[t])},b=function(i){var t=i.curve,n=i.yScale,r=i.areaBaselineValue;return e.useMemo((function(){return a.area().defined((function(e){return null!==e.x&&null!==e.y})).x((function(e){return e.x})).y1((function(e){return e.y})).curve(o.curveFromProp(t)).y0(n(r))}),[t,n,r])},y=function(o){var i=o.componentId,t=o.enableSlices,n=o.points,r=o.width,a=o.height;return e.useMemo((function(){if(!1===t)return[];if("x"===t){var e=new Map;return n.forEach((function(o){null!==o.data.x&&null!==o.data.y&&(e.has(o.x)?e.get(o.x).push(o):e.set(o.x,[o]))})),Array.from(e.entries()).sort((function(e,o){return e[0]-o[0]})).map((function(e,o,t){var n,l,s=e[0],u=e[1],c=t[o-1],d=t[o+1];return n=c?s-(s-c[0])/2:s,l=d?s-n+(d[0]-s)/2:r-n,{id:"slice:"+i+":"+s,x0:n,x:s,y0:0,y:0,width:l,height:a,points:u.reverse()}}))}if("y"===t){var o=new Map;return n.forEach((function(e){null!==e.data.x&&null!==e.data.y&&(o.has(e.y)?o.get(e.y).push(e):o.set(e.y,[e]))})),Array.from(o.entries()).sort((function(e,o){return e[0]-o[0]})).map((function(e,o,i){var t,n,l=e[0],s=e[1],u=i[o-1],c=i[o+1];return t=u?l-(l-u[0])/2:l,n=c?l-t+(c[0]-l)/2:a-t,{id:l,x0:0,x:0,y0:t,y:l,width:r,height:n,points:s.reverse()}}))}}),[i,t,a,n,r])},C="line",S=function(t){var n=t.data,r=t.xScale,a=void 0===r?m.xScale:r,u=t.xFormat,c=t.yScale,d=void 0===c?m.yScale:c,v=t.yFormat,p=t.width,f=t.height,x=t.colors,S=void 0===x?m.colors:x,M=t.curve,T=void 0===M?m.curve:M,k=t.areaBaselineValue,w=void 0===k?m.areaBaselineValue:k,j=t.pointColor,E=void 0===j?m.pointColor:j,L=t.pointBorderColor,B=void 0===L?m.pointBorderColor:L,W=t.enableSlices,P=void 0===W?m.enableSlicesTooltip:W,G=t.initialHiddenIds,F=void 0===G?m.initialHiddenIds:G,I=e.useState(s(C))[0],O=o.useValueFormatter(u),V=o.useValueFormatter(v),R=i.useOrdinalColorScale(S,"id"),q=o.useTheme(),A=i.useInheritedColor(E,q),H=i.useInheritedColor(B,q),Y=e.useState(null!=F?F:[]),D=Y[0],X=Y[1],z=e.useMemo((function(){return l.computeXYScalesForSeries(n.filter((function(e){return-1===D.indexOf(e.id)})),a,d,p,f)}),[n,D,a,d,p,f]),_=z.xScale,N=z.yScale,U=z.series,Q=e.useMemo((function(){var e=n.map((function(e){return{id:e.id,label:e.id,color:R(e)}})),o=e.map((function(e){return h({},U.find((function(o){return o.id===e.id})),{color:e.color})})).filter((function(e){return Boolean(e.id)}));return{legendData:e.map((function(e){return h({},e,{hidden:!o.find((function(o){return o.id===e.id}))})})).reverse(),series:o}}),[n,U,R]),J=Q.legendData,K=Q.series,Z=e.useCallback((function(e){X((function(o){return o.indexOf(e)>-1?o.filter((function(o){return o!==e})):[].concat(o,[e])}))}),[]),$=function(o){var i=o.series,t=o.getPointColor,n=o.getPointBorderColor,r=o.formatX,a=o.formatY;return e.useMemo((function(){return i.reduce((function(e,o){return[].concat(e,o.data.filter((function(e){return null!==e.position.x&&null!==e.position.y})).map((function(i,l){var s={id:o.id+"."+l,index:e.length+l,serieId:o.id,serieColor:o.color,x:i.position.x,y:i.position.y};return s.color=t(o),s.borderColor=n(s),s.data=h({},i.data,{xFormatted:r(i.data.x),yFormatted:a(i.data.y)}),s})))}),[])}),[i,t,n,r,a])}({series:K,getPointColor:A,getPointBorderColor:H,formatX:O,formatY:V}),ee=y({componentId:I,enableSlices:P,points:$,width:p,height:f});return{legendData:J,toggleSerie:Z,lineGenerator:g({curve:T}),areaGenerator:b({curve:T,yScale:N,areaBaselineValue:w}),getColor:R,series:K,xScale:_,yScale:N,slices:ee,points:$}},M=function(e){var i=e.areaBlendMode,t=e.areaOpacity,n=e.color,r=e.fill,a=e.path,l=o.useMotionConfig(),s=l.animate,d=l.config,h=o.useAnimatedPath(a),v=c.useSpring({color:n,config:d,immediate:!s});return u.jsx(c.animated.path,{d:h,fill:r||v.color,fillOpacity:t,strokeWidth:0,style:{mixBlendMode:i}})},T=e.memo((function(e){var o=e.areaGenerator,i=e.areaOpacity,t=e.areaBlendMode,n=e.lines.slice(0).reverse();return u.jsx("g",{children:n.map((function(e){return u.jsx(M,h({path:o(e.data.map((function(e){return e.position})))},h({areaOpacity:i,areaBlendMode:t},e)),e.id)}))})})),k=e.memo((function(i){var t=i.lineGenerator,n=i.points,r=i.color,a=i.thickness,l=e.useMemo((function(){return t(n)}),[t,n]),s=o.useAnimatedPath(l);return u.jsx(c.animated.path,{d:s,fill:"none",strokeWidth:a,stroke:r})})),w=e.memo((function(e){var o=e.lines,i=e.lineGenerator,t=e.lineWidth;return o.slice(0).reverse().map((function(e){var o=e.id,n=e.data,r=e.color;return u.jsx(k,{id:o,points:n.map((function(e){return e.position})),lineGenerator:i,color:r,thickness:t},o)}))})),j=e.memo((function(o){var i=o.slice,t=o.slices,n=o.axis,a=o.debug,l=o.tooltip,s=o.isCurrent,c=o.setCurrent,d=o.onMouseEnter,h=o.onMouseMove,v=o.onMouseLeave,p=o.onClick,f=o.onTouchStart,m=o.onTouchMove,x=o.onTouchEnd,g=r.useTooltip(),b=g.showTooltipFromEvent,y=g.hideTooltip,C=e.useCallback((function(o){b(e.createElement(l,{slice:i,axis:n}),o,"right"),c(i),d&&d(i,o)}),[b,l,i,n,c,d]),S=e.useCallback((function(o){b(e.createElement(l,{slice:i,axis:n}),o,"right"),h&&h(i,o)}),[b,l,i,n,h]),M=e.useCallback((function(e){y(),c(null),v&&v(i,e)}),[y,c,v,i]),T=e.useCallback((function(e){p&&p(i,e)}),[i,p]),k=e.useCallback((function(o){b(e.createElement(l,{slice:i,axis:n}),o,"right"),c(i),f&&f(i,o)}),[n,f,c,b,i,l]),w=e.useCallback((function(o){var r=o.touches[0],a=document.elementFromPoint(r.clientX,r.clientY),s=null==a?void 0:a.getAttribute("data-ref");if(s){var u=t.find((function(e){return e.id===s}));u&&(b(e.createElement(l,{slice:u,axis:n}),o,"right"),c(u))}m&&m(i,o)}),[n,m,c,b,i,t,l]),j=e.useCallback((function(e){y(),c(null),x&&x(i,e)}),[y,c,x,i]);return u.jsx("rect",{x:i.x0,y:i.y0,width:i.width,height:i.height,stroke:"red",strokeWidth:a?1:0,strokeOpacity:.75,fill:"red",fillOpacity:s&&a?.35:0,onMouseEnter:C,onMouseMove:S,onMouseLeave:M,onClick:T,onTouchStart:k,onTouchMove:w,onTouchEnd:j,"data-ref":i.id})})),E=e.memo((function(e){var o=e.slices,i=e.axis,t=e.debug,n=e.height,r=e.tooltip,a=e.current,l=e.setCurrent,s=e.onMouseEnter,c=e.onMouseMove,d=e.onMouseLeave,h=e.onClick,v=e.onTouchStart,p=e.onTouchMove,f=e.onTouchEnd;return o.map((function(e){return u.jsx(j,{slice:e,slices:o,axis:i,debug:t,height:n,tooltip:r,setCurrent:l,isCurrent:null!==a&&a.id===e.id,onMouseEnter:s,onMouseMove:c,onMouseLeave:d,onClick:h,onTouchStart:v,onTouchMove:p,onTouchEnd:f},e.id)}))})),L=e.memo((function(e){var i=e.points,t=e.symbol,n=e.size,r=e.borderWidth,a=e.enableLabel,l=e.label,s=e.labelYOffset,c=o.useTheme(),d=o.getLabelGenerator(l),h=i.slice(0).reverse().map((function(e){return{id:e.id,x:e.x,y:e.y,datum:e.data,fill:e.color,stroke:e.borderColor,label:a?d(e):null}}));return u.jsx("g",{children:h.map((function(e){return u.jsx(o.DotsItem,{x:e.x,y:e.y,datum:e.datum,symbol:t,size:n,color:e.fill,borderWidth:r,borderColor:e.stroke,label:e.label,labelYOffset:s,theme:c},e.id)}))})})),B=e.memo((function(o){var i=o.points,t=o.width,n=o.height,a=o.margin,l=o.setCurrent,s=o.onMouseEnter,c=o.onMouseMove,h=o.onMouseLeave,v=o.onClick,p=o.onTouchStart,f=o.onTouchMove,m=o.onTouchEnd,x=o.tooltip,g=o.debug,b=o.enableTouchCrosshair,y=r.useTooltip(),C=y.showTooltipAt,S=y.hideTooltip,M=e.useCallback((function(o,i){C(e.createElement(x,{point:o}),[o.x+a.left,o.y+a.top],"top"),s&&s(o,i)}),[C,x,s,a]),T=e.useCallback((function(o,i){C(e.createElement(x,{point:o}),[o.x+a.left,o.y+a.top],"top"),c&&c(o,i)}),[C,x,a.left,a.top,c]),k=e.useCallback((function(e,o){S(),h&&h(e,o)}),[S,h]),w=e.useCallback((function(e,o){v&&v(e,o)}),[v]),j=e.useCallback((function(o,i){C(e.createElement(x,{point:o}),[o.x+a.left,o.y+a.top],"top"),p&&p(o,i)}),[a.left,a.top,p,C,x]),E=e.useCallback((function(o,i){C(e.createElement(x,{point:o}),[o.x+a.left,o.y+a.top],"top"),f&&f(o,i)}),[a.left,a.top,f,C,x]),L=e.useCallback((function(e,o){S(),m&&m(e,o)}),[m,S]);return u.jsx(d.Mesh,{nodes:i,width:t,height:n,setCurrent:l,onMouseEnter:M,onMouseMove:T,onMouseLeave:k,onClick:w,onTouchStart:j,onTouchMove:E,onTouchEnd:L,enableTouchCrosshair:b,debug:g})})),W=o.withContainer((function(a){var l=a.data,s=a.xScale,c=void 0===s?{type:"point"}:s,d=a.xFormat,f=a.yScale,m=void 0===f?{type:"linear",min:0,max:"auto"}:f,x=a.yFormat,g=a.layers,b=void 0===g?["grid","markers","axes","areas","crosshair","lines","points","slices","mesh","legends"]:g,y=a.curve,C=void 0===y?"linear":y,M=a.areaBaselineValue,k=void 0===M?0:M,j=a.colors,W=void 0===j?{scheme:"nivo"}:j,P=a.margin,G=a.width,F=a.height,I=a.axisTop,O=a.axisRight,V=a.axisBottom,R=void 0===V?{}:V,q=a.axisLeft,A=void 0===q?{}:q,H=a.enableGridX,Y=void 0===H||H,D=a.enableGridY,X=void 0===D||D,z=a.gridXValues,_=a.gridYValues,N=a.lineWidth,U=void 0===N?2:N,Q=a.enableArea,J=void 0!==Q&&Q,K=a.areaOpacity,Z=void 0===K?.2:K,$=a.areaBlendMode,ee=void 0===$?"normal":$,oe=a.enablePoints,ie=void 0===oe||oe,te=a.pointSymbol,ne=a.pointSize,re=void 0===ne?6:ne,ae=a.pointColor,le=void 0===ae?{from:"color"}:ae,se=a.pointBorderWidth,ue=void 0===se?0:se,ce=a.pointBorderColor,de=void 0===ce?{theme:"background"}:ce,he=a.enablePointLabel,ve=void 0!==he&&he,pe=a.pointLabel,fe=void 0===pe?"data.yFormatted":pe,me=a.pointLabelYOffset,xe=a.defs,ge=void 0===xe?[]:xe,be=a.fill,ye=void 0===be?[]:be,Ce=a.markers,Se=a.legends,Me=void 0===Se?[]:Se,Te=a.isInteractive,ke=void 0===Te||Te,we=a.useMesh,je=void 0!==we&&we,Ee=a.debugMesh,Le=void 0!==Ee&&Ee,Be=a.onMouseEnter,We=a.onMouseMove,Pe=a.onMouseLeave,Ge=a.onClick,Fe=a.onTouchStart,Ie=a.onTouchMove,Oe=a.onTouchEnd,Ve=a.tooltip,Re=void 0===Ve?v:Ve,qe=a.enableSlices,Ae=void 0!==qe&&qe,He=a.debugSlices,Ye=void 0!==He&&He,De=a.sliceTooltip,Xe=void 0===De?p:De,ze=a.enableCrosshair,_e=void 0===ze||ze,Ne=a.crosshairType,Ue=void 0===Ne?"bottom-left":Ne,Qe=a.enableTouchCrosshair,Je=void 0!==Qe&&Qe,Ke=a.role,Ze=void 0===Ke?"img":Ke,$e=a.initialHiddenIds,eo=void 0===$e?[]:$e,oo=o.useDimensions(G,F,P),io=oo.margin,to=oo.innerWidth,no=oo.innerHeight,ro=oo.outerWidth,ao=oo.outerHeight,lo=S({data:l,xScale:c,xFormat:d,yScale:m,yFormat:x,width:to,height:no,colors:W,curve:C,areaBaselineValue:k,pointColor:le,pointBorderColor:de,enableSlices:Ae,initialHiddenIds:eo}),so=lo.legendData,uo=lo.toggleSerie,co=lo.lineGenerator,ho=lo.areaGenerator,vo=lo.series,po=lo.xScale,fo=lo.yScale,mo=lo.slices,xo=lo.points,go=o.useTheme(),bo=i.useInheritedColor(le,go),yo=i.useInheritedColor(de,go),Co=e.useState(null),So=Co[0],Mo=Co[1],To=e.useState(null),ko=To[0],wo=To[1],jo={grid:u.jsx(t.Grid,{theme:go,width:to,height:no,xScale:Y?po:null,yScale:X?fo:null,xValues:z,yValues:_},"grid"),markers:u.jsx(o.CartesianMarkers,{markers:Ce,width:to,height:no,xScale:po,yScale:fo,theme:go},"markers"),axes:u.jsx(t.Axes,{xScale:po,yScale:fo,width:to,height:no,theme:go,top:I,right:O,bottom:R,left:A},"axes"),areas:null,lines:u.jsx(w,{lines:vo,lineGenerator:co,lineWidth:U},"lines"),slices:null,points:null,crosshair:null,mesh:null,legends:Me.map((function(e,o){return u.jsx(n.BoxLegendSvg,h({},e,{containerWidth:to,containerHeight:no,data:e.data||so,theme:go,toggleSerie:e.toggleSerie?uo:void 0}),"legend."+o)}))},Eo=o.bindDefs(ge,vo,ye);return J&&(jo.areas=u.jsx(T,{areaGenerator:ho,areaOpacity:Z,areaBlendMode:ee,lines:vo},"areas")),ke&&!1!==Ae&&(jo.slices=u.jsx(E,{slices:mo,axis:Ae,debug:Ye,height:no,tooltip:Xe,current:ko,setCurrent:wo,onMouseEnter:Be,onMouseMove:We,onMouseLeave:Pe,onClick:Ge,onTouchStart:Fe,onTouchMove:Ie,onTouchEnd:Oe},"slices")),ie&&(jo.points=u.jsx(L,{points:xo,symbol:te,size:re,color:bo,borderWidth:ue,borderColor:yo,enableLabel:ve,label:fe,labelYOffset:me},"points")),ke&&_e&&(null!==So&&(jo.crosshair=u.jsx(r.Crosshair,{width:to,height:no,x:So.x,y:So.y,type:Ue},"crosshair")),null!==ko&&(jo.crosshair=u.jsx(r.Crosshair,{width:to,height:no,x:ko.x,y:ko.y,type:Ae},"crosshair"))),ke&&je&&!1===Ae&&(jo.mesh=u.jsx(B,{points:xo,width:to,height:no,margin:io,current:So,setCurrent:Mo,onMouseEnter:Be,onMouseMove:We,onMouseLeave:Pe,onClick:Ge,onTouchStart:Fe,onTouchMove:Ie,onTouchEnd:Oe,tooltip:Re,enableTouchCrosshair:Je,debug:Le},"mesh")),u.jsx(o.SvgWrapper,{defs:Eo,width:ro,height:ao,margin:io,role:Ze,children:b.map((function(o,i){return"function"==typeof o?u.jsx(e.Fragment,{children:o(h({},a,{innerWidth:to,innerHeight:no,series:vo,slices:mo,points:xo,xScale:po,yScale:fo,lineGenerator:co,areaGenerator:ho,currentPoint:So,setCurrentPoint:Mo,currentSlice:ko,setCurrentSlice:wo}))},i):jo[o]}))})})),P=o.withContainer((function(i){var a=e.useRef(null),l=i.width,s=i.height,c=i.margin,p=i.pixelRatio,f=void 0===p?"undefined"!=typeof window&&window.devicePixelRatio||1:p,m=i.data,x=i.xScale,g=void 0===x?{type:"point"}:x,b=i.xFormat,y=i.yScale,C=void 0===y?{type:"linear",min:0,max:"auto"}:y,M=i.yFormat,T=i.curve,k=void 0===T?"linear":T,w=i.layers,j=void 0===w?["grid","markers","axes","areas","crosshair","lines","points","slices","mesh","legends"]:w,E=i.colors,L=void 0===E?{scheme:"nivo"}:E,B=i.lineWidth,W=void 0===B?2:B,P=i.enableArea,G=void 0!==P&&P,F=i.areaBaselineValue,I=void 0===F?0:F,O=i.areaOpacity,V=void 0===O?.2:O,R=i.enablePoints,q=void 0===R||R,A=i.pointSize,H=void 0===A?6:A,Y=i.pointColor,D=void 0===Y?{from:"color"}:Y,X=i.pointBorderWidth,z=void 0===X?0:X,_=i.pointBorderColor,N=void 0===_?{theme:"background"}:_,U=i.enableGridX,Q=void 0===U||U,J=i.gridXValues,K=i.enableGridY,Z=void 0===K||K,$=i.gridYValues,ee=i.axisTop,oe=i.axisRight,ie=i.axisBottom,te=void 0===ie?{}:ie,ne=i.axisLeft,re=void 0===ne?{}:ne,ae=i.legends,le=void 0===ae?[]:ae,se=i.isInteractive,ue=void 0===se||se,ce=i.debugMesh,de=void 0!==ce&&ce,he=i.onMouseLeave,ve=i.onClick,pe=i.tooltip,fe=void 0===pe?v:pe,me=i.canvasRef,xe=o.useDimensions(l,s,c),ge=xe.margin,be=xe.innerWidth,ye=xe.innerHeight,Ce=xe.outerWidth,Se=xe.outerHeight,Me=o.useTheme(),Te=e.useState(null),ke=Te[0],we=Te[1],je=S({data:m,xScale:g,xFormat:b,yScale:C,yFormat:M,width:be,height:ye,colors:L,curve:k,areaBaselineValue:I,pointColor:D,pointBorderColor:N}),Ee=je.lineGenerator,Le=je.areaGenerator,Be=je.series,We=je.xScale,Pe=je.yScale,Ge=je.points,Fe=d.useVoronoiMesh({points:Ge,width:be,height:ye,debug:de}),Ie=Fe.delaunay,Oe=Fe.voronoi;e.useEffect((function(){me&&(me.current=a.current),a.current.width=Ce*f,a.current.height=Se*f;var e=a.current.getContext("2d");e.scale(f,f),e.fillStyle=Me.background,e.fillRect(0,0,Ce,Se),e.translate(ge.left,ge.top),j.forEach((function(o){if("function"==typeof o&&o({ctx:e,innerWidth:be,innerHeight:ye,series:Be,points:Ge,xScale:We,yScale:Pe,lineWidth:W,lineGenerator:Ee,areaGenerator:Le,currentPoint:ke,setCurrentPoint:we}),"grid"===o&&Me.grid.line.strokeWidth>0&&(e.lineWidth=Me.grid.line.strokeWidth,e.strokeStyle=Me.grid.line.stroke,Q&&t.renderGridLinesToCanvas(e,{width:be,height:ye,scale:We,axis:"x",values:J}),Z&&t.renderGridLinesToCanvas(e,{width:be,height:ye,scale:Pe,axis:"y",values:$})),"axes"===o&&t.renderAxesToCanvas(e,{xScale:We,yScale:Pe,width:be,height:ye,top:ee,right:oe,bottom:te,left:re,theme:Me}),"areas"===o&&!0===G){e.save(),e.globalAlpha=V,Le.context(e);for(var i=Be.length-1;i>=0;i--)e.fillStyle=Be[i].color,e.beginPath(),Le(Be[i].data.map((function(e){return e.position}))),e.fill();e.restore()}if("lines"===o&&(Ee.context(e),Be.forEach((function(o){e.strokeStyle=o.color,e.lineWidth=W,e.beginPath(),Ee(o.data.map((function(e){return e.position}))),e.stroke()}))),"points"===o&&!0===q&&H>0&&Ge.forEach((function(o){e.fillStyle=o.color,e.beginPath(),e.arc(o.x,o.y,H/2,0,2*Math.PI),e.fill(),z>0&&(e.strokeStyle=o.borderColor,e.lineWidth=z,e.stroke())})),"mesh"===o&&!0===de&&(d.renderVoronoiToCanvas(e,Oe),ke&&d.renderVoronoiCellToCanvas(e,Oe,ke.index)),"legends"===o){var r=Be.map((function(e){return{id:e.id,label:e.id,color:e.color}})).reverse();le.forEach((function(o){n.renderLegendToCanvas(e,h({},o,{data:o.data||r,containerWidth:be,containerHeight:ye,theme:Me}))}))}}))}),[a,Ce,Se,j,Me,Ee,Be,We,Pe,Q,J,Z,$,ee,oe,te,re,le,Ge,q,H,ke]);var Ve=e.useCallback((function(e){var i=o.getRelativeCursor(a.current,e),t=i[0],n=i[1];if(!o.isCursorInRect(ge.left,ge.top,be,ye,t,n))return null;var r=Ie.find(t-ge.left,n-ge.top);return Ge[r]}),[a,ge,be,ye,Ie]),Re=r.useTooltip(),qe=Re.showTooltipFromEvent,Ae=Re.hideTooltip,He=e.useCallback((function(o){var i=Ve(o);we(i),i?qe(e.createElement(fe,{point:i}),o):Ae()}),[Ve,we,qe,Ae,fe]),Ye=e.useCallback((function(e){Ae(),we(null),ke&&he&&he(ke,e)}),[Ae,we,he]),De=e.useCallback((function(e){if(ve){var o=Ve(e);o&&ve(o,e)}}),[Ve,ve]);return u.jsx("canvas",{ref:a,width:Ce*f,height:Se*f,style:{width:Ce,height:Se,cursor:ue?"auto":"normal"},onMouseEnter:ue?He:void 0,onMouseMove:ue?He:void 0,onMouseLeave:ue?Ye:void 0,onClick:ue?De:void 0})})),G=e.forwardRef((function(e,o){return u.jsx(P,h({},e,{canvasRef:o}))})),F=e.forwardRef((function(e,i){return u.jsx(o.ResponsiveWrapper,{children:function(o){var t=o.width,n=o.height;return u.jsx(G,h({width:t,height:n},e,{ref:i}))}})}));exports.LINE_UNIQUE_ID_PREFIX=C,exports.Line=W,exports.LineCanvas=G,exports.LineCanvasDefaultProps=x,exports.LineDefaultProps=m,exports.ResponsiveLine=function(e){return u.jsx(o.ResponsiveWrapper,{children:function(o){var i=o.width,t=o.height;return u.jsx(W,h({width:i,height:t},e))}})},exports.ResponsiveLineCanvas=F,exports.useAreaGenerator=b,exports.useLine=S,exports.useLineGenerator=g,exports.useSlices=y;
 //# sourceMappingURL=nivo-line.cjs.js.map
diff --git a/dist/nivo-line.cjs.js.map b/dist/nivo-line.cjs.js.map
index 101aaa11e8b5268106846290bf0931b80b44b11b..89b5e0a068359bfbbd0821726f441d95728c0032 100644
--- a/dist/nivo-line.cjs.js.map
+++ b/dist/nivo-line.cjs.js.map
@@ -1 +1 @@
-{"version":3,"file":"nivo-line.cjs.js","sources":["../src/PointTooltip.js","../src/SliceTooltip.js","../src/props.js","../src/hooks.js","../src/Areas.js","../src/LinesItem.js","../src/Lines.js","../src/SlicesItem.js","../src/Slices.js","../src/Points.js","../src/Mesh.js","../src/Line.js","../src/LineCanvas.js","../src/ResponsiveLineCanvas.js","../src/ResponsiveLine.js"],"sourcesContent":["import { memo } from 'react'\nimport { BasicTooltip } from '@nivo/tooltip'\n\nconst LinePointTooltip = ({ point }) => {\n    return (\n        <BasicTooltip\n            id={\n                <span>\n                    x: <strong>{point.data.xFormatted}</strong>, y:{' '}\n                    <strong>{point.data.yFormatted}</strong>\n                </span>\n            }\n            enableChip={true}\n            color={point.serieColor}\n        />\n    )\n}\n\nexport default memo(LinePointTooltip)\n","import { memo } from 'react'\nimport { useTheme } from '@nivo/core'\nimport { Chip, TableTooltip } from '@nivo/tooltip'\n\nconst SliceTooltip = ({ slice, axis }) => {\n    const theme = useTheme()\n    const otherAxis = axis === 'x' ? 'y' : 'x'\n\n    return (\n        <TableTooltip\n            rows={slice.points.map(point => [\n                <Chip key=\"chip\" color={point.serieColor} style={theme.tooltip.chip} />,\n                point.serieId,\n                <span key=\"value\" style={theme.tooltip.tableCellValue}>\n                    {point.data[`${otherAxis}Formatted`]}\n                </span>,\n            ])}\n        />\n    )\n}\n\nexport default memo(SliceTooltip)\n","import PointTooltip from './PointTooltip'\nimport SliceTooltip from './SliceTooltip'\n\nconst commonDefaultProps = {\n    curve: 'linear',\n\n    xScale: {\n        type: 'point',\n    },\n    yScale: {\n        type: 'linear',\n        min: 0,\n        max: 'auto',\n    },\n\n    layers: [\n        'grid',\n        'markers',\n        'axes',\n        'areas',\n        'crosshair',\n        'lines',\n        'points',\n        'slices',\n        'mesh',\n        'legends',\n    ],\n    axisBottom: {},\n    axisLeft: {},\n    enableGridX: true,\n    enableGridY: true,\n\n    enablePoints: true,\n    pointSize: 6,\n    pointColor: { from: 'color' },\n    pointBorderWidth: 0,\n    pointBorderColor: { theme: 'background' },\n    enablePointLabel: false,\n    pointLabel: 'yFormatted',\n\n    colors: { scheme: 'nivo' },\n    enableArea: false,\n    areaBaselineValue: 0,\n    areaOpacity: 0.2,\n    areaBlendMode: 'normal',\n    lineWidth: 2,\n\n    legends: [],\n\n    isInteractive: true,\n    tooltip: PointTooltip,\n    enableSlices: false,\n    debugSlices: false,\n    sliceTooltip: SliceTooltip,\n    debugMesh: false,\n    enableCrosshair: true,\n    crosshairType: 'bottom-left',\n}\n\nexport const LineDefaultProps = {\n    ...commonDefaultProps,\n    enablePointLabel: false,\n    useMesh: false,\n    enableTouchCrosshair: false,\n    animate: true,\n    motionConfig: 'gentle',\n    defs: [],\n    fill: [],\n    role: 'img',\n}\n\nexport const LineCanvasDefaultProps = {\n    ...commonDefaultProps,\n    pixelRatio: typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1,\n}\n","import { useCallback, useMemo, useState } from 'react'\nimport { area, line } from 'd3-shape'\nimport { curveFromProp, useTheme, useValueFormatter } from '@nivo/core'\nimport { useOrdinalColorScale, useInheritedColor } from '@nivo/colors'\nimport { computeXYScalesForSeries } from '@nivo/scales'\nimport uniqueId from 'lodash/uniqueId'\nimport { LineDefaultProps } from './props'\n\nexport const useLineGenerator = ({ curve }) => {\n    return useMemo(\n        () =>\n            line()\n                .defined(d => d.x !== null && d.y !== null)\n                .x(d => d.x)\n                .y(d => d.y)\n                .curve(curveFromProp(curve)),\n        [curve]\n    )\n}\n\nexport const useAreaGenerator = ({ curve, yScale, areaBaselineValue }) => {\n    return useMemo(() => {\n        return area()\n            .defined(d => d.x !== null && d.y !== null)\n            .x(d => d.x)\n            .y1(d => d.y)\n            .curve(curveFromProp(curve))\n            .y0(yScale(areaBaselineValue))\n    }, [curve, yScale, areaBaselineValue])\n}\n\nconst usePoints = ({ series, getPointColor, getPointBorderColor, formatX, formatY }) => {\n    return useMemo(() => {\n        return series.reduce((acc, serie) => {\n            return [\n                ...acc,\n                ...serie.data\n                    .filter(datum => datum.position.x !== null && datum.position.y !== null)\n                    .map((datum, i) => {\n                        const point = {\n                            id: `${serie.id}.${i}`,\n                            index: acc.length + i,\n                            serieId: serie.id,\n                            serieColor: serie.color,\n                            x: datum.position.x,\n                            y: datum.position.y,\n                        }\n                        point.color = getPointColor(serie)\n                        point.borderColor = getPointBorderColor(point)\n                        point.data = {\n                            ...datum.data,\n                            xFormatted: formatX(datum.data.x),\n                            yFormatted: formatY(datum.data.y),\n                        }\n\n                        return point\n                    }),\n            ]\n        }, [])\n    }, [series, getPointColor, getPointBorderColor, formatX, formatY])\n}\n\nexport const useSlices = ({ componentId, enableSlices, points, width, height }) => {\n    return useMemo(() => {\n        if (enableSlices === false) return []\n\n        if (enableSlices === 'x') {\n            const map = new Map()\n            points.forEach(point => {\n                if (point.data.x === null || point.data.y === null) return\n                if (!map.has(point.x)) map.set(point.x, [point])\n                else map.get(point.x).push(point)\n            })\n            return Array.from(map.entries())\n                .sort((a, b) => a[0] - b[0])\n                .map(([x, slicePoints], i, slices) => {\n                    const prevSlice = slices[i - 1]\n                    const nextSlice = slices[i + 1]\n\n                    let x0\n                    if (!prevSlice) x0 = x\n                    else x0 = x - (x - prevSlice[0]) / 2\n\n                    let sliceWidth\n                    if (!nextSlice) sliceWidth = width - x0\n                    else sliceWidth = x - x0 + (nextSlice[0] - x) / 2\n\n                    return {\n                        id: `slice:${componentId}:${x}`,\n                        x0,\n                        x,\n                        y0: 0,\n                        y: 0,\n                        width: sliceWidth,\n                        height,\n                        points: slicePoints.reverse(),\n                    }\n                })\n        } else if (enableSlices === 'y') {\n            const map = new Map()\n            points.forEach(point => {\n                if (point.data.x === null || point.data.y === null) return\n                if (!map.has(point.y)) map.set(point.y, [point])\n                else map.get(point.y).push(point)\n            })\n            return Array.from(map.entries())\n                .sort((a, b) => a[0] - b[0])\n                .map(([y, slicePoints], i, slices) => {\n                    const prevSlice = slices[i - 1]\n                    const nextSlice = slices[i + 1]\n\n                    let y0\n                    if (!prevSlice) y0 = y\n                    else y0 = y - (y - prevSlice[0]) / 2\n\n                    let sliceHeight\n                    if (!nextSlice) sliceHeight = height - y0\n                    else sliceHeight = y - y0 + (nextSlice[0] - y) / 2\n\n                    return {\n                        id: y,\n                        x0: 0,\n                        x: 0,\n                        y0,\n                        y,\n                        width,\n                        height: sliceHeight,\n                        points: slicePoints.reverse(),\n                    }\n                })\n        }\n    }, [componentId, enableSlices, height, points, width])\n}\n\nexport const LINE_UNIQUE_ID_PREFIX = 'line'\n\nexport const useLine = ({\n    data,\n    xScale: xScaleSpec = LineDefaultProps.xScale,\n    xFormat,\n    yScale: yScaleSpec = LineDefaultProps.yScale,\n    yFormat,\n    width,\n    height,\n    colors = LineDefaultProps.colors,\n    curve = LineDefaultProps.curve,\n    areaBaselineValue = LineDefaultProps.areaBaselineValue,\n    pointColor = LineDefaultProps.pointColor,\n    pointBorderColor = LineDefaultProps.pointBorderColor,\n    enableSlices = LineDefaultProps.enableSlicesTooltip,\n}) => {\n    const [componentId] = useState(uniqueId(LINE_UNIQUE_ID_PREFIX))\n    const formatX = useValueFormatter(xFormat)\n    const formatY = useValueFormatter(yFormat)\n    const getColor = useOrdinalColorScale(colors, 'id')\n    const theme = useTheme()\n    const getPointColor = useInheritedColor(pointColor, theme)\n    const getPointBorderColor = useInheritedColor(pointBorderColor, theme)\n    const [hiddenIds, setHiddenIds] = useState([])\n\n    const {\n        xScale,\n        yScale,\n        series: rawSeries,\n    } = useMemo(\n        () =>\n            computeXYScalesForSeries(\n                data.filter(item => hiddenIds.indexOf(item.id) === -1),\n                xScaleSpec,\n                yScaleSpec,\n                width,\n                height\n            ),\n        [data, hiddenIds, xScaleSpec, yScaleSpec, width, height]\n    )\n\n    const { legendData, series } = useMemo(() => {\n        const dataWithColor = data.map(line => ({\n            id: line.id,\n            label: line.id,\n            color: getColor(line),\n        }))\n        const series = dataWithColor\n            .map(datum => ({\n                ...rawSeries.find(serie => serie.id === datum.id),\n                color: datum.color,\n            }))\n            .filter(item => Boolean(item.id))\n        const legendData = dataWithColor\n            .map(item => ({ ...item, hidden: !series.find(serie => serie.id === item.id) }))\n            .reverse()\n\n        return { legendData, series }\n    }, [data, rawSeries, getColor])\n\n    const toggleSerie = useCallback(id => {\n        setHiddenIds(state =>\n            state.indexOf(id) > -1 ? state.filter(item => item !== id) : [...state, id]\n        )\n    }, [])\n\n    const points = usePoints({\n        series,\n        getPointColor,\n        getPointBorderColor,\n        formatX,\n        formatY,\n    })\n\n    const slices = useSlices({\n        componentId,\n        enableSlices,\n        points,\n        width,\n        height,\n    })\n\n    const lineGenerator = useLineGenerator({ curve })\n    const areaGenerator = useAreaGenerator({\n        curve,\n        yScale,\n        areaBaselineValue,\n    })\n\n    return {\n        legendData,\n        toggleSerie,\n        lineGenerator,\n        areaGenerator,\n        getColor,\n        series,\n        xScale,\n        yScale,\n        slices,\n        points,\n    }\n}\n","import { memo } from 'react'\nimport { useSpring, animated } from '@react-spring/web'\nimport { useAnimatedPath, useMotionConfig } from '@nivo/core'\n\nconst AreaPath = ({ areaBlendMode, areaOpacity, color, fill, path }) => {\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedPath = useAnimatedPath(path)\n    const animatedProps = useSpring({\n        color,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <animated.path\n            d={animatedPath}\n            fill={fill ? fill : animatedProps.color}\n            fillOpacity={areaOpacity}\n            strokeWidth={0}\n            style={{\n                mixBlendMode: areaBlendMode,\n            }}\n        />\n    )\n}\n\nconst Areas = ({ areaGenerator, areaOpacity, areaBlendMode, lines }) => {\n    const computedLines = lines.slice(0).reverse()\n\n    return (\n        <g>\n            {computedLines.map(line => (\n                <AreaPath\n                    key={line.id}\n                    path={areaGenerator(line.data.map(d => d.position))}\n                    {...{ areaOpacity, areaBlendMode, ...line }}\n                />\n            ))}\n        </g>\n    )\n}\n\nexport default memo(Areas)\n","import { memo, useMemo } from 'react'\nimport { animated } from '@react-spring/web'\nimport { useAnimatedPath } from '@nivo/core'\n\nconst LinesItem = ({ lineGenerator, points, color, thickness }) => {\n    const path = useMemo(() => lineGenerator(points), [lineGenerator, points])\n    const animatedPath = useAnimatedPath(path)\n\n    return <animated.path d={animatedPath} fill=\"none\" strokeWidth={thickness} stroke={color} />\n}\n\nexport default memo(LinesItem)\n","import { memo } from 'react'\nimport LinesItem from './LinesItem'\n\nconst Lines = ({ lines, lineGenerator, lineWidth }) => {\n    return lines\n        .slice(0)\n        .reverse()\n        .map(({ id, data, color }) => (\n            <LinesItem\n                key={id}\n                id={id}\n                points={data.map(d => d.position)}\n                lineGenerator={lineGenerator}\n                color={color}\n                thickness={lineWidth}\n            />\n        ))\n}\n\nexport default memo(Lines)\n","import { createElement, memo, useCallback } from 'react'\nimport { useTooltip } from '@nivo/tooltip'\n\nconst SlicesItem = ({\n    slice,\n    slices,\n    axis,\n    debug,\n    tooltip,\n    isCurrent,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n}) => {\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const handleMouseEnter = useCallback(\n        event => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n            setCurrent(slice)\n            onMouseEnter && onMouseEnter(slice, event)\n        },\n        [showTooltipFromEvent, tooltip, slice, axis, setCurrent, onMouseEnter]\n    )\n\n    const handleMouseMove = useCallback(\n        event => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n            onMouseMove && onMouseMove(slice, event)\n        },\n        [showTooltipFromEvent, tooltip, slice, axis, onMouseMove]\n    )\n\n    const handleMouseLeave = useCallback(\n        event => {\n            hideTooltip()\n            setCurrent(null)\n            onMouseLeave && onMouseLeave(slice, event)\n        },\n        [hideTooltip, setCurrent, onMouseLeave, slice]\n    )\n\n    const handleClick = useCallback(\n        event => {\n            onClick && onClick(slice, event)\n        },\n        [slice, onClick]\n    )\n\n    const handeOnTouchStart = useCallback(\n        event => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n            setCurrent(slice)\n            onTouchStart && onTouchStart(slice, event)\n        },\n        [axis, onTouchStart, setCurrent, showTooltipFromEvent, slice, tooltip]\n    )\n\n    const handeOnTouchMove = useCallback(\n        event => {\n            // This event will be locked to the element that was touched originally\n            // We find the element that is currently being \"hovered over\" by getting the element at the touch point\n            const touchPoint = event.touches[0]\n            const touchingElement = document.elementFromPoint(\n                touchPoint.clientX,\n                touchPoint.clientY\n            )\n            // Is this a nivo ref?\n            const touchingSliceId = touchingElement?.getAttribute('data-ref')\n            if (touchingSliceId) {\n                // Is this a slice for this graph?\n                const slice = slices.find(slice => slice.id === touchingSliceId)\n                if (slice) {\n                    showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n                    setCurrent(slice)\n                }\n            }\n\n            // Note here, this will pass the original slice, not the one we found\n            // But this can be found with document.elementFromPoint()\n            onTouchMove && onTouchMove(slice, event)\n        },\n        [axis, onTouchMove, setCurrent, showTooltipFromEvent, slice, slices, tooltip]\n    )\n\n    const handleOnTouchEnd = useCallback(\n        event => {\n            hideTooltip()\n            setCurrent(null)\n            onTouchEnd && onTouchEnd(slice, event)\n        },\n        [hideTooltip, setCurrent, onTouchEnd, slice]\n    )\n\n    return (\n        <rect\n            x={slice.x0}\n            y={slice.y0}\n            width={slice.width}\n            height={slice.height}\n            stroke=\"red\"\n            strokeWidth={debug ? 1 : 0}\n            strokeOpacity={0.75}\n            fill=\"red\"\n            fillOpacity={isCurrent && debug ? 0.35 : 0}\n            onMouseEnter={handleMouseEnter}\n            onMouseMove={handleMouseMove}\n            onMouseLeave={handleMouseLeave}\n            onClick={handleClick}\n            onTouchStart={handeOnTouchStart}\n            onTouchMove={handeOnTouchMove}\n            onTouchEnd={handleOnTouchEnd}\n            data-ref={slice.id}\n        />\n    )\n}\n\nexport default memo(SlicesItem)\n","import { memo } from 'react'\nimport SlicesItem from './SlicesItem'\n\nconst Slices = ({\n    slices,\n    axis,\n    debug,\n    height,\n    tooltip,\n    current,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n}) => {\n    return slices.map(slice => (\n        <SlicesItem\n            key={slice.id}\n            slice={slice}\n            slices={slices}\n            axis={axis}\n            debug={debug}\n            height={height}\n            tooltip={tooltip}\n            setCurrent={setCurrent}\n            isCurrent={current !== null && current.id === slice.id}\n            onMouseEnter={onMouseEnter}\n            onMouseMove={onMouseMove}\n            onMouseLeave={onMouseLeave}\n            onClick={onClick}\n            onTouchStart={onTouchStart}\n            onTouchMove={onTouchMove}\n            onTouchEnd={onTouchEnd}\n        />\n    ))\n}\n\nexport default memo(Slices)\n","import { memo } from 'react'\nimport { getLabelGenerator, DotsItem, useTheme } from '@nivo/core'\n\nconst Points = ({ points, symbol, size, borderWidth, enableLabel, label, labelYOffset }) => {\n    const theme = useTheme()\n    const getLabel = getLabelGenerator(label)\n\n    /**\n     * We reverse the `points` array so that points from the lower lines in stacked lines\n     * graph are drawn on top. See https://github.com/plouc/nivo/issues/1051.\n     */\n    const mappedPoints = points\n        .slice(0)\n        .reverse()\n        .map(point => {\n            const mappedPoint = {\n                id: point.id,\n                x: point.x,\n                y: point.y,\n                datum: point.data,\n                fill: point.color,\n                stroke: point.borderColor,\n                label: enableLabel ? getLabel(point) : null,\n            }\n\n            return mappedPoint\n        })\n\n    return (\n        <g>\n            {mappedPoints.map(point => (\n                <DotsItem\n                    key={point.id}\n                    x={point.x}\n                    y={point.y}\n                    datum={point.datum}\n                    symbol={symbol}\n                    size={size}\n                    color={point.fill}\n                    borderWidth={borderWidth}\n                    borderColor={point.stroke}\n                    label={point.label}\n                    labelYOffset={labelYOffset}\n                    theme={theme}\n                />\n            ))}\n        </g>\n    )\n}\n\nexport default memo(Points)\n","import { createElement, memo, useCallback } from 'react'\nimport { useTooltip } from '@nivo/tooltip'\nimport { Mesh as BaseMesh } from '@nivo/voronoi'\n\nconst Mesh = ({\n    points,\n    width,\n    height,\n    margin,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n    tooltip,\n    debug,\n    enableTouchCrosshair,\n}) => {\n    const { showTooltipAt, hideTooltip } = useTooltip()\n\n    const handleMouseEnter = useCallback(\n        (point, event) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onMouseEnter && onMouseEnter(point, event)\n        },\n        [showTooltipAt, tooltip, onMouseEnter, margin]\n    )\n\n    const handleMouseMove = useCallback(\n        (point, event) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onMouseMove && onMouseMove(point, event)\n        },\n        [showTooltipAt, tooltip, margin.left, margin.top, onMouseMove]\n    )\n\n    const handleMouseLeave = useCallback(\n        (point, event) => {\n            hideTooltip()\n            onMouseLeave && onMouseLeave(point, event)\n        },\n        [hideTooltip, onMouseLeave]\n    )\n\n    const handleClick = useCallback(\n        (point, event) => {\n            onClick && onClick(point, event)\n        },\n        [onClick]\n    )\n\n    const handleTouchStart = useCallback(\n        (point, event) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onTouchStart && onTouchStart(point, event)\n        },\n        [margin.left, margin.top, onTouchStart, showTooltipAt, tooltip]\n    )\n\n    const handleTouchMove = useCallback(\n        (point, event) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onTouchMove && onTouchMove(point, event)\n        },\n        [margin.left, margin.top, onTouchMove, showTooltipAt, tooltip]\n    )\n\n    const handleTouchEnd = useCallback(\n        (point, event) => {\n            hideTooltip()\n            onTouchEnd && onTouchEnd(point, event)\n        },\n        [onTouchEnd, hideTooltip]\n    )\n\n    return (\n        <BaseMesh\n            nodes={points}\n            width={width}\n            height={height}\n            setCurrent={setCurrent}\n            onMouseEnter={handleMouseEnter}\n            onMouseMove={handleMouseMove}\n            onMouseLeave={handleMouseLeave}\n            onClick={handleClick}\n            onTouchStart={handleTouchStart}\n            onTouchMove={handleTouchMove}\n            onTouchEnd={handleTouchEnd}\n            enableTouchCrosshair={enableTouchCrosshair}\n            debug={debug}\n        />\n    )\n}\n\nexport default memo(Mesh)\n","import { Fragment, useState } from 'react'\nimport {\n    bindDefs,\n    withContainer,\n    useDimensions,\n    useTheme,\n    SvgWrapper,\n    CartesianMarkers,\n} from '@nivo/core'\nimport { useInheritedColor } from '@nivo/colors'\nimport { Axes, Grid } from '@nivo/axes'\nimport { BoxLegendSvg } from '@nivo/legends'\nimport { Crosshair } from '@nivo/tooltip'\nimport { useLine } from './hooks'\nimport Areas from './Areas'\nimport Lines from './Lines'\nimport Slices from './Slices'\nimport Points from './Points'\nimport Mesh from './Mesh'\nimport PointTooltip from './PointTooltip'\nimport SliceTooltip from './SliceTooltip'\n\nconst Line = props => {\n    const {\n        data,\n        xScale: xScaleSpec = { type: 'point' },\n        xFormat,\n        yScale: yScaleSpec = {\n            type: 'linear',\n            min: 0,\n            max: 'auto',\n        },\n        yFormat,\n        layers = [\n            'grid',\n            'markers',\n            'axes',\n            'areas',\n            'crosshair',\n            'lines',\n            'points',\n            'slices',\n            'mesh',\n            'legends',\n        ],\n        curve = 'linear',\n        areaBaselineValue = 0,\n\n        colors = { scheme: 'nivo' },\n\n        margin: partialMargin,\n        width,\n        height,\n\n        axisTop,\n        axisRight,\n        axisBottom = {},\n        axisLeft = {},\n        enableGridX = true,\n        enableGridY = true,\n        gridXValues,\n        gridYValues,\n\n        lineWidth = 2,\n        enableArea = false,\n        areaOpacity = 0.2,\n        areaBlendMode = 'normal',\n\n        enablePoints = true,\n        pointSymbol,\n        pointSize = 6,\n        pointColor = { from: 'color' },\n        pointBorderWidth = 0,\n        pointBorderColor = { theme: 'background' },\n        enablePointLabel = false,\n        pointLabel = 'data.yFormatted',\n        pointLabelYOffset,\n\n        defs = [],\n        fill = [],\n\n        markers,\n\n        legends = [],\n\n        isInteractive = true,\n\n        useMesh = false,\n        debugMesh = false,\n\n        onMouseEnter,\n        onMouseMove,\n        onMouseLeave,\n        onClick,\n        onTouchStart,\n        onTouchMove,\n        onTouchEnd,\n\n        tooltip = PointTooltip,\n\n        enableSlices = false,\n        debugSlices = false,\n        sliceTooltip = SliceTooltip,\n\n        enableCrosshair = true,\n        crosshairType = 'bottom-left',\n        enableTouchCrosshair = false,\n\n        role = 'img',\n    } = props\n\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const {\n        legendData,\n        toggleSerie,\n        lineGenerator,\n        areaGenerator,\n        series,\n        xScale,\n        yScale,\n        slices,\n        points,\n    } = useLine({\n        data,\n        xScale: xScaleSpec,\n        xFormat,\n        yScale: yScaleSpec,\n        yFormat,\n        width: innerWidth,\n        height: innerHeight,\n        colors,\n        curve,\n        areaBaselineValue,\n        pointColor,\n        pointBorderColor,\n        enableSlices,\n    })\n\n    const theme = useTheme()\n    const getPointColor = useInheritedColor(pointColor, theme)\n    const getPointBorderColor = useInheritedColor(pointBorderColor, theme)\n\n    const [currentPoint, setCurrentPoint] = useState(null)\n    const [currentSlice, setCurrentSlice] = useState(null)\n\n    const layerById = {\n        grid: (\n            <Grid\n                key=\"grid\"\n                theme={theme}\n                width={innerWidth}\n                height={innerHeight}\n                xScale={enableGridX ? xScale : null}\n                yScale={enableGridY ? yScale : null}\n                xValues={gridXValues}\n                yValues={gridYValues}\n            />\n        ),\n        markers: (\n            <CartesianMarkers\n                key=\"markers\"\n                markers={markers}\n                width={innerWidth}\n                height={innerHeight}\n                xScale={xScale}\n                yScale={yScale}\n                theme={theme}\n            />\n        ),\n        axes: (\n            <Axes\n                key=\"axes\"\n                xScale={xScale}\n                yScale={yScale}\n                width={innerWidth}\n                height={innerHeight}\n                theme={theme}\n                top={axisTop}\n                right={axisRight}\n                bottom={axisBottom}\n                left={axisLeft}\n            />\n        ),\n        areas: null,\n        lines: (\n            <Lines key=\"lines\" lines={series} lineGenerator={lineGenerator} lineWidth={lineWidth} />\n        ),\n        slices: null,\n        points: null,\n        crosshair: null,\n        mesh: null,\n        legends: legends.map((legend, i) => (\n            <BoxLegendSvg\n                key={`legend.${i}`}\n                {...legend}\n                containerWidth={innerWidth}\n                containerHeight={innerHeight}\n                data={legend.data || legendData}\n                theme={theme}\n                toggleSerie={legend.toggleSerie ? toggleSerie : undefined}\n            />\n        )),\n    }\n\n    const boundDefs = bindDefs(defs, series, fill)\n\n    if (enableArea) {\n        layerById.areas = (\n            <Areas\n                key=\"areas\"\n                areaGenerator={areaGenerator}\n                areaOpacity={areaOpacity}\n                areaBlendMode={areaBlendMode}\n                lines={series}\n            />\n        )\n    }\n\n    if (isInteractive && enableSlices !== false) {\n        layerById.slices = (\n            <Slices\n                key=\"slices\"\n                slices={slices}\n                axis={enableSlices}\n                debug={debugSlices}\n                height={innerHeight}\n                tooltip={sliceTooltip}\n                current={currentSlice}\n                setCurrent={setCurrentSlice}\n                onMouseEnter={onMouseEnter}\n                onMouseMove={onMouseMove}\n                onMouseLeave={onMouseLeave}\n                onClick={onClick}\n                onTouchStart={onTouchStart}\n                onTouchMove={onTouchMove}\n                onTouchEnd={onTouchEnd}\n            />\n        )\n    }\n\n    if (enablePoints) {\n        layerById.points = (\n            <Points\n                key=\"points\"\n                points={points}\n                symbol={pointSymbol}\n                size={pointSize}\n                color={getPointColor}\n                borderWidth={pointBorderWidth}\n                borderColor={getPointBorderColor}\n                enableLabel={enablePointLabel}\n                label={pointLabel}\n                labelYOffset={pointLabelYOffset}\n            />\n        )\n    }\n\n    if (isInteractive && enableCrosshair) {\n        if (currentPoint !== null) {\n            layerById.crosshair = (\n                <Crosshair\n                    key=\"crosshair\"\n                    width={innerWidth}\n                    height={innerHeight}\n                    x={currentPoint.x}\n                    y={currentPoint.y}\n                    type={crosshairType}\n                />\n            )\n        }\n        if (currentSlice !== null) {\n            layerById.crosshair = (\n                <Crosshair\n                    key=\"crosshair\"\n                    width={innerWidth}\n                    height={innerHeight}\n                    x={currentSlice.x}\n                    y={currentSlice.y}\n                    type={enableSlices}\n                />\n            )\n        }\n    }\n\n    if (isInteractive && useMesh && enableSlices === false) {\n        layerById.mesh = (\n            <Mesh\n                key=\"mesh\"\n                points={points}\n                width={innerWidth}\n                height={innerHeight}\n                margin={margin}\n                current={currentPoint}\n                setCurrent={setCurrentPoint}\n                onMouseEnter={onMouseEnter}\n                onMouseMove={onMouseMove}\n                onMouseLeave={onMouseLeave}\n                onClick={onClick}\n                onTouchStart={onTouchStart}\n                onTouchMove={onTouchMove}\n                onTouchEnd={onTouchEnd}\n                tooltip={tooltip}\n                enableTouchCrosshair={enableTouchCrosshair}\n                debug={debugMesh}\n            />\n        )\n    }\n\n    return (\n        <SvgWrapper\n            defs={boundDefs}\n            width={outerWidth}\n            height={outerHeight}\n            margin={margin}\n            role={role}\n        >\n            {layers.map((layer, i) => {\n                if (typeof layer === 'function') {\n                    return (\n                        <Fragment key={i}>\n                            {layer({\n                                ...props,\n                                innerWidth,\n                                innerHeight,\n                                series,\n                                slices,\n                                points,\n                                xScale,\n                                yScale,\n                                lineGenerator,\n                                areaGenerator,\n                                currentPoint,\n                                setCurrentPoint,\n                                currentSlice,\n                                setCurrentSlice,\n                            })}\n                        </Fragment>\n                    )\n                }\n\n                return layerById[layer]\n            })}\n        </SvgWrapper>\n    )\n}\n\nexport default withContainer(Line)\n","import { createElement, useRef, useEffect, useState, useCallback, forwardRef } from 'react'\nimport {\n    withContainer,\n    useDimensions,\n    useTheme,\n    getRelativeCursor,\n    isCursorInRect,\n} from '@nivo/core'\nimport { renderAxesToCanvas, renderGridLinesToCanvas } from '@nivo/axes'\nimport { renderLegendToCanvas } from '@nivo/legends'\nimport { useTooltip } from '@nivo/tooltip'\nimport { useVoronoiMesh, renderVoronoiToCanvas, renderVoronoiCellToCanvas } from '@nivo/voronoi'\nimport { useLine } from './hooks'\nimport PointTooltip from './PointTooltip'\n\nconst LineCanvas = props => {\n    const canvasEl = useRef(null)\n    const {\n        width,\n        height,\n        margin: partialMargin,\n        pixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1,\n\n        data,\n        xScale: xScaleSpec = { type: 'point' },\n        xFormat,\n        yScale: yScaleSpec = {\n            type: 'linear',\n            min: 0,\n            max: 'auto',\n        },\n        yFormat,\n        curve = 'linear',\n\n        layers = [\n            'grid',\n            'markers',\n            'axes',\n            'areas',\n            'crosshair',\n            'lines',\n            'points',\n            'slices',\n            'mesh',\n            'legends',\n        ],\n\n        colors = { scheme: 'nivo' },\n        lineWidth = 2,\n\n        enableArea = false,\n        areaBaselineValue = 0,\n        areaOpacity = 0.2,\n\n        enablePoints = true,\n        pointSize = 6,\n        pointColor = { from: 'color' },\n        pointBorderWidth = 0,\n        pointBorderColor = { theme: 'background' },\n\n        enableGridX = true,\n        gridXValues,\n        enableGridY = true,\n        gridYValues,\n        axisTop,\n        axisRight,\n        axisBottom = {},\n        axisLeft = {},\n\n        legends = [],\n\n        isInteractive = true,\n        debugMesh = false,\n        //onMouseEnter,\n        //onMouseMove,\n        onMouseLeave,\n        onClick,\n        tooltip = PointTooltip,\n        canvasRef,\n    } = props\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n    const theme = useTheme()\n    const [currentPoint, setCurrentPoint] = useState(null)\n\n    const { lineGenerator, areaGenerator, series, xScale, yScale, points } = useLine({\n        data,\n        xScale: xScaleSpec,\n        xFormat,\n        yScale: yScaleSpec,\n        yFormat,\n        width: innerWidth,\n        height: innerHeight,\n        colors,\n        curve,\n        areaBaselineValue,\n        pointColor,\n        pointBorderColor,\n    })\n\n    const { delaunay, voronoi } = useVoronoiMesh({\n        points,\n        width: innerWidth,\n        height: innerHeight,\n        debug: debugMesh,\n    })\n\n    useEffect(() => {\n        if (canvasRef) {\n            canvasRef.current = canvasEl.current\n        }\n\n        canvasEl.current.width = outerWidth * pixelRatio\n        canvasEl.current.height = outerHeight * pixelRatio\n\n        const ctx = canvasEl.current.getContext('2d')\n\n        ctx.scale(pixelRatio, pixelRatio)\n\n        ctx.fillStyle = theme.background\n        ctx.fillRect(0, 0, outerWidth, outerHeight)\n        ctx.translate(margin.left, margin.top)\n\n        layers.forEach(layer => {\n            if (typeof layer === 'function') {\n                layer({\n                    ctx,\n                    innerWidth,\n                    innerHeight,\n                    series,\n                    points,\n                    xScale,\n                    yScale,\n                    lineWidth,\n                    lineGenerator,\n                    areaGenerator,\n                    currentPoint,\n                    setCurrentPoint,\n                })\n            }\n\n            if (layer === 'grid' && theme.grid.line.strokeWidth > 0) {\n                ctx.lineWidth = theme.grid.line.strokeWidth\n                ctx.strokeStyle = theme.grid.line.stroke\n\n                enableGridX &&\n                    renderGridLinesToCanvas(ctx, {\n                        width: innerWidth,\n                        height: innerHeight,\n                        scale: xScale,\n                        axis: 'x',\n                        values: gridXValues,\n                    })\n\n                enableGridY &&\n                    renderGridLinesToCanvas(ctx, {\n                        width: innerWidth,\n                        height: innerHeight,\n                        scale: yScale,\n                        axis: 'y',\n                        values: gridYValues,\n                    })\n            }\n\n            if (layer === 'axes') {\n                renderAxesToCanvas(ctx, {\n                    xScale,\n                    yScale,\n                    width: innerWidth,\n                    height: innerHeight,\n                    top: axisTop,\n                    right: axisRight,\n                    bottom: axisBottom,\n                    left: axisLeft,\n                    theme,\n                })\n            }\n\n            if (layer === 'areas' && enableArea === true) {\n                ctx.save()\n                ctx.globalAlpha = areaOpacity\n\n                areaGenerator.context(ctx)\n                for (let i = series.length - 1; i >= 0; i--) {\n                    ctx.fillStyle = series[i].color\n                    ctx.beginPath()\n                    areaGenerator(series[i].data.map(d => d.position))\n                    ctx.fill()\n                }\n\n                ctx.restore()\n            }\n\n            if (layer === 'lines') {\n                lineGenerator.context(ctx)\n                series.forEach(serie => {\n                    ctx.strokeStyle = serie.color\n                    ctx.lineWidth = lineWidth\n                    ctx.beginPath()\n                    lineGenerator(serie.data.map(d => d.position))\n                    ctx.stroke()\n                })\n            }\n\n            if (layer === 'points' && enablePoints === true && pointSize > 0) {\n                points.forEach(point => {\n                    ctx.fillStyle = point.color\n                    ctx.beginPath()\n                    ctx.arc(point.x, point.y, pointSize / 2, 0, 2 * Math.PI)\n                    ctx.fill()\n\n                    if (pointBorderWidth > 0) {\n                        ctx.strokeStyle = point.borderColor\n                        ctx.lineWidth = pointBorderWidth\n                        ctx.stroke()\n                    }\n                })\n            }\n\n            if (layer === 'mesh' && debugMesh === true) {\n                renderVoronoiToCanvas(ctx, voronoi)\n                if (currentPoint) {\n                    renderVoronoiCellToCanvas(ctx, voronoi, currentPoint.index)\n                }\n            }\n\n            if (layer === 'legends') {\n                const legendData = series\n                    .map(serie => ({\n                        id: serie.id,\n                        label: serie.id,\n                        color: serie.color,\n                    }))\n                    .reverse()\n\n                legends.forEach(legend => {\n                    renderLegendToCanvas(ctx, {\n                        ...legend,\n                        data: legend.data || legendData,\n                        containerWidth: innerWidth,\n                        containerHeight: innerHeight,\n                        theme,\n                    })\n                })\n            }\n        })\n    }, [\n        canvasEl,\n        outerWidth,\n        outerHeight,\n        layers,\n        theme,\n        lineGenerator,\n        series,\n        xScale,\n        yScale,\n        enableGridX,\n        gridXValues,\n        enableGridY,\n        gridYValues,\n        axisTop,\n        axisRight,\n        axisBottom,\n        axisLeft,\n        legends,\n        points,\n        enablePoints,\n        pointSize,\n        currentPoint,\n    ])\n\n    const getPointFromMouseEvent = useCallback(\n        event => {\n            const [x, y] = getRelativeCursor(canvasEl.current, event)\n            if (!isCursorInRect(margin.left, margin.top, innerWidth, innerHeight, x, y)) return null\n\n            const pointIndex = delaunay.find(x - margin.left, y - margin.top)\n            return points[pointIndex]\n        },\n        [canvasEl, margin, innerWidth, innerHeight, delaunay]\n    )\n\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const handleMouseHover = useCallback(\n        event => {\n            const point = getPointFromMouseEvent(event)\n            setCurrentPoint(point)\n\n            if (point) {\n                showTooltipFromEvent(createElement(tooltip, { point }), event)\n            } else {\n                hideTooltip()\n            }\n        },\n        [getPointFromMouseEvent, setCurrentPoint, showTooltipFromEvent, hideTooltip, tooltip]\n    )\n\n    const handleMouseLeave = useCallback(\n        event => {\n            hideTooltip()\n            setCurrentPoint(null)\n            currentPoint && onMouseLeave && onMouseLeave(currentPoint, event)\n        },\n        [hideTooltip, setCurrentPoint, onMouseLeave]\n    )\n\n    const handleClick = useCallback(\n        event => {\n            if (onClick) {\n                const point = getPointFromMouseEvent(event)\n                point && onClick(point, event)\n            }\n        },\n        [getPointFromMouseEvent, onClick]\n    )\n\n    return (\n        <canvas\n            ref={canvasEl}\n            width={outerWidth * pixelRatio}\n            height={outerHeight * pixelRatio}\n            style={{\n                width: outerWidth,\n                height: outerHeight,\n                cursor: isInteractive ? 'auto' : 'normal',\n            }}\n            onMouseEnter={isInteractive ? handleMouseHover : undefined}\n            onMouseMove={isInteractive ? handleMouseHover : undefined}\n            onMouseLeave={isInteractive ? handleMouseLeave : undefined}\n            onClick={isInteractive ? handleClick : undefined}\n        />\n    )\n}\n\nconst LineCanvasWithContainer = withContainer(LineCanvas)\n\nexport default forwardRef((props, ref) => <LineCanvasWithContainer {...props} canvasRef={ref} />)\n","import { forwardRef } from 'react'\nimport { ResponsiveWrapper } from '@nivo/core'\nimport LineCanvas from './LineCanvas'\n\nconst ResponsiveLineCanvas = (props, ref) => (\n    <ResponsiveWrapper>\n        {({ width, height }) => <LineCanvas width={width} height={height} {...props} ref={ref} />}\n    </ResponsiveWrapper>\n)\n\nexport default forwardRef(ResponsiveLineCanvas)\n","import { ResponsiveWrapper } from '@nivo/core'\nimport Line from './Line'\n\nconst ResponsiveLine = props => (\n    <ResponsiveWrapper>\n        {({ width, height }) => <Line width={width} height={height} {...props} />}\n    </ResponsiveWrapper>\n)\n\nexport default ResponsiveLine\n"],"names":["memo","_ref","point","_jsx","BasicTooltip","id","_jsxs","jsxs","children","jsx","data","xFormatted","yFormatted","enableChip","color","serieColor","slice","axis","theme","useTheme","otherAxis","TableTooltip","rows","points","map","Chip","style","tooltip","chip","serieId","tableCellValue","commonDefaultProps","curve","xScale","type","yScale","min","max","layers","axisBottom","axisLeft","enableGridX","enableGridY","enablePoints","pointSize","pointColor","from","pointBorderWidth","pointBorderColor","enablePointLabel","pointLabel","colors","scheme","enableArea","areaBaselineValue","areaOpacity","areaBlendMode","lineWidth","legends","isInteractive","PointTooltip","enableSlices","debugSlices","sliceTooltip","SliceTooltip","debugMesh","enableCrosshair","crosshairType","LineDefaultProps","_extends","useMesh","enableTouchCrosshair","animate","motionConfig","defs","fill","role","LineCanvasDefaultProps","pixelRatio","window","devicePixelRatio","useLineGenerator","useMemo","line","defined","d","x","y","curveFromProp","useAreaGenerator","_ref2","area","y1","y0","useSlices","_ref4","componentId","width","height","Map","forEach","has","get","push","set","Array","entries","sort","a","b","_ref5","i","slices","x0","sliceWidth","slicePoints","prevSlice","nextSlice","reverse","_ref6","sliceHeight","LINE_UNIQUE_ID_PREFIX","useLine","_ref7","_ref7$xScale","xScaleSpec","xFormat","_ref7$yScale","yScaleSpec","yFormat","_ref7$colors","_ref7$curve","_ref7$areaBaselineVal","_ref7$pointColor","_ref7$pointBorderColo","_ref7$enableSlices","enableSlicesTooltip","useState","uniqueId","formatX","useValueFormatter","formatY","getColor","useOrdinalColorScale","getPointColor","useInheritedColor","getPointBorderColor","_useState2","hiddenIds","setHiddenIds","_useMemo","computeXYScalesForSeries","filter","item","indexOf","rawSeries","series","_useMemo2","dataWithColor","label","datum","find","serie","Boolean","legendData","hidden","toggleSerie","useCallback","state","concat","_ref3","reduce","acc","position","index","length","borderColor","usePoints","lineGenerator","areaGenerator","AreaPath","path","_useMotionConfig","useMotionConfig","springConfig","config","animatedPath","useAnimatedPath","animatedProps","useSpring","immediate","animated","fillOpacity","strokeWidth","mixBlendMode","computedLines","lines","thickness","stroke","LinesItem","debug","isCurrent","setCurrent","onMouseEnter","onMouseMove","onMouseLeave","onClick","onTouchStart","onTouchMove","onTouchEnd","_useTooltip","useTooltip","showTooltipFromEvent","hideTooltip","handleMouseEnter","event","createElement","handleMouseMove","handleMouseLeave","handleClick","handeOnTouchStart","handeOnTouchMove","touchPoint","touches","touchingElement","document","elementFromPoint","clientX","clientY","touchingSliceId","getAttribute","handleOnTouchEnd","strokeOpacity","current","SlicesItem","symbol","size","borderWidth","enableLabel","labelYOffset","getLabel","getLabelGenerator","mappedPoints","DotsItem","margin","showTooltipAt","left","top","handleTouchStart","handleTouchMove","handleTouchEnd","BaseMesh","nodes","withContainer","props","_props$xScale","_props$yScale","_props$layers","_props$curve","_props$areaBaselineVa","_props$colors","partialMargin","axisTop","axisRight","_props$axisBottom","_props$axisLeft","_props$enableGridX","_props$enableGridY","gridXValues","gridYValues","_props$lineWidth","_props$enableArea","_props$areaOpacity","_props$areaBlendMode","_props$enablePoints","pointSymbol","_props$pointSize","_props$pointColor","_props$pointBorderWid","_props$pointBorderCol","_props$enablePointLab","_props$pointLabel","pointLabelYOffset","_props$defs","_props$fill","markers","_props$legends","_props$isInteractive","_props$useMesh","_props$debugMesh","_props$tooltip","_props$enableSlices","_props$debugSlices","_props$sliceTooltip","_props$enableCrosshai","_props$crosshairType","_props$enableTouchCro","_props$role","_useDimensions","useDimensions","innerWidth","innerHeight","outerWidth","outerHeight","_useLine","_useState","currentPoint","setCurrentPoint","currentSlice","setCurrentSlice","layerById","grid","Grid","xValues","yValues","CartesianMarkers","axes","Axes","right","bottom","areas","Lines","crosshair","mesh","legend","BoxLegendSvg","containerWidth","containerHeight","undefined","boundDefs","bindDefs","Areas","Slices","Points","Crosshair","Mesh","SvgWrapper","layer","Fragment","LineCanvasWithContainer","canvasEl","useRef","_props$pixelRatio","canvasRef","_useVoronoiMesh","useVoronoiMesh","delaunay","voronoi","useEffect","ctx","getContext","scale","fillStyle","background","fillRect","translate","strokeStyle","renderGridLinesToCanvas","values","renderAxesToCanvas","save","globalAlpha","context","beginPath","restore","arc","Math","PI","renderVoronoiToCanvas","renderVoronoiCellToCanvas","renderLegendToCanvas","getPointFromMouseEvent","_getRelativeCursor","getRelativeCursor","isCursorInRect","pointIndex","handleMouseHover","ref","cursor","LineCanvas$1","forwardRef","ResponsiveWrapper","LineCanvas","Line"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"nivo-line.cjs.js","sources":["../src/PointTooltip.js","../src/SliceTooltip.js","../src/props.js","../src/hooks.js","../src/Areas.js","../src/LinesItem.js","../src/Lines.js","../src/SlicesItem.js","../src/Slices.js","../src/Points.js","../src/Mesh.js","../src/Line.js","../src/LineCanvas.js","../src/ResponsiveLineCanvas.js","../src/ResponsiveLine.js"],"sourcesContent":["import { memo } from 'react'\nimport { BasicTooltip } from '@nivo/tooltip'\n\nconst LinePointTooltip = ({ point }) => {\n    return (\n        <BasicTooltip\n            id={\n                <span>\n                    x: <strong>{point.data.xFormatted}</strong>, y:{' '}\n                    <strong>{point.data.yFormatted}</strong>\n                </span>\n            }\n            enableChip={true}\n            color={point.serieColor}\n        />\n    )\n}\n\nexport default memo(LinePointTooltip)\n","import { memo } from 'react'\nimport { useTheme } from '@nivo/core'\nimport { Chip, TableTooltip } from '@nivo/tooltip'\n\nconst SliceTooltip = ({ slice, axis }) => {\n    const theme = useTheme()\n    const otherAxis = axis === 'x' ? 'y' : 'x'\n\n    return (\n        <TableTooltip\n            rows={slice.points.map(point => [\n                <Chip key=\"chip\" color={point.serieColor} style={theme.tooltip.chip} />,\n                point.serieId,\n                <span key=\"value\" style={theme.tooltip.tableCellValue}>\n                    {point.data[`${otherAxis}Formatted`]}\n                </span>,\n            ])}\n        />\n    )\n}\n\nexport default memo(SliceTooltip)\n","import PointTooltip from './PointTooltip'\nimport SliceTooltip from './SliceTooltip'\n\nconst commonDefaultProps = {\n    curve: 'linear',\n\n    xScale: {\n        type: 'point',\n    },\n    yScale: {\n        type: 'linear',\n        min: 0,\n        max: 'auto',\n    },\n\n    layers: [\n        'grid',\n        'markers',\n        'axes',\n        'areas',\n        'crosshair',\n        'lines',\n        'points',\n        'slices',\n        'mesh',\n        'legends',\n    ],\n    axisBottom: {},\n    axisLeft: {},\n    enableGridX: true,\n    enableGridY: true,\n\n    enablePoints: true,\n    pointSize: 6,\n    pointColor: { from: 'color' },\n    pointBorderWidth: 0,\n    pointBorderColor: { theme: 'background' },\n    enablePointLabel: false,\n    pointLabel: 'yFormatted',\n\n    colors: { scheme: 'nivo' },\n    enableArea: false,\n    areaBaselineValue: 0,\n    areaOpacity: 0.2,\n    areaBlendMode: 'normal',\n    lineWidth: 2,\n\n    legends: [],\n\n    isInteractive: true,\n    tooltip: PointTooltip,\n    enableSlices: false,\n    debugSlices: false,\n    sliceTooltip: SliceTooltip,\n    debugMesh: false,\n    enableCrosshair: true,\n    crosshairType: 'bottom-left',\n}\n\nexport const LineDefaultProps = {\n    ...commonDefaultProps,\n    enablePointLabel: false,\n    useMesh: false,\n    enableTouchCrosshair: false,\n    animate: true,\n    motionConfig: 'gentle',\n    defs: [],\n    fill: [],\n    role: 'img',\n    initialHiddenIds: [],\n}\n\nexport const LineCanvasDefaultProps = {\n    ...commonDefaultProps,\n    pixelRatio: typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1,\n}\n","import { useCallback, useMemo, useState } from 'react'\nimport { area, line } from 'd3-shape'\nimport { curveFromProp, useTheme, useValueFormatter } from '@nivo/core'\nimport { useOrdinalColorScale, useInheritedColor } from '@nivo/colors'\nimport { computeXYScalesForSeries } from '@nivo/scales'\nimport uniqueId from 'lodash/uniqueId'\nimport { LineDefaultProps } from './props'\n\nexport const useLineGenerator = ({ curve }) => {\n    return useMemo(\n        () =>\n            line()\n                .defined(d => d.x !== null && d.y !== null)\n                .x(d => d.x)\n                .y(d => d.y)\n                .curve(curveFromProp(curve)),\n        [curve]\n    )\n}\n\nexport const useAreaGenerator = ({ curve, yScale, areaBaselineValue }) => {\n    return useMemo(() => {\n        return area()\n            .defined(d => d.x !== null && d.y !== null)\n            .x(d => d.x)\n            .y1(d => d.y)\n            .curve(curveFromProp(curve))\n            .y0(yScale(areaBaselineValue))\n    }, [curve, yScale, areaBaselineValue])\n}\n\nconst usePoints = ({ series, getPointColor, getPointBorderColor, formatX, formatY }) => {\n    return useMemo(() => {\n        return series.reduce((acc, serie) => {\n            return [\n                ...acc,\n                ...serie.data\n                    .filter(datum => datum.position.x !== null && datum.position.y !== null)\n                    .map((datum, i) => {\n                        const point = {\n                            id: `${serie.id}.${i}`,\n                            index: acc.length + i,\n                            serieId: serie.id,\n                            serieColor: serie.color,\n                            x: datum.position.x,\n                            y: datum.position.y,\n                        }\n                        point.color = getPointColor(serie)\n                        point.borderColor = getPointBorderColor(point)\n                        point.data = {\n                            ...datum.data,\n                            xFormatted: formatX(datum.data.x),\n                            yFormatted: formatY(datum.data.y),\n                        }\n\n                        return point\n                    }),\n            ]\n        }, [])\n    }, [series, getPointColor, getPointBorderColor, formatX, formatY])\n}\n\nexport const useSlices = ({ componentId, enableSlices, points, width, height }) => {\n    return useMemo(() => {\n        if (enableSlices === false) return []\n\n        if (enableSlices === 'x') {\n            const map = new Map()\n            points.forEach(point => {\n                if (point.data.x === null || point.data.y === null) return\n                if (!map.has(point.x)) map.set(point.x, [point])\n                else map.get(point.x).push(point)\n            })\n            return Array.from(map.entries())\n                .sort((a, b) => a[0] - b[0])\n                .map(([x, slicePoints], i, slices) => {\n                    const prevSlice = slices[i - 1]\n                    const nextSlice = slices[i + 1]\n\n                    let x0\n                    if (!prevSlice) x0 = x\n                    else x0 = x - (x - prevSlice[0]) / 2\n\n                    let sliceWidth\n                    if (!nextSlice) sliceWidth = width - x0\n                    else sliceWidth = x - x0 + (nextSlice[0] - x) / 2\n\n                    return {\n                        id: `slice:${componentId}:${x}`,\n                        x0,\n                        x,\n                        y0: 0,\n                        y: 0,\n                        width: sliceWidth,\n                        height,\n                        points: slicePoints.reverse(),\n                    }\n                })\n        } else if (enableSlices === 'y') {\n            const map = new Map()\n            points.forEach(point => {\n                if (point.data.x === null || point.data.y === null) return\n                if (!map.has(point.y)) map.set(point.y, [point])\n                else map.get(point.y).push(point)\n            })\n            return Array.from(map.entries())\n                .sort((a, b) => a[0] - b[0])\n                .map(([y, slicePoints], i, slices) => {\n                    const prevSlice = slices[i - 1]\n                    const nextSlice = slices[i + 1]\n\n                    let y0\n                    if (!prevSlice) y0 = y\n                    else y0 = y - (y - prevSlice[0]) / 2\n\n                    let sliceHeight\n                    if (!nextSlice) sliceHeight = height - y0\n                    else sliceHeight = y - y0 + (nextSlice[0] - y) / 2\n\n                    return {\n                        id: y,\n                        x0: 0,\n                        x: 0,\n                        y0,\n                        y,\n                        width,\n                        height: sliceHeight,\n                        points: slicePoints.reverse(),\n                    }\n                })\n        }\n    }, [componentId, enableSlices, height, points, width])\n}\n\nexport const LINE_UNIQUE_ID_PREFIX = 'line'\n\nexport const useLine = ({\n    data,\n    xScale: xScaleSpec = LineDefaultProps.xScale,\n    xFormat,\n    yScale: yScaleSpec = LineDefaultProps.yScale,\n    yFormat,\n    width,\n    height,\n    colors = LineDefaultProps.colors,\n    curve = LineDefaultProps.curve,\n    areaBaselineValue = LineDefaultProps.areaBaselineValue,\n    pointColor = LineDefaultProps.pointColor,\n    pointBorderColor = LineDefaultProps.pointBorderColor,\n    enableSlices = LineDefaultProps.enableSlicesTooltip,\n    initialHiddenIds = LineDefaultProps.initialHiddenIds,\n}) => {\n    const [componentId] = useState(uniqueId(LINE_UNIQUE_ID_PREFIX))\n    const formatX = useValueFormatter(xFormat)\n    const formatY = useValueFormatter(yFormat)\n    const getColor = useOrdinalColorScale(colors, 'id')\n    const theme = useTheme()\n    const getPointColor = useInheritedColor(pointColor, theme)\n    const getPointBorderColor = useInheritedColor(pointBorderColor, theme)\n    const [hiddenIds, setHiddenIds] = useState(initialHiddenIds ?? [])\n\n    const {\n        xScale,\n        yScale,\n        series: rawSeries,\n    } = useMemo(\n        () =>\n            computeXYScalesForSeries(\n                data.filter(item => hiddenIds.indexOf(item.id) === -1),\n                xScaleSpec,\n                yScaleSpec,\n                width,\n                height\n            ),\n        [data, hiddenIds, xScaleSpec, yScaleSpec, width, height]\n    )\n\n    const { legendData, series } = useMemo(() => {\n        const dataWithColor = data.map(line => ({\n            id: line.id,\n            label: line.id,\n            color: getColor(line),\n        }))\n        const series = dataWithColor\n            .map(datum => ({\n                ...rawSeries.find(serie => serie.id === datum.id),\n                color: datum.color,\n            }))\n            .filter(item => Boolean(item.id))\n        const legendData = dataWithColor\n            .map(item => ({ ...item, hidden: !series.find(serie => serie.id === item.id) }))\n            .reverse()\n\n        return { legendData, series }\n    }, [data, rawSeries, getColor])\n\n    const toggleSerie = useCallback(id => {\n        setHiddenIds(state =>\n            state.indexOf(id) > -1 ? state.filter(item => item !== id) : [...state, id]\n        )\n    }, [])\n\n    const points = usePoints({\n        series,\n        getPointColor,\n        getPointBorderColor,\n        formatX,\n        formatY,\n    })\n\n    const slices = useSlices({\n        componentId,\n        enableSlices,\n        points,\n        width,\n        height,\n    })\n\n    const lineGenerator = useLineGenerator({ curve })\n    const areaGenerator = useAreaGenerator({\n        curve,\n        yScale,\n        areaBaselineValue,\n    })\n\n    return {\n        legendData,\n        toggleSerie,\n        lineGenerator,\n        areaGenerator,\n        getColor,\n        series,\n        xScale,\n        yScale,\n        slices,\n        points,\n    }\n}\n","import { memo } from 'react'\nimport { useSpring, animated } from '@react-spring/web'\nimport { useAnimatedPath, useMotionConfig } from '@nivo/core'\n\nconst AreaPath = ({ areaBlendMode, areaOpacity, color, fill, path }) => {\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedPath = useAnimatedPath(path)\n    const animatedProps = useSpring({\n        color,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <animated.path\n            d={animatedPath}\n            fill={fill ? fill : animatedProps.color}\n            fillOpacity={areaOpacity}\n            strokeWidth={0}\n            style={{\n                mixBlendMode: areaBlendMode,\n            }}\n        />\n    )\n}\n\nconst Areas = ({ areaGenerator, areaOpacity, areaBlendMode, lines }) => {\n    const computedLines = lines.slice(0).reverse()\n\n    return (\n        <g>\n            {computedLines.map(line => (\n                <AreaPath\n                    key={line.id}\n                    path={areaGenerator(line.data.map(d => d.position))}\n                    {...{ areaOpacity, areaBlendMode, ...line }}\n                />\n            ))}\n        </g>\n    )\n}\n\nexport default memo(Areas)\n","import { memo, useMemo } from 'react'\nimport { animated } from '@react-spring/web'\nimport { useAnimatedPath } from '@nivo/core'\n\nconst LinesItem = ({ lineGenerator, points, color, thickness }) => {\n    const path = useMemo(() => lineGenerator(points), [lineGenerator, points])\n    const animatedPath = useAnimatedPath(path)\n\n    return <animated.path d={animatedPath} fill=\"none\" strokeWidth={thickness} stroke={color} />\n}\n\nexport default memo(LinesItem)\n","import { memo } from 'react'\nimport LinesItem from './LinesItem'\n\nconst Lines = ({ lines, lineGenerator, lineWidth }) => {\n    return lines\n        .slice(0)\n        .reverse()\n        .map(({ id, data, color }) => (\n            <LinesItem\n                key={id}\n                id={id}\n                points={data.map(d => d.position)}\n                lineGenerator={lineGenerator}\n                color={color}\n                thickness={lineWidth}\n            />\n        ))\n}\n\nexport default memo(Lines)\n","import { createElement, memo, useCallback } from 'react'\nimport { useTooltip } from '@nivo/tooltip'\n\nconst SlicesItem = ({\n    slice,\n    slices,\n    axis,\n    debug,\n    tooltip,\n    isCurrent,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n}) => {\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const handleMouseEnter = useCallback(\n        event => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n            setCurrent(slice)\n            onMouseEnter && onMouseEnter(slice, event)\n        },\n        [showTooltipFromEvent, tooltip, slice, axis, setCurrent, onMouseEnter]\n    )\n\n    const handleMouseMove = useCallback(\n        event => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n            onMouseMove && onMouseMove(slice, event)\n        },\n        [showTooltipFromEvent, tooltip, slice, axis, onMouseMove]\n    )\n\n    const handleMouseLeave = useCallback(\n        event => {\n            hideTooltip()\n            setCurrent(null)\n            onMouseLeave && onMouseLeave(slice, event)\n        },\n        [hideTooltip, setCurrent, onMouseLeave, slice]\n    )\n\n    const handleClick = useCallback(\n        event => {\n            onClick && onClick(slice, event)\n        },\n        [slice, onClick]\n    )\n\n    const handeOnTouchStart = useCallback(\n        event => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n            setCurrent(slice)\n            onTouchStart && onTouchStart(slice, event)\n        },\n        [axis, onTouchStart, setCurrent, showTooltipFromEvent, slice, tooltip]\n    )\n\n    const handeOnTouchMove = useCallback(\n        event => {\n            // This event will be locked to the element that was touched originally\n            // We find the element that is currently being \"hovered over\" by getting the element at the touch point\n            const touchPoint = event.touches[0]\n            const touchingElement = document.elementFromPoint(\n                touchPoint.clientX,\n                touchPoint.clientY\n            )\n            // Is this a nivo ref?\n            const touchingSliceId = touchingElement?.getAttribute('data-ref')\n            if (touchingSliceId) {\n                // Is this a slice for this graph?\n                const slice = slices.find(slice => slice.id === touchingSliceId)\n                if (slice) {\n                    showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n                    setCurrent(slice)\n                }\n            }\n\n            // Note here, this will pass the original slice, not the one we found\n            // But this can be found with document.elementFromPoint()\n            onTouchMove && onTouchMove(slice, event)\n        },\n        [axis, onTouchMove, setCurrent, showTooltipFromEvent, slice, slices, tooltip]\n    )\n\n    const handleOnTouchEnd = useCallback(\n        event => {\n            hideTooltip()\n            setCurrent(null)\n            onTouchEnd && onTouchEnd(slice, event)\n        },\n        [hideTooltip, setCurrent, onTouchEnd, slice]\n    )\n\n    return (\n        <rect\n            x={slice.x0}\n            y={slice.y0}\n            width={slice.width}\n            height={slice.height}\n            stroke=\"red\"\n            strokeWidth={debug ? 1 : 0}\n            strokeOpacity={0.75}\n            fill=\"red\"\n            fillOpacity={isCurrent && debug ? 0.35 : 0}\n            onMouseEnter={handleMouseEnter}\n            onMouseMove={handleMouseMove}\n            onMouseLeave={handleMouseLeave}\n            onClick={handleClick}\n            onTouchStart={handeOnTouchStart}\n            onTouchMove={handeOnTouchMove}\n            onTouchEnd={handleOnTouchEnd}\n            data-ref={slice.id}\n        />\n    )\n}\n\nexport default memo(SlicesItem)\n","import { memo } from 'react'\nimport SlicesItem from './SlicesItem'\n\nconst Slices = ({\n    slices,\n    axis,\n    debug,\n    height,\n    tooltip,\n    current,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n}) => {\n    return slices.map(slice => (\n        <SlicesItem\n            key={slice.id}\n            slice={slice}\n            slices={slices}\n            axis={axis}\n            debug={debug}\n            height={height}\n            tooltip={tooltip}\n            setCurrent={setCurrent}\n            isCurrent={current !== null && current.id === slice.id}\n            onMouseEnter={onMouseEnter}\n            onMouseMove={onMouseMove}\n            onMouseLeave={onMouseLeave}\n            onClick={onClick}\n            onTouchStart={onTouchStart}\n            onTouchMove={onTouchMove}\n            onTouchEnd={onTouchEnd}\n        />\n    ))\n}\n\nexport default memo(Slices)\n","import { memo } from 'react'\nimport { getLabelGenerator, DotsItem, useTheme } from '@nivo/core'\n\nconst Points = ({ points, symbol, size, borderWidth, enableLabel, label, labelYOffset }) => {\n    const theme = useTheme()\n    const getLabel = getLabelGenerator(label)\n\n    /**\n     * We reverse the `points` array so that points from the lower lines in stacked lines\n     * graph are drawn on top. See https://github.com/plouc/nivo/issues/1051.\n     */\n    const mappedPoints = points\n        .slice(0)\n        .reverse()\n        .map(point => {\n            const mappedPoint = {\n                id: point.id,\n                x: point.x,\n                y: point.y,\n                datum: point.data,\n                fill: point.color,\n                stroke: point.borderColor,\n                label: enableLabel ? getLabel(point) : null,\n            }\n\n            return mappedPoint\n        })\n\n    return (\n        <g>\n            {mappedPoints.map(point => (\n                <DotsItem\n                    key={point.id}\n                    x={point.x}\n                    y={point.y}\n                    datum={point.datum}\n                    symbol={symbol}\n                    size={size}\n                    color={point.fill}\n                    borderWidth={borderWidth}\n                    borderColor={point.stroke}\n                    label={point.label}\n                    labelYOffset={labelYOffset}\n                    theme={theme}\n                />\n            ))}\n        </g>\n    )\n}\n\nexport default memo(Points)\n","import { createElement, memo, useCallback } from 'react'\nimport { useTooltip } from '@nivo/tooltip'\nimport { Mesh as BaseMesh } from '@nivo/voronoi'\n\nconst Mesh = ({\n    points,\n    width,\n    height,\n    margin,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n    tooltip,\n    debug,\n    enableTouchCrosshair,\n}) => {\n    const { showTooltipAt, hideTooltip } = useTooltip()\n\n    const handleMouseEnter = useCallback(\n        (point, event) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onMouseEnter && onMouseEnter(point, event)\n        },\n        [showTooltipAt, tooltip, onMouseEnter, margin]\n    )\n\n    const handleMouseMove = useCallback(\n        (point, event) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onMouseMove && onMouseMove(point, event)\n        },\n        [showTooltipAt, tooltip, margin.left, margin.top, onMouseMove]\n    )\n\n    const handleMouseLeave = useCallback(\n        (point, event) => {\n            hideTooltip()\n            onMouseLeave && onMouseLeave(point, event)\n        },\n        [hideTooltip, onMouseLeave]\n    )\n\n    const handleClick = useCallback(\n        (point, event) => {\n            onClick && onClick(point, event)\n        },\n        [onClick]\n    )\n\n    const handleTouchStart = useCallback(\n        (point, event) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onTouchStart && onTouchStart(point, event)\n        },\n        [margin.left, margin.top, onTouchStart, showTooltipAt, tooltip]\n    )\n\n    const handleTouchMove = useCallback(\n        (point, event) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onTouchMove && onTouchMove(point, event)\n        },\n        [margin.left, margin.top, onTouchMove, showTooltipAt, tooltip]\n    )\n\n    const handleTouchEnd = useCallback(\n        (point, event) => {\n            hideTooltip()\n            onTouchEnd && onTouchEnd(point, event)\n        },\n        [onTouchEnd, hideTooltip]\n    )\n\n    return (\n        <BaseMesh\n            nodes={points}\n            width={width}\n            height={height}\n            setCurrent={setCurrent}\n            onMouseEnter={handleMouseEnter}\n            onMouseMove={handleMouseMove}\n            onMouseLeave={handleMouseLeave}\n            onClick={handleClick}\n            onTouchStart={handleTouchStart}\n            onTouchMove={handleTouchMove}\n            onTouchEnd={handleTouchEnd}\n            enableTouchCrosshair={enableTouchCrosshair}\n            debug={debug}\n        />\n    )\n}\n\nexport default memo(Mesh)\n","import { Fragment, useState } from 'react'\nimport {\n    bindDefs,\n    withContainer,\n    useDimensions,\n    useTheme,\n    SvgWrapper,\n    CartesianMarkers,\n} from '@nivo/core'\nimport { useInheritedColor } from '@nivo/colors'\nimport { Axes, Grid } from '@nivo/axes'\nimport { BoxLegendSvg } from '@nivo/legends'\nimport { Crosshair } from '@nivo/tooltip'\nimport { useLine } from './hooks'\nimport Areas from './Areas'\nimport Lines from './Lines'\nimport Slices from './Slices'\nimport Points from './Points'\nimport Mesh from './Mesh'\nimport PointTooltip from './PointTooltip'\nimport SliceTooltip from './SliceTooltip'\n\nconst Line = props => {\n    const {\n        data,\n        xScale: xScaleSpec = { type: 'point' },\n        xFormat,\n        yScale: yScaleSpec = {\n            type: 'linear',\n            min: 0,\n            max: 'auto',\n        },\n        yFormat,\n        layers = [\n            'grid',\n            'markers',\n            'axes',\n            'areas',\n            'crosshair',\n            'lines',\n            'points',\n            'slices',\n            'mesh',\n            'legends',\n        ],\n        curve = 'linear',\n        areaBaselineValue = 0,\n\n        colors = { scheme: 'nivo' },\n\n        margin: partialMargin,\n        width,\n        height,\n\n        axisTop,\n        axisRight,\n        axisBottom = {},\n        axisLeft = {},\n        enableGridX = true,\n        enableGridY = true,\n        gridXValues,\n        gridYValues,\n\n        lineWidth = 2,\n        enableArea = false,\n        areaOpacity = 0.2,\n        areaBlendMode = 'normal',\n\n        enablePoints = true,\n        pointSymbol,\n        pointSize = 6,\n        pointColor = { from: 'color' },\n        pointBorderWidth = 0,\n        pointBorderColor = { theme: 'background' },\n        enablePointLabel = false,\n        pointLabel = 'data.yFormatted',\n        pointLabelYOffset,\n\n        defs = [],\n        fill = [],\n\n        markers,\n\n        legends = [],\n\n        isInteractive = true,\n\n        useMesh = false,\n        debugMesh = false,\n\n        onMouseEnter,\n        onMouseMove,\n        onMouseLeave,\n        onClick,\n        onTouchStart,\n        onTouchMove,\n        onTouchEnd,\n\n        tooltip = PointTooltip,\n\n        enableSlices = false,\n        debugSlices = false,\n        sliceTooltip = SliceTooltip,\n\n        enableCrosshair = true,\n        crosshairType = 'bottom-left',\n        enableTouchCrosshair = false,\n\n        role = 'img',\n        initialHiddenIds = [],\n    } = props\n\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const {\n        legendData,\n        toggleSerie,\n        lineGenerator,\n        areaGenerator,\n        series,\n        xScale,\n        yScale,\n        slices,\n        points,\n    } = useLine({\n        data,\n        xScale: xScaleSpec,\n        xFormat,\n        yScale: yScaleSpec,\n        yFormat,\n        width: innerWidth,\n        height: innerHeight,\n        colors,\n        curve,\n        areaBaselineValue,\n        pointColor,\n        pointBorderColor,\n        enableSlices,\n        initialHiddenIds,\n    })\n\n    const theme = useTheme()\n    const getPointColor = useInheritedColor(pointColor, theme)\n    const getPointBorderColor = useInheritedColor(pointBorderColor, theme)\n\n    const [currentPoint, setCurrentPoint] = useState(null)\n    const [currentSlice, setCurrentSlice] = useState(null)\n\n    const layerById = {\n        grid: (\n            <Grid\n                key=\"grid\"\n                theme={theme}\n                width={innerWidth}\n                height={innerHeight}\n                xScale={enableGridX ? xScale : null}\n                yScale={enableGridY ? yScale : null}\n                xValues={gridXValues}\n                yValues={gridYValues}\n            />\n        ),\n        markers: (\n            <CartesianMarkers\n                key=\"markers\"\n                markers={markers}\n                width={innerWidth}\n                height={innerHeight}\n                xScale={xScale}\n                yScale={yScale}\n                theme={theme}\n            />\n        ),\n        axes: (\n            <Axes\n                key=\"axes\"\n                xScale={xScale}\n                yScale={yScale}\n                width={innerWidth}\n                height={innerHeight}\n                theme={theme}\n                top={axisTop}\n                right={axisRight}\n                bottom={axisBottom}\n                left={axisLeft}\n            />\n        ),\n        areas: null,\n        lines: (\n            <Lines key=\"lines\" lines={series} lineGenerator={lineGenerator} lineWidth={lineWidth} />\n        ),\n        slices: null,\n        points: null,\n        crosshair: null,\n        mesh: null,\n        legends: legends.map((legend, i) => (\n            <BoxLegendSvg\n                key={`legend.${i}`}\n                {...legend}\n                containerWidth={innerWidth}\n                containerHeight={innerHeight}\n                data={legend.data || legendData}\n                theme={theme}\n                toggleSerie={legend.toggleSerie ? toggleSerie : undefined}\n            />\n        )),\n    }\n\n    const boundDefs = bindDefs(defs, series, fill)\n\n    if (enableArea) {\n        layerById.areas = (\n            <Areas\n                key=\"areas\"\n                areaGenerator={areaGenerator}\n                areaOpacity={areaOpacity}\n                areaBlendMode={areaBlendMode}\n                lines={series}\n            />\n        )\n    }\n\n    if (isInteractive && enableSlices !== false) {\n        layerById.slices = (\n            <Slices\n                key=\"slices\"\n                slices={slices}\n                axis={enableSlices}\n                debug={debugSlices}\n                height={innerHeight}\n                tooltip={sliceTooltip}\n                current={currentSlice}\n                setCurrent={setCurrentSlice}\n                onMouseEnter={onMouseEnter}\n                onMouseMove={onMouseMove}\n                onMouseLeave={onMouseLeave}\n                onClick={onClick}\n                onTouchStart={onTouchStart}\n                onTouchMove={onTouchMove}\n                onTouchEnd={onTouchEnd}\n            />\n        )\n    }\n\n    if (enablePoints) {\n        layerById.points = (\n            <Points\n                key=\"points\"\n                points={points}\n                symbol={pointSymbol}\n                size={pointSize}\n                color={getPointColor}\n                borderWidth={pointBorderWidth}\n                borderColor={getPointBorderColor}\n                enableLabel={enablePointLabel}\n                label={pointLabel}\n                labelYOffset={pointLabelYOffset}\n            />\n        )\n    }\n\n    if (isInteractive && enableCrosshair) {\n        if (currentPoint !== null) {\n            layerById.crosshair = (\n                <Crosshair\n                    key=\"crosshair\"\n                    width={innerWidth}\n                    height={innerHeight}\n                    x={currentPoint.x}\n                    y={currentPoint.y}\n                    type={crosshairType}\n                />\n            )\n        }\n        if (currentSlice !== null) {\n            layerById.crosshair = (\n                <Crosshair\n                    key=\"crosshair\"\n                    width={innerWidth}\n                    height={innerHeight}\n                    x={currentSlice.x}\n                    y={currentSlice.y}\n                    type={enableSlices}\n                />\n            )\n        }\n    }\n\n    if (isInteractive && useMesh && enableSlices === false) {\n        layerById.mesh = (\n            <Mesh\n                key=\"mesh\"\n                points={points}\n                width={innerWidth}\n                height={innerHeight}\n                margin={margin}\n                current={currentPoint}\n                setCurrent={setCurrentPoint}\n                onMouseEnter={onMouseEnter}\n                onMouseMove={onMouseMove}\n                onMouseLeave={onMouseLeave}\n                onClick={onClick}\n                onTouchStart={onTouchStart}\n                onTouchMove={onTouchMove}\n                onTouchEnd={onTouchEnd}\n                tooltip={tooltip}\n                enableTouchCrosshair={enableTouchCrosshair}\n                debug={debugMesh}\n            />\n        )\n    }\n\n    return (\n        <SvgWrapper\n            defs={boundDefs}\n            width={outerWidth}\n            height={outerHeight}\n            margin={margin}\n            role={role}\n        >\n            {layers.map((layer, i) => {\n                if (typeof layer === 'function') {\n                    return (\n                        <Fragment key={i}>\n                            {layer({\n                                ...props,\n                                innerWidth,\n                                innerHeight,\n                                series,\n                                slices,\n                                points,\n                                xScale,\n                                yScale,\n                                lineGenerator,\n                                areaGenerator,\n                                currentPoint,\n                                setCurrentPoint,\n                                currentSlice,\n                                setCurrentSlice,\n                            })}\n                        </Fragment>\n                    )\n                }\n\n                return layerById[layer]\n            })}\n        </SvgWrapper>\n    )\n}\n\nexport default withContainer(Line)\n","import { createElement, useRef, useEffect, useState, useCallback, forwardRef } from 'react'\nimport {\n    withContainer,\n    useDimensions,\n    useTheme,\n    getRelativeCursor,\n    isCursorInRect,\n} from '@nivo/core'\nimport { renderAxesToCanvas, renderGridLinesToCanvas } from '@nivo/axes'\nimport { renderLegendToCanvas } from '@nivo/legends'\nimport { useTooltip } from '@nivo/tooltip'\nimport { useVoronoiMesh, renderVoronoiToCanvas, renderVoronoiCellToCanvas } from '@nivo/voronoi'\nimport { useLine } from './hooks'\nimport PointTooltip from './PointTooltip'\n\nconst LineCanvas = props => {\n    const canvasEl = useRef(null)\n    const {\n        width,\n        height,\n        margin: partialMargin,\n        pixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1,\n\n        data,\n        xScale: xScaleSpec = { type: 'point' },\n        xFormat,\n        yScale: yScaleSpec = {\n            type: 'linear',\n            min: 0,\n            max: 'auto',\n        },\n        yFormat,\n        curve = 'linear',\n\n        layers = [\n            'grid',\n            'markers',\n            'axes',\n            'areas',\n            'crosshair',\n            'lines',\n            'points',\n            'slices',\n            'mesh',\n            'legends',\n        ],\n\n        colors = { scheme: 'nivo' },\n        lineWidth = 2,\n\n        enableArea = false,\n        areaBaselineValue = 0,\n        areaOpacity = 0.2,\n\n        enablePoints = true,\n        pointSize = 6,\n        pointColor = { from: 'color' },\n        pointBorderWidth = 0,\n        pointBorderColor = { theme: 'background' },\n\n        enableGridX = true,\n        gridXValues,\n        enableGridY = true,\n        gridYValues,\n        axisTop,\n        axisRight,\n        axisBottom = {},\n        axisLeft = {},\n\n        legends = [],\n\n        isInteractive = true,\n        debugMesh = false,\n        //onMouseEnter,\n        //onMouseMove,\n        onMouseLeave,\n        onClick,\n        tooltip = PointTooltip,\n        canvasRef,\n    } = props\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n    const theme = useTheme()\n    const [currentPoint, setCurrentPoint] = useState(null)\n\n    const { lineGenerator, areaGenerator, series, xScale, yScale, points } = useLine({\n        data,\n        xScale: xScaleSpec,\n        xFormat,\n        yScale: yScaleSpec,\n        yFormat,\n        width: innerWidth,\n        height: innerHeight,\n        colors,\n        curve,\n        areaBaselineValue,\n        pointColor,\n        pointBorderColor,\n    })\n\n    const { delaunay, voronoi } = useVoronoiMesh({\n        points,\n        width: innerWidth,\n        height: innerHeight,\n        debug: debugMesh,\n    })\n\n    useEffect(() => {\n        if (canvasRef) {\n            canvasRef.current = canvasEl.current\n        }\n\n        canvasEl.current.width = outerWidth * pixelRatio\n        canvasEl.current.height = outerHeight * pixelRatio\n\n        const ctx = canvasEl.current.getContext('2d')\n\n        ctx.scale(pixelRatio, pixelRatio)\n\n        ctx.fillStyle = theme.background\n        ctx.fillRect(0, 0, outerWidth, outerHeight)\n        ctx.translate(margin.left, margin.top)\n\n        layers.forEach(layer => {\n            if (typeof layer === 'function') {\n                layer({\n                    ctx,\n                    innerWidth,\n                    innerHeight,\n                    series,\n                    points,\n                    xScale,\n                    yScale,\n                    lineWidth,\n                    lineGenerator,\n                    areaGenerator,\n                    currentPoint,\n                    setCurrentPoint,\n                })\n            }\n\n            if (layer === 'grid' && theme.grid.line.strokeWidth > 0) {\n                ctx.lineWidth = theme.grid.line.strokeWidth\n                ctx.strokeStyle = theme.grid.line.stroke\n\n                enableGridX &&\n                    renderGridLinesToCanvas(ctx, {\n                        width: innerWidth,\n                        height: innerHeight,\n                        scale: xScale,\n                        axis: 'x',\n                        values: gridXValues,\n                    })\n\n                enableGridY &&\n                    renderGridLinesToCanvas(ctx, {\n                        width: innerWidth,\n                        height: innerHeight,\n                        scale: yScale,\n                        axis: 'y',\n                        values: gridYValues,\n                    })\n            }\n\n            if (layer === 'axes') {\n                renderAxesToCanvas(ctx, {\n                    xScale,\n                    yScale,\n                    width: innerWidth,\n                    height: innerHeight,\n                    top: axisTop,\n                    right: axisRight,\n                    bottom: axisBottom,\n                    left: axisLeft,\n                    theme,\n                })\n            }\n\n            if (layer === 'areas' && enableArea === true) {\n                ctx.save()\n                ctx.globalAlpha = areaOpacity\n\n                areaGenerator.context(ctx)\n                for (let i = series.length - 1; i >= 0; i--) {\n                    ctx.fillStyle = series[i].color\n                    ctx.beginPath()\n                    areaGenerator(series[i].data.map(d => d.position))\n                    ctx.fill()\n                }\n\n                ctx.restore()\n            }\n\n            if (layer === 'lines') {\n                lineGenerator.context(ctx)\n                series.forEach(serie => {\n                    ctx.strokeStyle = serie.color\n                    ctx.lineWidth = lineWidth\n                    ctx.beginPath()\n                    lineGenerator(serie.data.map(d => d.position))\n                    ctx.stroke()\n                })\n            }\n\n            if (layer === 'points' && enablePoints === true && pointSize > 0) {\n                points.forEach(point => {\n                    ctx.fillStyle = point.color\n                    ctx.beginPath()\n                    ctx.arc(point.x, point.y, pointSize / 2, 0, 2 * Math.PI)\n                    ctx.fill()\n\n                    if (pointBorderWidth > 0) {\n                        ctx.strokeStyle = point.borderColor\n                        ctx.lineWidth = pointBorderWidth\n                        ctx.stroke()\n                    }\n                })\n            }\n\n            if (layer === 'mesh' && debugMesh === true) {\n                renderVoronoiToCanvas(ctx, voronoi)\n                if (currentPoint) {\n                    renderVoronoiCellToCanvas(ctx, voronoi, currentPoint.index)\n                }\n            }\n\n            if (layer === 'legends') {\n                const legendData = series\n                    .map(serie => ({\n                        id: serie.id,\n                        label: serie.id,\n                        color: serie.color,\n                    }))\n                    .reverse()\n\n                legends.forEach(legend => {\n                    renderLegendToCanvas(ctx, {\n                        ...legend,\n                        data: legend.data || legendData,\n                        containerWidth: innerWidth,\n                        containerHeight: innerHeight,\n                        theme,\n                    })\n                })\n            }\n        })\n    }, [\n        canvasEl,\n        outerWidth,\n        outerHeight,\n        layers,\n        theme,\n        lineGenerator,\n        series,\n        xScale,\n        yScale,\n        enableGridX,\n        gridXValues,\n        enableGridY,\n        gridYValues,\n        axisTop,\n        axisRight,\n        axisBottom,\n        axisLeft,\n        legends,\n        points,\n        enablePoints,\n        pointSize,\n        currentPoint,\n    ])\n\n    const getPointFromMouseEvent = useCallback(\n        event => {\n            const [x, y] = getRelativeCursor(canvasEl.current, event)\n            if (!isCursorInRect(margin.left, margin.top, innerWidth, innerHeight, x, y)) return null\n\n            const pointIndex = delaunay.find(x - margin.left, y - margin.top)\n            return points[pointIndex]\n        },\n        [canvasEl, margin, innerWidth, innerHeight, delaunay]\n    )\n\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const handleMouseHover = useCallback(\n        event => {\n            const point = getPointFromMouseEvent(event)\n            setCurrentPoint(point)\n\n            if (point) {\n                showTooltipFromEvent(createElement(tooltip, { point }), event)\n            } else {\n                hideTooltip()\n            }\n        },\n        [getPointFromMouseEvent, setCurrentPoint, showTooltipFromEvent, hideTooltip, tooltip]\n    )\n\n    const handleMouseLeave = useCallback(\n        event => {\n            hideTooltip()\n            setCurrentPoint(null)\n            currentPoint && onMouseLeave && onMouseLeave(currentPoint, event)\n        },\n        [hideTooltip, setCurrentPoint, onMouseLeave]\n    )\n\n    const handleClick = useCallback(\n        event => {\n            if (onClick) {\n                const point = getPointFromMouseEvent(event)\n                point && onClick(point, event)\n            }\n        },\n        [getPointFromMouseEvent, onClick]\n    )\n\n    return (\n        <canvas\n            ref={canvasEl}\n            width={outerWidth * pixelRatio}\n            height={outerHeight * pixelRatio}\n            style={{\n                width: outerWidth,\n                height: outerHeight,\n                cursor: isInteractive ? 'auto' : 'normal',\n            }}\n            onMouseEnter={isInteractive ? handleMouseHover : undefined}\n            onMouseMove={isInteractive ? handleMouseHover : undefined}\n            onMouseLeave={isInteractive ? handleMouseLeave : undefined}\n            onClick={isInteractive ? handleClick : undefined}\n        />\n    )\n}\n\nconst LineCanvasWithContainer = withContainer(LineCanvas)\n\nexport default forwardRef((props, ref) => <LineCanvasWithContainer {...props} canvasRef={ref} />)\n","import { forwardRef } from 'react'\nimport { ResponsiveWrapper } from '@nivo/core'\nimport LineCanvas from './LineCanvas'\n\nconst ResponsiveLineCanvas = (props, ref) => (\n    <ResponsiveWrapper>\n        {({ width, height }) => <LineCanvas width={width} height={height} {...props} ref={ref} />}\n    </ResponsiveWrapper>\n)\n\nexport default forwardRef(ResponsiveLineCanvas)\n","import { ResponsiveWrapper } from '@nivo/core'\nimport Line from './Line'\n\nconst ResponsiveLine = props => (\n    <ResponsiveWrapper>\n        {({ width, height }) => <Line width={width} height={height} {...props} />}\n    </ResponsiveWrapper>\n)\n\nexport default ResponsiveLine\n"],"names":["memo","_ref","point","_jsx","BasicTooltip","id","_jsxs","jsxs","children","jsx","data","xFormatted","yFormatted","enableChip","color","serieColor","slice","axis","theme","useTheme","otherAxis","TableTooltip","rows","points","map","Chip","style","tooltip","chip","serieId","tableCellValue","commonDefaultProps","curve","xScale","type","yScale","min","max","layers","axisBottom","axisLeft","enableGridX","enableGridY","enablePoints","pointSize","pointColor","from","pointBorderWidth","pointBorderColor","enablePointLabel","pointLabel","colors","scheme","enableArea","areaBaselineValue","areaOpacity","areaBlendMode","lineWidth","legends","isInteractive","PointTooltip","enableSlices","debugSlices","sliceTooltip","SliceTooltip","debugMesh","enableCrosshair","crosshairType","LineDefaultProps","_extends","useMesh","enableTouchCrosshair","animate","motionConfig","defs","fill","role","initialHiddenIds","LineCanvasDefaultProps","pixelRatio","window","devicePixelRatio","useLineGenerator","useMemo","line","defined","d","x","y","curveFromProp","useAreaGenerator","_ref2","area","y1","y0","useSlices","_ref4","componentId","width","height","Map","forEach","has","get","push","set","Array","entries","sort","a","b","_ref5","i","slices","x0","sliceWidth","slicePoints","prevSlice","nextSlice","reverse","_ref6","sliceHeight","LINE_UNIQUE_ID_PREFIX","useLine","_ref7","_ref7$xScale","xScaleSpec","xFormat","_ref7$yScale","yScaleSpec","yFormat","_ref7$colors","_ref7$curve","_ref7$areaBaselineVal","_ref7$pointColor","_ref7$pointBorderColo","_ref7$enableSlices","enableSlicesTooltip","_ref7$initialHiddenId","useState","uniqueId","formatX","useValueFormatter","formatY","getColor","useOrdinalColorScale","getPointColor","useInheritedColor","getPointBorderColor","_useState2","hiddenIds","setHiddenIds","_useMemo","computeXYScalesForSeries","filter","item","indexOf","rawSeries","series","_useMemo2","dataWithColor","label","datum","find","serie","Boolean","legendData","hidden","toggleSerie","useCallback","state","concat","_ref3","reduce","acc","position","index","length","borderColor","usePoints","lineGenerator","areaGenerator","AreaPath","path","_useMotionConfig","useMotionConfig","springConfig","config","animatedPath","useAnimatedPath","animatedProps","useSpring","immediate","animated","fillOpacity","strokeWidth","mixBlendMode","computedLines","lines","thickness","stroke","LinesItem","debug","isCurrent","setCurrent","onMouseEnter","onMouseMove","onMouseLeave","onClick","onTouchStart","onTouchMove","onTouchEnd","_useTooltip","useTooltip","showTooltipFromEvent","hideTooltip","handleMouseEnter","event","createElement","handleMouseMove","handleMouseLeave","handleClick","handeOnTouchStart","handeOnTouchMove","touchPoint","touches","touchingElement","document","elementFromPoint","clientX","clientY","touchingSliceId","getAttribute","handleOnTouchEnd","strokeOpacity","current","SlicesItem","symbol","size","borderWidth","enableLabel","labelYOffset","getLabel","getLabelGenerator","mappedPoints","DotsItem","margin","showTooltipAt","left","top","handleTouchStart","handleTouchMove","handleTouchEnd","BaseMesh","nodes","withContainer","props","_props$xScale","_props$yScale","_props$layers","_props$curve","_props$areaBaselineVa","_props$colors","partialMargin","axisTop","axisRight","_props$axisBottom","_props$axisLeft","_props$enableGridX","_props$enableGridY","gridXValues","gridYValues","_props$lineWidth","_props$enableArea","_props$areaOpacity","_props$areaBlendMode","_props$enablePoints","pointSymbol","_props$pointSize","_props$pointColor","_props$pointBorderWid","_props$pointBorderCol","_props$enablePointLab","_props$pointLabel","pointLabelYOffset","_props$defs","_props$fill","markers","_props$legends","_props$isInteractive","_props$useMesh","_props$debugMesh","_props$tooltip","_props$enableSlices","_props$debugSlices","_props$sliceTooltip","_props$enableCrosshai","_props$crosshairType","_props$enableTouchCro","_props$role","_props$initialHiddenI","_useDimensions","useDimensions","innerWidth","innerHeight","outerWidth","outerHeight","_useLine","_useState","currentPoint","setCurrentPoint","currentSlice","setCurrentSlice","layerById","grid","Grid","xValues","yValues","CartesianMarkers","axes","Axes","right","bottom","areas","Lines","crosshair","mesh","legend","BoxLegendSvg","containerWidth","containerHeight","undefined","boundDefs","bindDefs","Areas","Slices","Points","Crosshair","Mesh","SvgWrapper","layer","Fragment","LineCanvasWithContainer","canvasEl","useRef","_props$pixelRatio","canvasRef","_useVoronoiMesh","useVoronoiMesh","delaunay","voronoi","useEffect","ctx","getContext","scale","fillStyle","background","fillRect","translate","strokeStyle","renderGridLinesToCanvas","values","renderAxesToCanvas","save","globalAlpha","context","beginPath","restore","arc","Math","PI","renderVoronoiToCanvas","renderVoronoiCellToCanvas","renderLegendToCanvas","getPointFromMouseEvent","_getRelativeCursor","getRelativeCursor","isCursorInRect","pointIndex","handleMouseHover","ref","cursor","LineCanvas$1","forwardRef","ResponsiveWrapper","LineCanvas","Line"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/nivo-line.es.js b/dist/nivo-line.es.js
index 15dbdc9044da515512749d0f31b660a0f17c0796..b973f60946c5427c9d48b6e2a3a6220d58aa41fa 100644
--- a/dist/nivo-line.es.js
+++ b/dist/nivo-line.es.js
@@ -1,2 +1,2 @@
-import{memo as e,useMemo as o,useState as i,useCallback as t,createElement as n,Fragment as r,forwardRef as a,useRef as l,useEffect as s}from"react";import{useTheme as c,curveFromProp as u,useValueFormatter as d,useMotionConfig as h,useAnimatedPath as f,getLabelGenerator as v,DotsItem as p,withContainer as m,useDimensions as g,CartesianMarkers as y,bindDefs as x,SvgWrapper as b,ResponsiveWrapper as S,getRelativeCursor as M,isCursorInRect as C}from"@nivo/core";import{useOrdinalColorScale as w,useInheritedColor as T}from"@nivo/colors";import{Grid as k,Axes as B,renderGridLinesToCanvas as W,renderAxesToCanvas as E}from"@nivo/axes";import{BoxLegendSvg as L,renderLegendToCanvas as G}from"@nivo/legends";import{BasicTooltip as P,TableTooltip as F,Chip as O,useTooltip as V,Crosshair as Y}from"@nivo/tooltip";import{line as R,area as I}from"d3-shape";import{computeXYScalesForSeries as A}from"@nivo/scales";import H from"lodash/uniqueId";import{jsx as X,jsxs as z}from"react/jsx-runtime";import{useSpring as j,animated as D}from"@react-spring/web";import{Mesh as q,useVoronoiMesh as J,renderVoronoiToCanvas as K,renderVoronoiCellToCanvas as N}from"@nivo/voronoi";function Q(){return Q=Object.assign?Object.assign.bind():function(e){for(var o=1;o<arguments.length;o++){var i=arguments[o];for(var t in i)Object.prototype.hasOwnProperty.call(i,t)&&(e[t]=i[t])}return e},Q.apply(this,arguments)}var U=e((function(e){var o=e.point;return X(P,{id:z("span",{children:["x: ",X("strong",{children:o.data.xFormatted}),", y:"," ",X("strong",{children:o.data.yFormatted})]}),enableChip:!0,color:o.serieColor})})),Z=e((function(e){var o=e.slice,i=e.axis,t=c(),n="x"===i?"y":"x";return X(F,{rows:o.points.map((function(e){return[X(O,{color:e.serieColor,style:t.tooltip.chip},"chip"),e.serieId,X("span",{style:t.tooltip.tableCellValue,children:e.data[n+"Formatted"]},"value")]}))})})),$={curve:"linear",xScale:{type:"point"},yScale:{type:"linear",min:0,max:"auto"},layers:["grid","markers","axes","areas","crosshair","lines","points","slices","mesh","legends"],axisBottom:{},axisLeft:{},enableGridX:!0,enableGridY:!0,enablePoints:!0,pointSize:6,pointColor:{from:"color"},pointBorderWidth:0,pointBorderColor:{theme:"background"},enablePointLabel:!1,pointLabel:"yFormatted",colors:{scheme:"nivo"},enableArea:!1,areaBaselineValue:0,areaOpacity:.2,areaBlendMode:"normal",lineWidth:2,legends:[],isInteractive:!0,tooltip:U,enableSlices:!1,debugSlices:!1,sliceTooltip:Z,debugMesh:!1,enableCrosshair:!0,crosshairType:"bottom-left"},_=Q({},$,{enablePointLabel:!1,useMesh:!1,enableTouchCrosshair:!1,animate:!0,motionConfig:"gentle",defs:[],fill:[],role:"img"}),ee=Q({},$,{pixelRatio:"undefined"!=typeof window&&window.devicePixelRatio||1}),oe=function(e){var i=e.curve;return o((function(){return R().defined((function(e){return null!==e.x&&null!==e.y})).x((function(e){return e.x})).y((function(e){return e.y})).curve(u(i))}),[i])},ie=function(e){var i=e.curve,t=e.yScale,n=e.areaBaselineValue;return o((function(){return I().defined((function(e){return null!==e.x&&null!==e.y})).x((function(e){return e.x})).y1((function(e){return e.y})).curve(u(i)).y0(t(n))}),[i,t,n])},te=function(e){var i=e.componentId,t=e.enableSlices,n=e.points,r=e.width,a=e.height;return o((function(){if(!1===t)return[];if("x"===t){var e=new Map;return n.forEach((function(o){null!==o.data.x&&null!==o.data.y&&(e.has(o.x)?e.get(o.x).push(o):e.set(o.x,[o]))})),Array.from(e.entries()).sort((function(e,o){return e[0]-o[0]})).map((function(e,o,t){var n,l,s=e[0],c=e[1],u=t[o-1],d=t[o+1];return n=u?s-(s-u[0])/2:s,l=d?s-n+(d[0]-s)/2:r-n,{id:"slice:"+i+":"+s,x0:n,x:s,y0:0,y:0,width:l,height:a,points:c.reverse()}}))}if("y"===t){var o=new Map;return n.forEach((function(e){null!==e.data.x&&null!==e.data.y&&(o.has(e.y)?o.get(e.y).push(e):o.set(e.y,[e]))})),Array.from(o.entries()).sort((function(e,o){return e[0]-o[0]})).map((function(e,o,i){var t,n,l=e[0],s=e[1],c=i[o-1],u=i[o+1];return t=c?l-(l-c[0])/2:l,n=u?l-t+(u[0]-l)/2:a-t,{id:l,x0:0,x:0,y0:t,y:l,width:r,height:n,points:s.reverse()}}))}}),[i,t,a,n,r])},ne="line",re=function(e){var n=e.data,r=e.xScale,a=void 0===r?_.xScale:r,l=e.xFormat,s=e.yScale,u=void 0===s?_.yScale:s,h=e.yFormat,f=e.width,v=e.height,p=e.colors,m=void 0===p?_.colors:p,g=e.curve,y=void 0===g?_.curve:g,x=e.areaBaselineValue,b=void 0===x?_.areaBaselineValue:x,S=e.pointColor,M=void 0===S?_.pointColor:S,C=e.pointBorderColor,k=void 0===C?_.pointBorderColor:C,B=e.enableSlices,W=void 0===B?_.enableSlicesTooltip:B,E=i(H(ne))[0],L=d(l),G=d(h),P=w(m,"id"),F=c(),O=T(M,F),V=T(k,F),Y=i([]),R=Y[0],I=Y[1],X=o((function(){return A(n.filter((function(e){return-1===R.indexOf(e.id)})),a,u,f,v)}),[n,R,a,u,f,v]),z=X.xScale,j=X.yScale,D=X.series,q=o((function(){var e=n.map((function(e){return{id:e.id,label:e.id,color:P(e)}})),o=e.map((function(e){return Q({},D.find((function(o){return o.id===e.id})),{color:e.color})})).filter((function(e){return Boolean(e.id)}));return{legendData:e.map((function(e){return Q({},e,{hidden:!o.find((function(o){return o.id===e.id}))})})).reverse(),series:o}}),[n,D,P]),J=q.legendData,K=q.series,N=t((function(e){I((function(o){return o.indexOf(e)>-1?o.filter((function(o){return o!==e})):[].concat(o,[e])}))}),[]),U=function(e){var i=e.series,t=e.getPointColor,n=e.getPointBorderColor,r=e.formatX,a=e.formatY;return o((function(){return i.reduce((function(e,o){return[].concat(e,o.data.filter((function(e){return null!==e.position.x&&null!==e.position.y})).map((function(i,l){var s={id:o.id+"."+l,index:e.length+l,serieId:o.id,serieColor:o.color,x:i.position.x,y:i.position.y};return s.color=t(o),s.borderColor=n(s),s.data=Q({},i.data,{xFormatted:r(i.data.x),yFormatted:a(i.data.y)}),s})))}),[])}),[i,t,n,r,a])}({series:K,getPointColor:O,getPointBorderColor:V,formatX:L,formatY:G}),Z=te({componentId:E,enableSlices:W,points:U,width:f,height:v});return{legendData:J,toggleSerie:N,lineGenerator:oe({curve:y}),areaGenerator:ie({curve:y,yScale:j,areaBaselineValue:b}),getColor:P,series:K,xScale:z,yScale:j,slices:Z,points:U}},ae=function(e){var o=e.areaBlendMode,i=e.areaOpacity,t=e.color,n=e.fill,r=e.path,a=h(),l=a.animate,s=a.config,c=f(r),u=j({color:t,config:s,immediate:!l});return X(D.path,{d:c,fill:n||u.color,fillOpacity:i,strokeWidth:0,style:{mixBlendMode:o}})},le=e((function(e){var o=e.areaGenerator,i=e.areaOpacity,t=e.areaBlendMode,n=e.lines.slice(0).reverse();return X("g",{children:n.map((function(e){return X(ae,Q({path:o(e.data.map((function(e){return e.position})))},Q({areaOpacity:i,areaBlendMode:t},e)),e.id)}))})})),se=e((function(e){var i=e.lineGenerator,t=e.points,n=e.color,r=e.thickness,a=o((function(){return i(t)}),[i,t]),l=f(a);return X(D.path,{d:l,fill:"none",strokeWidth:r,stroke:n})})),ce=e((function(e){var o=e.lines,i=e.lineGenerator,t=e.lineWidth;return o.slice(0).reverse().map((function(e){var o=e.id,n=e.data,r=e.color;return X(se,{id:o,points:n.map((function(e){return e.position})),lineGenerator:i,color:r,thickness:t},o)}))})),ue=e((function(e){var o=e.slice,i=e.slices,r=e.axis,a=e.debug,l=e.tooltip,s=e.isCurrent,c=e.setCurrent,u=e.onMouseEnter,d=e.onMouseMove,h=e.onMouseLeave,f=e.onClick,v=e.onTouchStart,p=e.onTouchMove,m=e.onTouchEnd,g=V(),y=g.showTooltipFromEvent,x=g.hideTooltip,b=t((function(e){y(n(l,{slice:o,axis:r}),e,"right"),c(o),u&&u(o,e)}),[y,l,o,r,c,u]),S=t((function(e){y(n(l,{slice:o,axis:r}),e,"right"),d&&d(o,e)}),[y,l,o,r,d]),M=t((function(e){x(),c(null),h&&h(o,e)}),[x,c,h,o]),C=t((function(e){f&&f(o,e)}),[o,f]),w=t((function(e){y(n(l,{slice:o,axis:r}),e,"right"),c(o),v&&v(o,e)}),[r,v,c,y,o,l]),T=t((function(e){var t=e.touches[0],a=document.elementFromPoint(t.clientX,t.clientY),s=null==a?void 0:a.getAttribute("data-ref");if(s){var u=i.find((function(e){return e.id===s}));u&&(y(n(l,{slice:u,axis:r}),e,"right"),c(u))}p&&p(o,e)}),[r,p,c,y,o,i,l]),k=t((function(e){x(),c(null),m&&m(o,e)}),[x,c,m,o]);return X("rect",{x:o.x0,y:o.y0,width:o.width,height:o.height,stroke:"red",strokeWidth:a?1:0,strokeOpacity:.75,fill:"red",fillOpacity:s&&a?.35:0,onMouseEnter:b,onMouseMove:S,onMouseLeave:M,onClick:C,onTouchStart:w,onTouchMove:T,onTouchEnd:k,"data-ref":o.id})})),de=e((function(e){var o=e.slices,i=e.axis,t=e.debug,n=e.height,r=e.tooltip,a=e.current,l=e.setCurrent,s=e.onMouseEnter,c=e.onMouseMove,u=e.onMouseLeave,d=e.onClick,h=e.onTouchStart,f=e.onTouchMove,v=e.onTouchEnd;return o.map((function(e){return X(ue,{slice:e,slices:o,axis:i,debug:t,height:n,tooltip:r,setCurrent:l,isCurrent:null!==a&&a.id===e.id,onMouseEnter:s,onMouseMove:c,onMouseLeave:u,onClick:d,onTouchStart:h,onTouchMove:f,onTouchEnd:v},e.id)}))})),he=e((function(e){var o=e.points,i=e.symbol,t=e.size,n=e.borderWidth,r=e.enableLabel,a=e.label,l=e.labelYOffset,s=c(),u=v(a),d=o.slice(0).reverse().map((function(e){return{id:e.id,x:e.x,y:e.y,datum:e.data,fill:e.color,stroke:e.borderColor,label:r?u(e):null}}));return X("g",{children:d.map((function(e){return X(p,{x:e.x,y:e.y,datum:e.datum,symbol:i,size:t,color:e.fill,borderWidth:n,borderColor:e.stroke,label:e.label,labelYOffset:l,theme:s},e.id)}))})})),fe=e((function(e){var o=e.points,i=e.width,r=e.height,a=e.margin,l=e.setCurrent,s=e.onMouseEnter,c=e.onMouseMove,u=e.onMouseLeave,d=e.onClick,h=e.onTouchStart,f=e.onTouchMove,v=e.onTouchEnd,p=e.tooltip,m=e.debug,g=e.enableTouchCrosshair,y=V(),x=y.showTooltipAt,b=y.hideTooltip,S=t((function(e,o){x(n(p,{point:e}),[e.x+a.left,e.y+a.top],"top"),s&&s(e,o)}),[x,p,s,a]),M=t((function(e,o){x(n(p,{point:e}),[e.x+a.left,e.y+a.top],"top"),c&&c(e,o)}),[x,p,a.left,a.top,c]),C=t((function(e,o){b(),u&&u(e,o)}),[b,u]),w=t((function(e,o){d&&d(e,o)}),[d]),T=t((function(e,o){x(n(p,{point:e}),[e.x+a.left,e.y+a.top],"top"),h&&h(e,o)}),[a.left,a.top,h,x,p]),k=t((function(e,o){x(n(p,{point:e}),[e.x+a.left,e.y+a.top],"top"),f&&f(e,o)}),[a.left,a.top,f,x,p]),B=t((function(e,o){b(),v&&v(e,o)}),[v,b]);return X(q,{nodes:o,width:i,height:r,setCurrent:l,onMouseEnter:S,onMouseMove:M,onMouseLeave:C,onClick:w,onTouchStart:T,onTouchMove:k,onTouchEnd:B,enableTouchCrosshair:g,debug:m})})),ve=m((function(e){var o=e.data,t=e.xScale,n=void 0===t?{type:"point"}:t,a=e.xFormat,l=e.yScale,s=void 0===l?{type:"linear",min:0,max:"auto"}:l,u=e.yFormat,d=e.layers,h=void 0===d?["grid","markers","axes","areas","crosshair","lines","points","slices","mesh","legends"]:d,f=e.curve,v=void 0===f?"linear":f,p=e.areaBaselineValue,m=void 0===p?0:p,S=e.colors,M=void 0===S?{scheme:"nivo"}:S,C=e.margin,w=e.width,W=e.height,E=e.axisTop,G=e.axisRight,P=e.axisBottom,F=void 0===P?{}:P,O=e.axisLeft,V=void 0===O?{}:O,R=e.enableGridX,I=void 0===R||R,A=e.enableGridY,H=void 0===A||A,z=e.gridXValues,j=e.gridYValues,D=e.lineWidth,q=void 0===D?2:D,J=e.enableArea,K=void 0!==J&&J,N=e.areaOpacity,$=void 0===N?.2:N,_=e.areaBlendMode,ee=void 0===_?"normal":_,oe=e.enablePoints,ie=void 0===oe||oe,te=e.pointSymbol,ne=e.pointSize,ae=void 0===ne?6:ne,se=e.pointColor,ue=void 0===se?{from:"color"}:se,ve=e.pointBorderWidth,pe=void 0===ve?0:ve,me=e.pointBorderColor,ge=void 0===me?{theme:"background"}:me,ye=e.enablePointLabel,xe=void 0!==ye&&ye,be=e.pointLabel,Se=void 0===be?"data.yFormatted":be,Me=e.pointLabelYOffset,Ce=e.defs,we=void 0===Ce?[]:Ce,Te=e.fill,ke=void 0===Te?[]:Te,Be=e.markers,We=e.legends,Ee=void 0===We?[]:We,Le=e.isInteractive,Ge=void 0===Le||Le,Pe=e.useMesh,Fe=void 0!==Pe&&Pe,Oe=e.debugMesh,Ve=void 0!==Oe&&Oe,Ye=e.onMouseEnter,Re=e.onMouseMove,Ie=e.onMouseLeave,Ae=e.onClick,He=e.onTouchStart,Xe=e.onTouchMove,ze=e.onTouchEnd,je=e.tooltip,De=void 0===je?U:je,qe=e.enableSlices,Je=void 0!==qe&&qe,Ke=e.debugSlices,Ne=void 0!==Ke&&Ke,Qe=e.sliceTooltip,Ue=void 0===Qe?Z:Qe,Ze=e.enableCrosshair,$e=void 0===Ze||Ze,_e=e.crosshairType,eo=void 0===_e?"bottom-left":_e,oo=e.enableTouchCrosshair,io=void 0!==oo&&oo,to=e.role,no=void 0===to?"img":to,ro=g(w,W,C),ao=ro.margin,lo=ro.innerWidth,so=ro.innerHeight,co=ro.outerWidth,uo=ro.outerHeight,ho=re({data:o,xScale:n,xFormat:a,yScale:s,yFormat:u,width:lo,height:so,colors:M,curve:v,areaBaselineValue:m,pointColor:ue,pointBorderColor:ge,enableSlices:Je}),fo=ho.legendData,vo=ho.toggleSerie,po=ho.lineGenerator,mo=ho.areaGenerator,go=ho.series,yo=ho.xScale,xo=ho.yScale,bo=ho.slices,So=ho.points,Mo=c(),Co=T(ue,Mo),wo=T(ge,Mo),To=i(null),ko=To[0],Bo=To[1],Wo=i(null),Eo=Wo[0],Lo=Wo[1],Go={grid:X(k,{theme:Mo,width:lo,height:so,xScale:I?yo:null,yScale:H?xo:null,xValues:z,yValues:j},"grid"),markers:X(y,{markers:Be,width:lo,height:so,xScale:yo,yScale:xo,theme:Mo},"markers"),axes:X(B,{xScale:yo,yScale:xo,width:lo,height:so,theme:Mo,top:E,right:G,bottom:F,left:V},"axes"),areas:null,lines:X(ce,{lines:go,lineGenerator:po,lineWidth:q},"lines"),slices:null,points:null,crosshair:null,mesh:null,legends:Ee.map((function(e,o){return X(L,Q({},e,{containerWidth:lo,containerHeight:so,data:e.data||fo,theme:Mo,toggleSerie:e.toggleSerie?vo:void 0}),"legend."+o)}))},Po=x(we,go,ke);return K&&(Go.areas=X(le,{areaGenerator:mo,areaOpacity:$,areaBlendMode:ee,lines:go},"areas")),Ge&&!1!==Je&&(Go.slices=X(de,{slices:bo,axis:Je,debug:Ne,height:so,tooltip:Ue,current:Eo,setCurrent:Lo,onMouseEnter:Ye,onMouseMove:Re,onMouseLeave:Ie,onClick:Ae,onTouchStart:He,onTouchMove:Xe,onTouchEnd:ze},"slices")),ie&&(Go.points=X(he,{points:So,symbol:te,size:ae,color:Co,borderWidth:pe,borderColor:wo,enableLabel:xe,label:Se,labelYOffset:Me},"points")),Ge&&$e&&(null!==ko&&(Go.crosshair=X(Y,{width:lo,height:so,x:ko.x,y:ko.y,type:eo},"crosshair")),null!==Eo&&(Go.crosshair=X(Y,{width:lo,height:so,x:Eo.x,y:Eo.y,type:Je},"crosshair"))),Ge&&Fe&&!1===Je&&(Go.mesh=X(fe,{points:So,width:lo,height:so,margin:ao,current:ko,setCurrent:Bo,onMouseEnter:Ye,onMouseMove:Re,onMouseLeave:Ie,onClick:Ae,onTouchStart:He,onTouchMove:Xe,onTouchEnd:ze,tooltip:De,enableTouchCrosshair:io,debug:Ve},"mesh")),X(b,{defs:Po,width:co,height:uo,margin:ao,role:no,children:h.map((function(o,i){return"function"==typeof o?X(r,{children:o(Q({},e,{innerWidth:lo,innerHeight:so,series:go,slices:bo,points:So,xScale:yo,yScale:xo,lineGenerator:po,areaGenerator:mo,currentPoint:ko,setCurrentPoint:Bo,currentSlice:Eo,setCurrentSlice:Lo}))},i):Go[o]}))})})),pe=function(e){return X(S,{children:function(o){var i=o.width,t=o.height;return X(ve,Q({width:i,height:t},e))}})},me=m((function(e){var o=l(null),r=e.width,a=e.height,u=e.margin,d=e.pixelRatio,h=void 0===d?"undefined"!=typeof window&&window.devicePixelRatio||1:d,f=e.data,v=e.xScale,p=void 0===v?{type:"point"}:v,m=e.xFormat,y=e.yScale,x=void 0===y?{type:"linear",min:0,max:"auto"}:y,b=e.yFormat,S=e.curve,w=void 0===S?"linear":S,T=e.layers,k=void 0===T?["grid","markers","axes","areas","crosshair","lines","points","slices","mesh","legends"]:T,B=e.colors,L=void 0===B?{scheme:"nivo"}:B,P=e.lineWidth,F=void 0===P?2:P,O=e.enableArea,Y=void 0!==O&&O,R=e.areaBaselineValue,I=void 0===R?0:R,A=e.areaOpacity,H=void 0===A?.2:A,z=e.enablePoints,j=void 0===z||z,D=e.pointSize,q=void 0===D?6:D,Z=e.pointColor,$=void 0===Z?{from:"color"}:Z,_=e.pointBorderWidth,ee=void 0===_?0:_,oe=e.pointBorderColor,ie=void 0===oe?{theme:"background"}:oe,te=e.enableGridX,ne=void 0===te||te,ae=e.gridXValues,le=e.enableGridY,se=void 0===le||le,ce=e.gridYValues,ue=e.axisTop,de=e.axisRight,he=e.axisBottom,fe=void 0===he?{}:he,ve=e.axisLeft,pe=void 0===ve?{}:ve,me=e.legends,ge=void 0===me?[]:me,ye=e.isInteractive,xe=void 0===ye||ye,be=e.debugMesh,Se=void 0!==be&&be,Me=e.onMouseLeave,Ce=e.onClick,we=e.tooltip,Te=void 0===we?U:we,ke=e.canvasRef,Be=g(r,a,u),We=Be.margin,Ee=Be.innerWidth,Le=Be.innerHeight,Ge=Be.outerWidth,Pe=Be.outerHeight,Fe=c(),Oe=i(null),Ve=Oe[0],Ye=Oe[1],Re=re({data:f,xScale:p,xFormat:m,yScale:x,yFormat:b,width:Ee,height:Le,colors:L,curve:w,areaBaselineValue:I,pointColor:$,pointBorderColor:ie}),Ie=Re.lineGenerator,Ae=Re.areaGenerator,He=Re.series,Xe=Re.xScale,ze=Re.yScale,je=Re.points,De=J({points:je,width:Ee,height:Le,debug:Se}),qe=De.delaunay,Je=De.voronoi;s((function(){ke&&(ke.current=o.current),o.current.width=Ge*h,o.current.height=Pe*h;var e=o.current.getContext("2d");e.scale(h,h),e.fillStyle=Fe.background,e.fillRect(0,0,Ge,Pe),e.translate(We.left,We.top),k.forEach((function(o){if("function"==typeof o&&o({ctx:e,innerWidth:Ee,innerHeight:Le,series:He,points:je,xScale:Xe,yScale:ze,lineWidth:F,lineGenerator:Ie,areaGenerator:Ae,currentPoint:Ve,setCurrentPoint:Ye}),"grid"===o&&Fe.grid.line.strokeWidth>0&&(e.lineWidth=Fe.grid.line.strokeWidth,e.strokeStyle=Fe.grid.line.stroke,ne&&W(e,{width:Ee,height:Le,scale:Xe,axis:"x",values:ae}),se&&W(e,{width:Ee,height:Le,scale:ze,axis:"y",values:ce})),"axes"===o&&E(e,{xScale:Xe,yScale:ze,width:Ee,height:Le,top:ue,right:de,bottom:fe,left:pe,theme:Fe}),"areas"===o&&!0===Y){e.save(),e.globalAlpha=H,Ae.context(e);for(var i=He.length-1;i>=0;i--)e.fillStyle=He[i].color,e.beginPath(),Ae(He[i].data.map((function(e){return e.position}))),e.fill();e.restore()}if("lines"===o&&(Ie.context(e),He.forEach((function(o){e.strokeStyle=o.color,e.lineWidth=F,e.beginPath(),Ie(o.data.map((function(e){return e.position}))),e.stroke()}))),"points"===o&&!0===j&&q>0&&je.forEach((function(o){e.fillStyle=o.color,e.beginPath(),e.arc(o.x,o.y,q/2,0,2*Math.PI),e.fill(),ee>0&&(e.strokeStyle=o.borderColor,e.lineWidth=ee,e.stroke())})),"mesh"===o&&!0===Se&&(K(e,Je),Ve&&N(e,Je,Ve.index)),"legends"===o){var t=He.map((function(e){return{id:e.id,label:e.id,color:e.color}})).reverse();ge.forEach((function(o){G(e,Q({},o,{data:o.data||t,containerWidth:Ee,containerHeight:Le,theme:Fe}))}))}}))}),[o,Ge,Pe,k,Fe,Ie,He,Xe,ze,ne,ae,se,ce,ue,de,fe,pe,ge,je,j,q,Ve]);var Ke=t((function(e){var i=M(o.current,e),t=i[0],n=i[1];if(!C(We.left,We.top,Ee,Le,t,n))return null;var r=qe.find(t-We.left,n-We.top);return je[r]}),[o,We,Ee,Le,qe]),Ne=V(),Qe=Ne.showTooltipFromEvent,Ue=Ne.hideTooltip,Ze=t((function(e){var o=Ke(e);Ye(o),o?Qe(n(Te,{point:o}),e):Ue()}),[Ke,Ye,Qe,Ue,Te]),$e=t((function(e){Ue(),Ye(null),Ve&&Me&&Me(Ve,e)}),[Ue,Ye,Me]),_e=t((function(e){if(Ce){var o=Ke(e);o&&Ce(o,e)}}),[Ke,Ce]);return X("canvas",{ref:o,width:Ge*h,height:Pe*h,style:{width:Ge,height:Pe,cursor:xe?"auto":"normal"},onMouseEnter:xe?Ze:void 0,onMouseMove:xe?Ze:void 0,onMouseLeave:xe?$e:void 0,onClick:xe?_e:void 0})})),ge=a((function(e,o){return X(me,Q({},e,{canvasRef:o}))})),ye=a((function(e,o){return X(S,{children:function(i){var t=i.width,n=i.height;return X(ge,Q({width:t,height:n},e,{ref:o}))}})}));export{ne as LINE_UNIQUE_ID_PREFIX,ve as Line,ge as LineCanvas,ee as LineCanvasDefaultProps,_ as LineDefaultProps,pe as ResponsiveLine,ye as ResponsiveLineCanvas,ie as useAreaGenerator,re as useLine,oe as useLineGenerator,te as useSlices};
+import{memo as e,useMemo as o,useState as i,useCallback as t,createElement as n,Fragment as r,forwardRef as a,useRef as l,useEffect as s}from"react";import{useTheme as d,curveFromProp as c,useValueFormatter as u,useMotionConfig as h,useAnimatedPath as f,getLabelGenerator as v,DotsItem as p,withContainer as m,useDimensions as g,CartesianMarkers as y,bindDefs as x,SvgWrapper as b,ResponsiveWrapper as S,getRelativeCursor as M,isCursorInRect as C}from"@nivo/core";import{useOrdinalColorScale as w,useInheritedColor as T}from"@nivo/colors";import{Grid as k,Axes as B,renderGridLinesToCanvas as W,renderAxesToCanvas as E}from"@nivo/axes";import{BoxLegendSvg as L,renderLegendToCanvas as G}from"@nivo/legends";import{BasicTooltip as P,TableTooltip as F,Chip as O,useTooltip as V,Crosshair as I}from"@nivo/tooltip";import{line as H,area as Y}from"d3-shape";import{computeXYScalesForSeries as R}from"@nivo/scales";import A from"lodash/uniqueId";import{jsx as X,jsxs as z}from"react/jsx-runtime";import{useSpring as j,animated as D}from"@react-spring/web";import{Mesh as q,useVoronoiMesh as J,renderVoronoiToCanvas as K,renderVoronoiCellToCanvas as N}from"@nivo/voronoi";function Q(){return Q=Object.assign?Object.assign.bind():function(e){for(var o=1;o<arguments.length;o++){var i=arguments[o];for(var t in i)Object.prototype.hasOwnProperty.call(i,t)&&(e[t]=i[t])}return e},Q.apply(this,arguments)}var U=e((function(e){var o=e.point;return X(P,{id:z("span",{children:["x: ",X("strong",{children:o.data.xFormatted}),", y:"," ",X("strong",{children:o.data.yFormatted})]}),enableChip:!0,color:o.serieColor})})),Z=e((function(e){var o=e.slice,i=e.axis,t=d(),n="x"===i?"y":"x";return X(F,{rows:o.points.map((function(e){return[X(O,{color:e.serieColor,style:t.tooltip.chip},"chip"),e.serieId,X("span",{style:t.tooltip.tableCellValue,children:e.data[n+"Formatted"]},"value")]}))})})),$={curve:"linear",xScale:{type:"point"},yScale:{type:"linear",min:0,max:"auto"},layers:["grid","markers","axes","areas","crosshair","lines","points","slices","mesh","legends"],axisBottom:{},axisLeft:{},enableGridX:!0,enableGridY:!0,enablePoints:!0,pointSize:6,pointColor:{from:"color"},pointBorderWidth:0,pointBorderColor:{theme:"background"},enablePointLabel:!1,pointLabel:"yFormatted",colors:{scheme:"nivo"},enableArea:!1,areaBaselineValue:0,areaOpacity:.2,areaBlendMode:"normal",lineWidth:2,legends:[],isInteractive:!0,tooltip:U,enableSlices:!1,debugSlices:!1,sliceTooltip:Z,debugMesh:!1,enableCrosshair:!0,crosshairType:"bottom-left"},_=Q({},$,{enablePointLabel:!1,useMesh:!1,enableTouchCrosshair:!1,animate:!0,motionConfig:"gentle",defs:[],fill:[],role:"img",initialHiddenIds:[]}),ee=Q({},$,{pixelRatio:"undefined"!=typeof window&&window.devicePixelRatio||1}),oe=function(e){var i=e.curve;return o((function(){return H().defined((function(e){return null!==e.x&&null!==e.y})).x((function(e){return e.x})).y((function(e){return e.y})).curve(c(i))}),[i])},ie=function(e){var i=e.curve,t=e.yScale,n=e.areaBaselineValue;return o((function(){return Y().defined((function(e){return null!==e.x&&null!==e.y})).x((function(e){return e.x})).y1((function(e){return e.y})).curve(c(i)).y0(t(n))}),[i,t,n])},te=function(e){var i=e.componentId,t=e.enableSlices,n=e.points,r=e.width,a=e.height;return o((function(){if(!1===t)return[];if("x"===t){var e=new Map;return n.forEach((function(o){null!==o.data.x&&null!==o.data.y&&(e.has(o.x)?e.get(o.x).push(o):e.set(o.x,[o]))})),Array.from(e.entries()).sort((function(e,o){return e[0]-o[0]})).map((function(e,o,t){var n,l,s=e[0],d=e[1],c=t[o-1],u=t[o+1];return n=c?s-(s-c[0])/2:s,l=u?s-n+(u[0]-s)/2:r-n,{id:"slice:"+i+":"+s,x0:n,x:s,y0:0,y:0,width:l,height:a,points:d.reverse()}}))}if("y"===t){var o=new Map;return n.forEach((function(e){null!==e.data.x&&null!==e.data.y&&(o.has(e.y)?o.get(e.y).push(e):o.set(e.y,[e]))})),Array.from(o.entries()).sort((function(e,o){return e[0]-o[0]})).map((function(e,o,i){var t,n,l=e[0],s=e[1],d=i[o-1],c=i[o+1];return t=d?l-(l-d[0])/2:l,n=c?l-t+(c[0]-l)/2:a-t,{id:l,x0:0,x:0,y0:t,y:l,width:r,height:n,points:s.reverse()}}))}}),[i,t,a,n,r])},ne="line",re=function(e){var n=e.data,r=e.xScale,a=void 0===r?_.xScale:r,l=e.xFormat,s=e.yScale,c=void 0===s?_.yScale:s,h=e.yFormat,f=e.width,v=e.height,p=e.colors,m=void 0===p?_.colors:p,g=e.curve,y=void 0===g?_.curve:g,x=e.areaBaselineValue,b=void 0===x?_.areaBaselineValue:x,S=e.pointColor,M=void 0===S?_.pointColor:S,C=e.pointBorderColor,k=void 0===C?_.pointBorderColor:C,B=e.enableSlices,W=void 0===B?_.enableSlicesTooltip:B,E=e.initialHiddenIds,L=void 0===E?_.initialHiddenIds:E,G=i(A(ne))[0],P=u(l),F=u(h),O=w(m,"id"),V=d(),I=T(M,V),H=T(k,V),Y=i(null!=L?L:[]),X=Y[0],z=Y[1],j=o((function(){return R(n.filter((function(e){return-1===X.indexOf(e.id)})),a,c,f,v)}),[n,X,a,c,f,v]),D=j.xScale,q=j.yScale,J=j.series,K=o((function(){var e=n.map((function(e){return{id:e.id,label:e.id,color:O(e)}})),o=e.map((function(e){return Q({},J.find((function(o){return o.id===e.id})),{color:e.color})})).filter((function(e){return Boolean(e.id)}));return{legendData:e.map((function(e){return Q({},e,{hidden:!o.find((function(o){return o.id===e.id}))})})).reverse(),series:o}}),[n,J,O]),N=K.legendData,U=K.series,Z=t((function(e){z((function(o){return o.indexOf(e)>-1?o.filter((function(o){return o!==e})):[].concat(o,[e])}))}),[]),$=function(e){var i=e.series,t=e.getPointColor,n=e.getPointBorderColor,r=e.formatX,a=e.formatY;return o((function(){return i.reduce((function(e,o){return[].concat(e,o.data.filter((function(e){return null!==e.position.x&&null!==e.position.y})).map((function(i,l){var s={id:o.id+"."+l,index:e.length+l,serieId:o.id,serieColor:o.color,x:i.position.x,y:i.position.y};return s.color=t(o),s.borderColor=n(s),s.data=Q({},i.data,{xFormatted:r(i.data.x),yFormatted:a(i.data.y)}),s})))}),[])}),[i,t,n,r,a])}({series:U,getPointColor:I,getPointBorderColor:H,formatX:P,formatY:F}),ee=te({componentId:G,enableSlices:W,points:$,width:f,height:v});return{legendData:N,toggleSerie:Z,lineGenerator:oe({curve:y}),areaGenerator:ie({curve:y,yScale:q,areaBaselineValue:b}),getColor:O,series:U,xScale:D,yScale:q,slices:ee,points:$}},ae=function(e){var o=e.areaBlendMode,i=e.areaOpacity,t=e.color,n=e.fill,r=e.path,a=h(),l=a.animate,s=a.config,d=f(r),c=j({color:t,config:s,immediate:!l});return X(D.path,{d:d,fill:n||c.color,fillOpacity:i,strokeWidth:0,style:{mixBlendMode:o}})},le=e((function(e){var o=e.areaGenerator,i=e.areaOpacity,t=e.areaBlendMode,n=e.lines.slice(0).reverse();return X("g",{children:n.map((function(e){return X(ae,Q({path:o(e.data.map((function(e){return e.position})))},Q({areaOpacity:i,areaBlendMode:t},e)),e.id)}))})})),se=e((function(e){var i=e.lineGenerator,t=e.points,n=e.color,r=e.thickness,a=o((function(){return i(t)}),[i,t]),l=f(a);return X(D.path,{d:l,fill:"none",strokeWidth:r,stroke:n})})),de=e((function(e){var o=e.lines,i=e.lineGenerator,t=e.lineWidth;return o.slice(0).reverse().map((function(e){var o=e.id,n=e.data,r=e.color;return X(se,{id:o,points:n.map((function(e){return e.position})),lineGenerator:i,color:r,thickness:t},o)}))})),ce=e((function(e){var o=e.slice,i=e.slices,r=e.axis,a=e.debug,l=e.tooltip,s=e.isCurrent,d=e.setCurrent,c=e.onMouseEnter,u=e.onMouseMove,h=e.onMouseLeave,f=e.onClick,v=e.onTouchStart,p=e.onTouchMove,m=e.onTouchEnd,g=V(),y=g.showTooltipFromEvent,x=g.hideTooltip,b=t((function(e){y(n(l,{slice:o,axis:r}),e,"right"),d(o),c&&c(o,e)}),[y,l,o,r,d,c]),S=t((function(e){y(n(l,{slice:o,axis:r}),e,"right"),u&&u(o,e)}),[y,l,o,r,u]),M=t((function(e){x(),d(null),h&&h(o,e)}),[x,d,h,o]),C=t((function(e){f&&f(o,e)}),[o,f]),w=t((function(e){y(n(l,{slice:o,axis:r}),e,"right"),d(o),v&&v(o,e)}),[r,v,d,y,o,l]),T=t((function(e){var t=e.touches[0],a=document.elementFromPoint(t.clientX,t.clientY),s=null==a?void 0:a.getAttribute("data-ref");if(s){var c=i.find((function(e){return e.id===s}));c&&(y(n(l,{slice:c,axis:r}),e,"right"),d(c))}p&&p(o,e)}),[r,p,d,y,o,i,l]),k=t((function(e){x(),d(null),m&&m(o,e)}),[x,d,m,o]);return X("rect",{x:o.x0,y:o.y0,width:o.width,height:o.height,stroke:"red",strokeWidth:a?1:0,strokeOpacity:.75,fill:"red",fillOpacity:s&&a?.35:0,onMouseEnter:b,onMouseMove:S,onMouseLeave:M,onClick:C,onTouchStart:w,onTouchMove:T,onTouchEnd:k,"data-ref":o.id})})),ue=e((function(e){var o=e.slices,i=e.axis,t=e.debug,n=e.height,r=e.tooltip,a=e.current,l=e.setCurrent,s=e.onMouseEnter,d=e.onMouseMove,c=e.onMouseLeave,u=e.onClick,h=e.onTouchStart,f=e.onTouchMove,v=e.onTouchEnd;return o.map((function(e){return X(ce,{slice:e,slices:o,axis:i,debug:t,height:n,tooltip:r,setCurrent:l,isCurrent:null!==a&&a.id===e.id,onMouseEnter:s,onMouseMove:d,onMouseLeave:c,onClick:u,onTouchStart:h,onTouchMove:f,onTouchEnd:v},e.id)}))})),he=e((function(e){var o=e.points,i=e.symbol,t=e.size,n=e.borderWidth,r=e.enableLabel,a=e.label,l=e.labelYOffset,s=d(),c=v(a),u=o.slice(0).reverse().map((function(e){return{id:e.id,x:e.x,y:e.y,datum:e.data,fill:e.color,stroke:e.borderColor,label:r?c(e):null}}));return X("g",{children:u.map((function(e){return X(p,{x:e.x,y:e.y,datum:e.datum,symbol:i,size:t,color:e.fill,borderWidth:n,borderColor:e.stroke,label:e.label,labelYOffset:l,theme:s},e.id)}))})})),fe=e((function(e){var o=e.points,i=e.width,r=e.height,a=e.margin,l=e.setCurrent,s=e.onMouseEnter,d=e.onMouseMove,c=e.onMouseLeave,u=e.onClick,h=e.onTouchStart,f=e.onTouchMove,v=e.onTouchEnd,p=e.tooltip,m=e.debug,g=e.enableTouchCrosshair,y=V(),x=y.showTooltipAt,b=y.hideTooltip,S=t((function(e,o){x(n(p,{point:e}),[e.x+a.left,e.y+a.top],"top"),s&&s(e,o)}),[x,p,s,a]),M=t((function(e,o){x(n(p,{point:e}),[e.x+a.left,e.y+a.top],"top"),d&&d(e,o)}),[x,p,a.left,a.top,d]),C=t((function(e,o){b(),c&&c(e,o)}),[b,c]),w=t((function(e,o){u&&u(e,o)}),[u]),T=t((function(e,o){x(n(p,{point:e}),[e.x+a.left,e.y+a.top],"top"),h&&h(e,o)}),[a.left,a.top,h,x,p]),k=t((function(e,o){x(n(p,{point:e}),[e.x+a.left,e.y+a.top],"top"),f&&f(e,o)}),[a.left,a.top,f,x,p]),B=t((function(e,o){b(),v&&v(e,o)}),[v,b]);return X(q,{nodes:o,width:i,height:r,setCurrent:l,onMouseEnter:S,onMouseMove:M,onMouseLeave:C,onClick:w,onTouchStart:T,onTouchMove:k,onTouchEnd:B,enableTouchCrosshair:g,debug:m})})),ve=m((function(e){var o=e.data,t=e.xScale,n=void 0===t?{type:"point"}:t,a=e.xFormat,l=e.yScale,s=void 0===l?{type:"linear",min:0,max:"auto"}:l,c=e.yFormat,u=e.layers,h=void 0===u?["grid","markers","axes","areas","crosshair","lines","points","slices","mesh","legends"]:u,f=e.curve,v=void 0===f?"linear":f,p=e.areaBaselineValue,m=void 0===p?0:p,S=e.colors,M=void 0===S?{scheme:"nivo"}:S,C=e.margin,w=e.width,W=e.height,E=e.axisTop,G=e.axisRight,P=e.axisBottom,F=void 0===P?{}:P,O=e.axisLeft,V=void 0===O?{}:O,H=e.enableGridX,Y=void 0===H||H,R=e.enableGridY,A=void 0===R||R,z=e.gridXValues,j=e.gridYValues,D=e.lineWidth,q=void 0===D?2:D,J=e.enableArea,K=void 0!==J&&J,N=e.areaOpacity,$=void 0===N?.2:N,_=e.areaBlendMode,ee=void 0===_?"normal":_,oe=e.enablePoints,ie=void 0===oe||oe,te=e.pointSymbol,ne=e.pointSize,ae=void 0===ne?6:ne,se=e.pointColor,ce=void 0===se?{from:"color"}:se,ve=e.pointBorderWidth,pe=void 0===ve?0:ve,me=e.pointBorderColor,ge=void 0===me?{theme:"background"}:me,ye=e.enablePointLabel,xe=void 0!==ye&&ye,be=e.pointLabel,Se=void 0===be?"data.yFormatted":be,Me=e.pointLabelYOffset,Ce=e.defs,we=void 0===Ce?[]:Ce,Te=e.fill,ke=void 0===Te?[]:Te,Be=e.markers,We=e.legends,Ee=void 0===We?[]:We,Le=e.isInteractive,Ge=void 0===Le||Le,Pe=e.useMesh,Fe=void 0!==Pe&&Pe,Oe=e.debugMesh,Ve=void 0!==Oe&&Oe,Ie=e.onMouseEnter,He=e.onMouseMove,Ye=e.onMouseLeave,Re=e.onClick,Ae=e.onTouchStart,Xe=e.onTouchMove,ze=e.onTouchEnd,je=e.tooltip,De=void 0===je?U:je,qe=e.enableSlices,Je=void 0!==qe&&qe,Ke=e.debugSlices,Ne=void 0!==Ke&&Ke,Qe=e.sliceTooltip,Ue=void 0===Qe?Z:Qe,Ze=e.enableCrosshair,$e=void 0===Ze||Ze,_e=e.crosshairType,eo=void 0===_e?"bottom-left":_e,oo=e.enableTouchCrosshair,io=void 0!==oo&&oo,to=e.role,no=void 0===to?"img":to,ro=e.initialHiddenIds,ao=void 0===ro?[]:ro,lo=g(w,W,C),so=lo.margin,co=lo.innerWidth,uo=lo.innerHeight,ho=lo.outerWidth,fo=lo.outerHeight,vo=re({data:o,xScale:n,xFormat:a,yScale:s,yFormat:c,width:co,height:uo,colors:M,curve:v,areaBaselineValue:m,pointColor:ce,pointBorderColor:ge,enableSlices:Je,initialHiddenIds:ao}),po=vo.legendData,mo=vo.toggleSerie,go=vo.lineGenerator,yo=vo.areaGenerator,xo=vo.series,bo=vo.xScale,So=vo.yScale,Mo=vo.slices,Co=vo.points,wo=d(),To=T(ce,wo),ko=T(ge,wo),Bo=i(null),Wo=Bo[0],Eo=Bo[1],Lo=i(null),Go=Lo[0],Po=Lo[1],Fo={grid:X(k,{theme:wo,width:co,height:uo,xScale:Y?bo:null,yScale:A?So:null,xValues:z,yValues:j},"grid"),markers:X(y,{markers:Be,width:co,height:uo,xScale:bo,yScale:So,theme:wo},"markers"),axes:X(B,{xScale:bo,yScale:So,width:co,height:uo,theme:wo,top:E,right:G,bottom:F,left:V},"axes"),areas:null,lines:X(de,{lines:xo,lineGenerator:go,lineWidth:q},"lines"),slices:null,points:null,crosshair:null,mesh:null,legends:Ee.map((function(e,o){return X(L,Q({},e,{containerWidth:co,containerHeight:uo,data:e.data||po,theme:wo,toggleSerie:e.toggleSerie?mo:void 0}),"legend."+o)}))},Oo=x(we,xo,ke);return K&&(Fo.areas=X(le,{areaGenerator:yo,areaOpacity:$,areaBlendMode:ee,lines:xo},"areas")),Ge&&!1!==Je&&(Fo.slices=X(ue,{slices:Mo,axis:Je,debug:Ne,height:uo,tooltip:Ue,current:Go,setCurrent:Po,onMouseEnter:Ie,onMouseMove:He,onMouseLeave:Ye,onClick:Re,onTouchStart:Ae,onTouchMove:Xe,onTouchEnd:ze},"slices")),ie&&(Fo.points=X(he,{points:Co,symbol:te,size:ae,color:To,borderWidth:pe,borderColor:ko,enableLabel:xe,label:Se,labelYOffset:Me},"points")),Ge&&$e&&(null!==Wo&&(Fo.crosshair=X(I,{width:co,height:uo,x:Wo.x,y:Wo.y,type:eo},"crosshair")),null!==Go&&(Fo.crosshair=X(I,{width:co,height:uo,x:Go.x,y:Go.y,type:Je},"crosshair"))),Ge&&Fe&&!1===Je&&(Fo.mesh=X(fe,{points:Co,width:co,height:uo,margin:so,current:Wo,setCurrent:Eo,onMouseEnter:Ie,onMouseMove:He,onMouseLeave:Ye,onClick:Re,onTouchStart:Ae,onTouchMove:Xe,onTouchEnd:ze,tooltip:De,enableTouchCrosshair:io,debug:Ve},"mesh")),X(b,{defs:Oo,width:ho,height:fo,margin:so,role:no,children:h.map((function(o,i){return"function"==typeof o?X(r,{children:o(Q({},e,{innerWidth:co,innerHeight:uo,series:xo,slices:Mo,points:Co,xScale:bo,yScale:So,lineGenerator:go,areaGenerator:yo,currentPoint:Wo,setCurrentPoint:Eo,currentSlice:Go,setCurrentSlice:Po}))},i):Fo[o]}))})})),pe=function(e){return X(S,{children:function(o){var i=o.width,t=o.height;return X(ve,Q({width:i,height:t},e))}})},me=m((function(e){var o=l(null),r=e.width,a=e.height,c=e.margin,u=e.pixelRatio,h=void 0===u?"undefined"!=typeof window&&window.devicePixelRatio||1:u,f=e.data,v=e.xScale,p=void 0===v?{type:"point"}:v,m=e.xFormat,y=e.yScale,x=void 0===y?{type:"linear",min:0,max:"auto"}:y,b=e.yFormat,S=e.curve,w=void 0===S?"linear":S,T=e.layers,k=void 0===T?["grid","markers","axes","areas","crosshair","lines","points","slices","mesh","legends"]:T,B=e.colors,L=void 0===B?{scheme:"nivo"}:B,P=e.lineWidth,F=void 0===P?2:P,O=e.enableArea,I=void 0!==O&&O,H=e.areaBaselineValue,Y=void 0===H?0:H,R=e.areaOpacity,A=void 0===R?.2:R,z=e.enablePoints,j=void 0===z||z,D=e.pointSize,q=void 0===D?6:D,Z=e.pointColor,$=void 0===Z?{from:"color"}:Z,_=e.pointBorderWidth,ee=void 0===_?0:_,oe=e.pointBorderColor,ie=void 0===oe?{theme:"background"}:oe,te=e.enableGridX,ne=void 0===te||te,ae=e.gridXValues,le=e.enableGridY,se=void 0===le||le,de=e.gridYValues,ce=e.axisTop,ue=e.axisRight,he=e.axisBottom,fe=void 0===he?{}:he,ve=e.axisLeft,pe=void 0===ve?{}:ve,me=e.legends,ge=void 0===me?[]:me,ye=e.isInteractive,xe=void 0===ye||ye,be=e.debugMesh,Se=void 0!==be&&be,Me=e.onMouseLeave,Ce=e.onClick,we=e.tooltip,Te=void 0===we?U:we,ke=e.canvasRef,Be=g(r,a,c),We=Be.margin,Ee=Be.innerWidth,Le=Be.innerHeight,Ge=Be.outerWidth,Pe=Be.outerHeight,Fe=d(),Oe=i(null),Ve=Oe[0],Ie=Oe[1],He=re({data:f,xScale:p,xFormat:m,yScale:x,yFormat:b,width:Ee,height:Le,colors:L,curve:w,areaBaselineValue:Y,pointColor:$,pointBorderColor:ie}),Ye=He.lineGenerator,Re=He.areaGenerator,Ae=He.series,Xe=He.xScale,ze=He.yScale,je=He.points,De=J({points:je,width:Ee,height:Le,debug:Se}),qe=De.delaunay,Je=De.voronoi;s((function(){ke&&(ke.current=o.current),o.current.width=Ge*h,o.current.height=Pe*h;var e=o.current.getContext("2d");e.scale(h,h),e.fillStyle=Fe.background,e.fillRect(0,0,Ge,Pe),e.translate(We.left,We.top),k.forEach((function(o){if("function"==typeof o&&o({ctx:e,innerWidth:Ee,innerHeight:Le,series:Ae,points:je,xScale:Xe,yScale:ze,lineWidth:F,lineGenerator:Ye,areaGenerator:Re,currentPoint:Ve,setCurrentPoint:Ie}),"grid"===o&&Fe.grid.line.strokeWidth>0&&(e.lineWidth=Fe.grid.line.strokeWidth,e.strokeStyle=Fe.grid.line.stroke,ne&&W(e,{width:Ee,height:Le,scale:Xe,axis:"x",values:ae}),se&&W(e,{width:Ee,height:Le,scale:ze,axis:"y",values:de})),"axes"===o&&E(e,{xScale:Xe,yScale:ze,width:Ee,height:Le,top:ce,right:ue,bottom:fe,left:pe,theme:Fe}),"areas"===o&&!0===I){e.save(),e.globalAlpha=A,Re.context(e);for(var i=Ae.length-1;i>=0;i--)e.fillStyle=Ae[i].color,e.beginPath(),Re(Ae[i].data.map((function(e){return e.position}))),e.fill();e.restore()}if("lines"===o&&(Ye.context(e),Ae.forEach((function(o){e.strokeStyle=o.color,e.lineWidth=F,e.beginPath(),Ye(o.data.map((function(e){return e.position}))),e.stroke()}))),"points"===o&&!0===j&&q>0&&je.forEach((function(o){e.fillStyle=o.color,e.beginPath(),e.arc(o.x,o.y,q/2,0,2*Math.PI),e.fill(),ee>0&&(e.strokeStyle=o.borderColor,e.lineWidth=ee,e.stroke())})),"mesh"===o&&!0===Se&&(K(e,Je),Ve&&N(e,Je,Ve.index)),"legends"===o){var t=Ae.map((function(e){return{id:e.id,label:e.id,color:e.color}})).reverse();ge.forEach((function(o){G(e,Q({},o,{data:o.data||t,containerWidth:Ee,containerHeight:Le,theme:Fe}))}))}}))}),[o,Ge,Pe,k,Fe,Ye,Ae,Xe,ze,ne,ae,se,de,ce,ue,fe,pe,ge,je,j,q,Ve]);var Ke=t((function(e){var i=M(o.current,e),t=i[0],n=i[1];if(!C(We.left,We.top,Ee,Le,t,n))return null;var r=qe.find(t-We.left,n-We.top);return je[r]}),[o,We,Ee,Le,qe]),Ne=V(),Qe=Ne.showTooltipFromEvent,Ue=Ne.hideTooltip,Ze=t((function(e){var o=Ke(e);Ie(o),o?Qe(n(Te,{point:o}),e):Ue()}),[Ke,Ie,Qe,Ue,Te]),$e=t((function(e){Ue(),Ie(null),Ve&&Me&&Me(Ve,e)}),[Ue,Ie,Me]),_e=t((function(e){if(Ce){var o=Ke(e);o&&Ce(o,e)}}),[Ke,Ce]);return X("canvas",{ref:o,width:Ge*h,height:Pe*h,style:{width:Ge,height:Pe,cursor:xe?"auto":"normal"},onMouseEnter:xe?Ze:void 0,onMouseMove:xe?Ze:void 0,onMouseLeave:xe?$e:void 0,onClick:xe?_e:void 0})})),ge=a((function(e,o){return X(me,Q({},e,{canvasRef:o}))})),ye=a((function(e,o){return X(S,{children:function(i){var t=i.width,n=i.height;return X(ge,Q({width:t,height:n},e,{ref:o}))}})}));export{ne as LINE_UNIQUE_ID_PREFIX,ve as Line,ge as LineCanvas,ee as LineCanvasDefaultProps,_ as LineDefaultProps,pe as ResponsiveLine,ye as ResponsiveLineCanvas,ie as useAreaGenerator,re as useLine,oe as useLineGenerator,te as useSlices};
 //# sourceMappingURL=nivo-line.es.js.map
diff --git a/dist/nivo-line.es.js.map b/dist/nivo-line.es.js.map
index 0d30a9b6f236eadb24dbf21c72b6612c248122b0..8fd833aea841bb57dba1b1944be37614d1aeb742 100644
--- a/dist/nivo-line.es.js.map
+++ b/dist/nivo-line.es.js.map
@@ -1 +1 @@
-{"version":3,"file":"nivo-line.es.js","sources":["../src/PointTooltip.js","../src/SliceTooltip.js","../src/props.js","../src/hooks.js","../src/Areas.js","../src/LinesItem.js","../src/Lines.js","../src/SlicesItem.js","../src/Slices.js","../src/Points.js","../src/Mesh.js","../src/Line.js","../src/ResponsiveLine.js","../src/LineCanvas.js","../src/ResponsiveLineCanvas.js"],"sourcesContent":["import { memo } from 'react'\nimport { BasicTooltip } from '@nivo/tooltip'\n\nconst LinePointTooltip = ({ point }) => {\n    return (\n        <BasicTooltip\n            id={\n                <span>\n                    x: <strong>{point.data.xFormatted}</strong>, y:{' '}\n                    <strong>{point.data.yFormatted}</strong>\n                </span>\n            }\n            enableChip={true}\n            color={point.serieColor}\n        />\n    )\n}\n\nexport default memo(LinePointTooltip)\n","import { memo } from 'react'\nimport { useTheme } from '@nivo/core'\nimport { Chip, TableTooltip } from '@nivo/tooltip'\n\nconst SliceTooltip = ({ slice, axis }) => {\n    const theme = useTheme()\n    const otherAxis = axis === 'x' ? 'y' : 'x'\n\n    return (\n        <TableTooltip\n            rows={slice.points.map(point => [\n                <Chip key=\"chip\" color={point.serieColor} style={theme.tooltip.chip} />,\n                point.serieId,\n                <span key=\"value\" style={theme.tooltip.tableCellValue}>\n                    {point.data[`${otherAxis}Formatted`]}\n                </span>,\n            ])}\n        />\n    )\n}\n\nexport default memo(SliceTooltip)\n","import PointTooltip from './PointTooltip'\nimport SliceTooltip from './SliceTooltip'\n\nconst commonDefaultProps = {\n    curve: 'linear',\n\n    xScale: {\n        type: 'point',\n    },\n    yScale: {\n        type: 'linear',\n        min: 0,\n        max: 'auto',\n    },\n\n    layers: [\n        'grid',\n        'markers',\n        'axes',\n        'areas',\n        'crosshair',\n        'lines',\n        'points',\n        'slices',\n        'mesh',\n        'legends',\n    ],\n    axisBottom: {},\n    axisLeft: {},\n    enableGridX: true,\n    enableGridY: true,\n\n    enablePoints: true,\n    pointSize: 6,\n    pointColor: { from: 'color' },\n    pointBorderWidth: 0,\n    pointBorderColor: { theme: 'background' },\n    enablePointLabel: false,\n    pointLabel: 'yFormatted',\n\n    colors: { scheme: 'nivo' },\n    enableArea: false,\n    areaBaselineValue: 0,\n    areaOpacity: 0.2,\n    areaBlendMode: 'normal',\n    lineWidth: 2,\n\n    legends: [],\n\n    isInteractive: true,\n    tooltip: PointTooltip,\n    enableSlices: false,\n    debugSlices: false,\n    sliceTooltip: SliceTooltip,\n    debugMesh: false,\n    enableCrosshair: true,\n    crosshairType: 'bottom-left',\n}\n\nexport const LineDefaultProps = {\n    ...commonDefaultProps,\n    enablePointLabel: false,\n    useMesh: false,\n    enableTouchCrosshair: false,\n    animate: true,\n    motionConfig: 'gentle',\n    defs: [],\n    fill: [],\n    role: 'img',\n}\n\nexport const LineCanvasDefaultProps = {\n    ...commonDefaultProps,\n    pixelRatio: typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1,\n}\n","import { useCallback, useMemo, useState } from 'react'\nimport { area, line } from 'd3-shape'\nimport { curveFromProp, useTheme, useValueFormatter } from '@nivo/core'\nimport { useOrdinalColorScale, useInheritedColor } from '@nivo/colors'\nimport { computeXYScalesForSeries } from '@nivo/scales'\nimport uniqueId from 'lodash/uniqueId'\nimport { LineDefaultProps } from './props'\n\nexport const useLineGenerator = ({ curve }) => {\n    return useMemo(\n        () =>\n            line()\n                .defined(d => d.x !== null && d.y !== null)\n                .x(d => d.x)\n                .y(d => d.y)\n                .curve(curveFromProp(curve)),\n        [curve]\n    )\n}\n\nexport const useAreaGenerator = ({ curve, yScale, areaBaselineValue }) => {\n    return useMemo(() => {\n        return area()\n            .defined(d => d.x !== null && d.y !== null)\n            .x(d => d.x)\n            .y1(d => d.y)\n            .curve(curveFromProp(curve))\n            .y0(yScale(areaBaselineValue))\n    }, [curve, yScale, areaBaselineValue])\n}\n\nconst usePoints = ({ series, getPointColor, getPointBorderColor, formatX, formatY }) => {\n    return useMemo(() => {\n        return series.reduce((acc, serie) => {\n            return [\n                ...acc,\n                ...serie.data\n                    .filter(datum => datum.position.x !== null && datum.position.y !== null)\n                    .map((datum, i) => {\n                        const point = {\n                            id: `${serie.id}.${i}`,\n                            index: acc.length + i,\n                            serieId: serie.id,\n                            serieColor: serie.color,\n                            x: datum.position.x,\n                            y: datum.position.y,\n                        }\n                        point.color = getPointColor(serie)\n                        point.borderColor = getPointBorderColor(point)\n                        point.data = {\n                            ...datum.data,\n                            xFormatted: formatX(datum.data.x),\n                            yFormatted: formatY(datum.data.y),\n                        }\n\n                        return point\n                    }),\n            ]\n        }, [])\n    }, [series, getPointColor, getPointBorderColor, formatX, formatY])\n}\n\nexport const useSlices = ({ componentId, enableSlices, points, width, height }) => {\n    return useMemo(() => {\n        if (enableSlices === false) return []\n\n        if (enableSlices === 'x') {\n            const map = new Map()\n            points.forEach(point => {\n                if (point.data.x === null || point.data.y === null) return\n                if (!map.has(point.x)) map.set(point.x, [point])\n                else map.get(point.x).push(point)\n            })\n            return Array.from(map.entries())\n                .sort((a, b) => a[0] - b[0])\n                .map(([x, slicePoints], i, slices) => {\n                    const prevSlice = slices[i - 1]\n                    const nextSlice = slices[i + 1]\n\n                    let x0\n                    if (!prevSlice) x0 = x\n                    else x0 = x - (x - prevSlice[0]) / 2\n\n                    let sliceWidth\n                    if (!nextSlice) sliceWidth = width - x0\n                    else sliceWidth = x - x0 + (nextSlice[0] - x) / 2\n\n                    return {\n                        id: `slice:${componentId}:${x}`,\n                        x0,\n                        x,\n                        y0: 0,\n                        y: 0,\n                        width: sliceWidth,\n                        height,\n                        points: slicePoints.reverse(),\n                    }\n                })\n        } else if (enableSlices === 'y') {\n            const map = new Map()\n            points.forEach(point => {\n                if (point.data.x === null || point.data.y === null) return\n                if (!map.has(point.y)) map.set(point.y, [point])\n                else map.get(point.y).push(point)\n            })\n            return Array.from(map.entries())\n                .sort((a, b) => a[0] - b[0])\n                .map(([y, slicePoints], i, slices) => {\n                    const prevSlice = slices[i - 1]\n                    const nextSlice = slices[i + 1]\n\n                    let y0\n                    if (!prevSlice) y0 = y\n                    else y0 = y - (y - prevSlice[0]) / 2\n\n                    let sliceHeight\n                    if (!nextSlice) sliceHeight = height - y0\n                    else sliceHeight = y - y0 + (nextSlice[0] - y) / 2\n\n                    return {\n                        id: y,\n                        x0: 0,\n                        x: 0,\n                        y0,\n                        y,\n                        width,\n                        height: sliceHeight,\n                        points: slicePoints.reverse(),\n                    }\n                })\n        }\n    }, [componentId, enableSlices, height, points, width])\n}\n\nexport const LINE_UNIQUE_ID_PREFIX = 'line'\n\nexport const useLine = ({\n    data,\n    xScale: xScaleSpec = LineDefaultProps.xScale,\n    xFormat,\n    yScale: yScaleSpec = LineDefaultProps.yScale,\n    yFormat,\n    width,\n    height,\n    colors = LineDefaultProps.colors,\n    curve = LineDefaultProps.curve,\n    areaBaselineValue = LineDefaultProps.areaBaselineValue,\n    pointColor = LineDefaultProps.pointColor,\n    pointBorderColor = LineDefaultProps.pointBorderColor,\n    enableSlices = LineDefaultProps.enableSlicesTooltip,\n}) => {\n    const [componentId] = useState(uniqueId(LINE_UNIQUE_ID_PREFIX))\n    const formatX = useValueFormatter(xFormat)\n    const formatY = useValueFormatter(yFormat)\n    const getColor = useOrdinalColorScale(colors, 'id')\n    const theme = useTheme()\n    const getPointColor = useInheritedColor(pointColor, theme)\n    const getPointBorderColor = useInheritedColor(pointBorderColor, theme)\n    const [hiddenIds, setHiddenIds] = useState([])\n\n    const {\n        xScale,\n        yScale,\n        series: rawSeries,\n    } = useMemo(\n        () =>\n            computeXYScalesForSeries(\n                data.filter(item => hiddenIds.indexOf(item.id) === -1),\n                xScaleSpec,\n                yScaleSpec,\n                width,\n                height\n            ),\n        [data, hiddenIds, xScaleSpec, yScaleSpec, width, height]\n    )\n\n    const { legendData, series } = useMemo(() => {\n        const dataWithColor = data.map(line => ({\n            id: line.id,\n            label: line.id,\n            color: getColor(line),\n        }))\n        const series = dataWithColor\n            .map(datum => ({\n                ...rawSeries.find(serie => serie.id === datum.id),\n                color: datum.color,\n            }))\n            .filter(item => Boolean(item.id))\n        const legendData = dataWithColor\n            .map(item => ({ ...item, hidden: !series.find(serie => serie.id === item.id) }))\n            .reverse()\n\n        return { legendData, series }\n    }, [data, rawSeries, getColor])\n\n    const toggleSerie = useCallback(id => {\n        setHiddenIds(state =>\n            state.indexOf(id) > -1 ? state.filter(item => item !== id) : [...state, id]\n        )\n    }, [])\n\n    const points = usePoints({\n        series,\n        getPointColor,\n        getPointBorderColor,\n        formatX,\n        formatY,\n    })\n\n    const slices = useSlices({\n        componentId,\n        enableSlices,\n        points,\n        width,\n        height,\n    })\n\n    const lineGenerator = useLineGenerator({ curve })\n    const areaGenerator = useAreaGenerator({\n        curve,\n        yScale,\n        areaBaselineValue,\n    })\n\n    return {\n        legendData,\n        toggleSerie,\n        lineGenerator,\n        areaGenerator,\n        getColor,\n        series,\n        xScale,\n        yScale,\n        slices,\n        points,\n    }\n}\n","import { memo } from 'react'\nimport { useSpring, animated } from '@react-spring/web'\nimport { useAnimatedPath, useMotionConfig } from '@nivo/core'\n\nconst AreaPath = ({ areaBlendMode, areaOpacity, color, fill, path }) => {\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedPath = useAnimatedPath(path)\n    const animatedProps = useSpring({\n        color,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <animated.path\n            d={animatedPath}\n            fill={fill ? fill : animatedProps.color}\n            fillOpacity={areaOpacity}\n            strokeWidth={0}\n            style={{\n                mixBlendMode: areaBlendMode,\n            }}\n        />\n    )\n}\n\nconst Areas = ({ areaGenerator, areaOpacity, areaBlendMode, lines }) => {\n    const computedLines = lines.slice(0).reverse()\n\n    return (\n        <g>\n            {computedLines.map(line => (\n                <AreaPath\n                    key={line.id}\n                    path={areaGenerator(line.data.map(d => d.position))}\n                    {...{ areaOpacity, areaBlendMode, ...line }}\n                />\n            ))}\n        </g>\n    )\n}\n\nexport default memo(Areas)\n","import { memo, useMemo } from 'react'\nimport { animated } from '@react-spring/web'\nimport { useAnimatedPath } from '@nivo/core'\n\nconst LinesItem = ({ lineGenerator, points, color, thickness }) => {\n    const path = useMemo(() => lineGenerator(points), [lineGenerator, points])\n    const animatedPath = useAnimatedPath(path)\n\n    return <animated.path d={animatedPath} fill=\"none\" strokeWidth={thickness} stroke={color} />\n}\n\nexport default memo(LinesItem)\n","import { memo } from 'react'\nimport LinesItem from './LinesItem'\n\nconst Lines = ({ lines, lineGenerator, lineWidth }) => {\n    return lines\n        .slice(0)\n        .reverse()\n        .map(({ id, data, color }) => (\n            <LinesItem\n                key={id}\n                id={id}\n                points={data.map(d => d.position)}\n                lineGenerator={lineGenerator}\n                color={color}\n                thickness={lineWidth}\n            />\n        ))\n}\n\nexport default memo(Lines)\n","import { createElement, memo, useCallback } from 'react'\nimport { useTooltip } from '@nivo/tooltip'\n\nconst SlicesItem = ({\n    slice,\n    slices,\n    axis,\n    debug,\n    tooltip,\n    isCurrent,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n}) => {\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const handleMouseEnter = useCallback(\n        event => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n            setCurrent(slice)\n            onMouseEnter && onMouseEnter(slice, event)\n        },\n        [showTooltipFromEvent, tooltip, slice, axis, setCurrent, onMouseEnter]\n    )\n\n    const handleMouseMove = useCallback(\n        event => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n            onMouseMove && onMouseMove(slice, event)\n        },\n        [showTooltipFromEvent, tooltip, slice, axis, onMouseMove]\n    )\n\n    const handleMouseLeave = useCallback(\n        event => {\n            hideTooltip()\n            setCurrent(null)\n            onMouseLeave && onMouseLeave(slice, event)\n        },\n        [hideTooltip, setCurrent, onMouseLeave, slice]\n    )\n\n    const handleClick = useCallback(\n        event => {\n            onClick && onClick(slice, event)\n        },\n        [slice, onClick]\n    )\n\n    const handeOnTouchStart = useCallback(\n        event => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n            setCurrent(slice)\n            onTouchStart && onTouchStart(slice, event)\n        },\n        [axis, onTouchStart, setCurrent, showTooltipFromEvent, slice, tooltip]\n    )\n\n    const handeOnTouchMove = useCallback(\n        event => {\n            // This event will be locked to the element that was touched originally\n            // We find the element that is currently being \"hovered over\" by getting the element at the touch point\n            const touchPoint = event.touches[0]\n            const touchingElement = document.elementFromPoint(\n                touchPoint.clientX,\n                touchPoint.clientY\n            )\n            // Is this a nivo ref?\n            const touchingSliceId = touchingElement?.getAttribute('data-ref')\n            if (touchingSliceId) {\n                // Is this a slice for this graph?\n                const slice = slices.find(slice => slice.id === touchingSliceId)\n                if (slice) {\n                    showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n                    setCurrent(slice)\n                }\n            }\n\n            // Note here, this will pass the original slice, not the one we found\n            // But this can be found with document.elementFromPoint()\n            onTouchMove && onTouchMove(slice, event)\n        },\n        [axis, onTouchMove, setCurrent, showTooltipFromEvent, slice, slices, tooltip]\n    )\n\n    const handleOnTouchEnd = useCallback(\n        event => {\n            hideTooltip()\n            setCurrent(null)\n            onTouchEnd && onTouchEnd(slice, event)\n        },\n        [hideTooltip, setCurrent, onTouchEnd, slice]\n    )\n\n    return (\n        <rect\n            x={slice.x0}\n            y={slice.y0}\n            width={slice.width}\n            height={slice.height}\n            stroke=\"red\"\n            strokeWidth={debug ? 1 : 0}\n            strokeOpacity={0.75}\n            fill=\"red\"\n            fillOpacity={isCurrent && debug ? 0.35 : 0}\n            onMouseEnter={handleMouseEnter}\n            onMouseMove={handleMouseMove}\n            onMouseLeave={handleMouseLeave}\n            onClick={handleClick}\n            onTouchStart={handeOnTouchStart}\n            onTouchMove={handeOnTouchMove}\n            onTouchEnd={handleOnTouchEnd}\n            data-ref={slice.id}\n        />\n    )\n}\n\nexport default memo(SlicesItem)\n","import { memo } from 'react'\nimport SlicesItem from './SlicesItem'\n\nconst Slices = ({\n    slices,\n    axis,\n    debug,\n    height,\n    tooltip,\n    current,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n}) => {\n    return slices.map(slice => (\n        <SlicesItem\n            key={slice.id}\n            slice={slice}\n            slices={slices}\n            axis={axis}\n            debug={debug}\n            height={height}\n            tooltip={tooltip}\n            setCurrent={setCurrent}\n            isCurrent={current !== null && current.id === slice.id}\n            onMouseEnter={onMouseEnter}\n            onMouseMove={onMouseMove}\n            onMouseLeave={onMouseLeave}\n            onClick={onClick}\n            onTouchStart={onTouchStart}\n            onTouchMove={onTouchMove}\n            onTouchEnd={onTouchEnd}\n        />\n    ))\n}\n\nexport default memo(Slices)\n","import { memo } from 'react'\nimport { getLabelGenerator, DotsItem, useTheme } from '@nivo/core'\n\nconst Points = ({ points, symbol, size, borderWidth, enableLabel, label, labelYOffset }) => {\n    const theme = useTheme()\n    const getLabel = getLabelGenerator(label)\n\n    /**\n     * We reverse the `points` array so that points from the lower lines in stacked lines\n     * graph are drawn on top. See https://github.com/plouc/nivo/issues/1051.\n     */\n    const mappedPoints = points\n        .slice(0)\n        .reverse()\n        .map(point => {\n            const mappedPoint = {\n                id: point.id,\n                x: point.x,\n                y: point.y,\n                datum: point.data,\n                fill: point.color,\n                stroke: point.borderColor,\n                label: enableLabel ? getLabel(point) : null,\n            }\n\n            return mappedPoint\n        })\n\n    return (\n        <g>\n            {mappedPoints.map(point => (\n                <DotsItem\n                    key={point.id}\n                    x={point.x}\n                    y={point.y}\n                    datum={point.datum}\n                    symbol={symbol}\n                    size={size}\n                    color={point.fill}\n                    borderWidth={borderWidth}\n                    borderColor={point.stroke}\n                    label={point.label}\n                    labelYOffset={labelYOffset}\n                    theme={theme}\n                />\n            ))}\n        </g>\n    )\n}\n\nexport default memo(Points)\n","import { createElement, memo, useCallback } from 'react'\nimport { useTooltip } from '@nivo/tooltip'\nimport { Mesh as BaseMesh } from '@nivo/voronoi'\n\nconst Mesh = ({\n    points,\n    width,\n    height,\n    margin,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n    tooltip,\n    debug,\n    enableTouchCrosshair,\n}) => {\n    const { showTooltipAt, hideTooltip } = useTooltip()\n\n    const handleMouseEnter = useCallback(\n        (point, event) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onMouseEnter && onMouseEnter(point, event)\n        },\n        [showTooltipAt, tooltip, onMouseEnter, margin]\n    )\n\n    const handleMouseMove = useCallback(\n        (point, event) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onMouseMove && onMouseMove(point, event)\n        },\n        [showTooltipAt, tooltip, margin.left, margin.top, onMouseMove]\n    )\n\n    const handleMouseLeave = useCallback(\n        (point, event) => {\n            hideTooltip()\n            onMouseLeave && onMouseLeave(point, event)\n        },\n        [hideTooltip, onMouseLeave]\n    )\n\n    const handleClick = useCallback(\n        (point, event) => {\n            onClick && onClick(point, event)\n        },\n        [onClick]\n    )\n\n    const handleTouchStart = useCallback(\n        (point, event) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onTouchStart && onTouchStart(point, event)\n        },\n        [margin.left, margin.top, onTouchStart, showTooltipAt, tooltip]\n    )\n\n    const handleTouchMove = useCallback(\n        (point, event) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onTouchMove && onTouchMove(point, event)\n        },\n        [margin.left, margin.top, onTouchMove, showTooltipAt, tooltip]\n    )\n\n    const handleTouchEnd = useCallback(\n        (point, event) => {\n            hideTooltip()\n            onTouchEnd && onTouchEnd(point, event)\n        },\n        [onTouchEnd, hideTooltip]\n    )\n\n    return (\n        <BaseMesh\n            nodes={points}\n            width={width}\n            height={height}\n            setCurrent={setCurrent}\n            onMouseEnter={handleMouseEnter}\n            onMouseMove={handleMouseMove}\n            onMouseLeave={handleMouseLeave}\n            onClick={handleClick}\n            onTouchStart={handleTouchStart}\n            onTouchMove={handleTouchMove}\n            onTouchEnd={handleTouchEnd}\n            enableTouchCrosshair={enableTouchCrosshair}\n            debug={debug}\n        />\n    )\n}\n\nexport default memo(Mesh)\n","import { Fragment, useState } from 'react'\nimport {\n    bindDefs,\n    withContainer,\n    useDimensions,\n    useTheme,\n    SvgWrapper,\n    CartesianMarkers,\n} from '@nivo/core'\nimport { useInheritedColor } from '@nivo/colors'\nimport { Axes, Grid } from '@nivo/axes'\nimport { BoxLegendSvg } from '@nivo/legends'\nimport { Crosshair } from '@nivo/tooltip'\nimport { useLine } from './hooks'\nimport Areas from './Areas'\nimport Lines from './Lines'\nimport Slices from './Slices'\nimport Points from './Points'\nimport Mesh from './Mesh'\nimport PointTooltip from './PointTooltip'\nimport SliceTooltip from './SliceTooltip'\n\nconst Line = props => {\n    const {\n        data,\n        xScale: xScaleSpec = { type: 'point' },\n        xFormat,\n        yScale: yScaleSpec = {\n            type: 'linear',\n            min: 0,\n            max: 'auto',\n        },\n        yFormat,\n        layers = [\n            'grid',\n            'markers',\n            'axes',\n            'areas',\n            'crosshair',\n            'lines',\n            'points',\n            'slices',\n            'mesh',\n            'legends',\n        ],\n        curve = 'linear',\n        areaBaselineValue = 0,\n\n        colors = { scheme: 'nivo' },\n\n        margin: partialMargin,\n        width,\n        height,\n\n        axisTop,\n        axisRight,\n        axisBottom = {},\n        axisLeft = {},\n        enableGridX = true,\n        enableGridY = true,\n        gridXValues,\n        gridYValues,\n\n        lineWidth = 2,\n        enableArea = false,\n        areaOpacity = 0.2,\n        areaBlendMode = 'normal',\n\n        enablePoints = true,\n        pointSymbol,\n        pointSize = 6,\n        pointColor = { from: 'color' },\n        pointBorderWidth = 0,\n        pointBorderColor = { theme: 'background' },\n        enablePointLabel = false,\n        pointLabel = 'data.yFormatted',\n        pointLabelYOffset,\n\n        defs = [],\n        fill = [],\n\n        markers,\n\n        legends = [],\n\n        isInteractive = true,\n\n        useMesh = false,\n        debugMesh = false,\n\n        onMouseEnter,\n        onMouseMove,\n        onMouseLeave,\n        onClick,\n        onTouchStart,\n        onTouchMove,\n        onTouchEnd,\n\n        tooltip = PointTooltip,\n\n        enableSlices = false,\n        debugSlices = false,\n        sliceTooltip = SliceTooltip,\n\n        enableCrosshair = true,\n        crosshairType = 'bottom-left',\n        enableTouchCrosshair = false,\n\n        role = 'img',\n    } = props\n\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const {\n        legendData,\n        toggleSerie,\n        lineGenerator,\n        areaGenerator,\n        series,\n        xScale,\n        yScale,\n        slices,\n        points,\n    } = useLine({\n        data,\n        xScale: xScaleSpec,\n        xFormat,\n        yScale: yScaleSpec,\n        yFormat,\n        width: innerWidth,\n        height: innerHeight,\n        colors,\n        curve,\n        areaBaselineValue,\n        pointColor,\n        pointBorderColor,\n        enableSlices,\n    })\n\n    const theme = useTheme()\n    const getPointColor = useInheritedColor(pointColor, theme)\n    const getPointBorderColor = useInheritedColor(pointBorderColor, theme)\n\n    const [currentPoint, setCurrentPoint] = useState(null)\n    const [currentSlice, setCurrentSlice] = useState(null)\n\n    const layerById = {\n        grid: (\n            <Grid\n                key=\"grid\"\n                theme={theme}\n                width={innerWidth}\n                height={innerHeight}\n                xScale={enableGridX ? xScale : null}\n                yScale={enableGridY ? yScale : null}\n                xValues={gridXValues}\n                yValues={gridYValues}\n            />\n        ),\n        markers: (\n            <CartesianMarkers\n                key=\"markers\"\n                markers={markers}\n                width={innerWidth}\n                height={innerHeight}\n                xScale={xScale}\n                yScale={yScale}\n                theme={theme}\n            />\n        ),\n        axes: (\n            <Axes\n                key=\"axes\"\n                xScale={xScale}\n                yScale={yScale}\n                width={innerWidth}\n                height={innerHeight}\n                theme={theme}\n                top={axisTop}\n                right={axisRight}\n                bottom={axisBottom}\n                left={axisLeft}\n            />\n        ),\n        areas: null,\n        lines: (\n            <Lines key=\"lines\" lines={series} lineGenerator={lineGenerator} lineWidth={lineWidth} />\n        ),\n        slices: null,\n        points: null,\n        crosshair: null,\n        mesh: null,\n        legends: legends.map((legend, i) => (\n            <BoxLegendSvg\n                key={`legend.${i}`}\n                {...legend}\n                containerWidth={innerWidth}\n                containerHeight={innerHeight}\n                data={legend.data || legendData}\n                theme={theme}\n                toggleSerie={legend.toggleSerie ? toggleSerie : undefined}\n            />\n        )),\n    }\n\n    const boundDefs = bindDefs(defs, series, fill)\n\n    if (enableArea) {\n        layerById.areas = (\n            <Areas\n                key=\"areas\"\n                areaGenerator={areaGenerator}\n                areaOpacity={areaOpacity}\n                areaBlendMode={areaBlendMode}\n                lines={series}\n            />\n        )\n    }\n\n    if (isInteractive && enableSlices !== false) {\n        layerById.slices = (\n            <Slices\n                key=\"slices\"\n                slices={slices}\n                axis={enableSlices}\n                debug={debugSlices}\n                height={innerHeight}\n                tooltip={sliceTooltip}\n                current={currentSlice}\n                setCurrent={setCurrentSlice}\n                onMouseEnter={onMouseEnter}\n                onMouseMove={onMouseMove}\n                onMouseLeave={onMouseLeave}\n                onClick={onClick}\n                onTouchStart={onTouchStart}\n                onTouchMove={onTouchMove}\n                onTouchEnd={onTouchEnd}\n            />\n        )\n    }\n\n    if (enablePoints) {\n        layerById.points = (\n            <Points\n                key=\"points\"\n                points={points}\n                symbol={pointSymbol}\n                size={pointSize}\n                color={getPointColor}\n                borderWidth={pointBorderWidth}\n                borderColor={getPointBorderColor}\n                enableLabel={enablePointLabel}\n                label={pointLabel}\n                labelYOffset={pointLabelYOffset}\n            />\n        )\n    }\n\n    if (isInteractive && enableCrosshair) {\n        if (currentPoint !== null) {\n            layerById.crosshair = (\n                <Crosshair\n                    key=\"crosshair\"\n                    width={innerWidth}\n                    height={innerHeight}\n                    x={currentPoint.x}\n                    y={currentPoint.y}\n                    type={crosshairType}\n                />\n            )\n        }\n        if (currentSlice !== null) {\n            layerById.crosshair = (\n                <Crosshair\n                    key=\"crosshair\"\n                    width={innerWidth}\n                    height={innerHeight}\n                    x={currentSlice.x}\n                    y={currentSlice.y}\n                    type={enableSlices}\n                />\n            )\n        }\n    }\n\n    if (isInteractive && useMesh && enableSlices === false) {\n        layerById.mesh = (\n            <Mesh\n                key=\"mesh\"\n                points={points}\n                width={innerWidth}\n                height={innerHeight}\n                margin={margin}\n                current={currentPoint}\n                setCurrent={setCurrentPoint}\n                onMouseEnter={onMouseEnter}\n                onMouseMove={onMouseMove}\n                onMouseLeave={onMouseLeave}\n                onClick={onClick}\n                onTouchStart={onTouchStart}\n                onTouchMove={onTouchMove}\n                onTouchEnd={onTouchEnd}\n                tooltip={tooltip}\n                enableTouchCrosshair={enableTouchCrosshair}\n                debug={debugMesh}\n            />\n        )\n    }\n\n    return (\n        <SvgWrapper\n            defs={boundDefs}\n            width={outerWidth}\n            height={outerHeight}\n            margin={margin}\n            role={role}\n        >\n            {layers.map((layer, i) => {\n                if (typeof layer === 'function') {\n                    return (\n                        <Fragment key={i}>\n                            {layer({\n                                ...props,\n                                innerWidth,\n                                innerHeight,\n                                series,\n                                slices,\n                                points,\n                                xScale,\n                                yScale,\n                                lineGenerator,\n                                areaGenerator,\n                                currentPoint,\n                                setCurrentPoint,\n                                currentSlice,\n                                setCurrentSlice,\n                            })}\n                        </Fragment>\n                    )\n                }\n\n                return layerById[layer]\n            })}\n        </SvgWrapper>\n    )\n}\n\nexport default withContainer(Line)\n","import { ResponsiveWrapper } from '@nivo/core'\nimport Line from './Line'\n\nconst ResponsiveLine = props => (\n    <ResponsiveWrapper>\n        {({ width, height }) => <Line width={width} height={height} {...props} />}\n    </ResponsiveWrapper>\n)\n\nexport default ResponsiveLine\n","import { createElement, useRef, useEffect, useState, useCallback, forwardRef } from 'react'\nimport {\n    withContainer,\n    useDimensions,\n    useTheme,\n    getRelativeCursor,\n    isCursorInRect,\n} from '@nivo/core'\nimport { renderAxesToCanvas, renderGridLinesToCanvas } from '@nivo/axes'\nimport { renderLegendToCanvas } from '@nivo/legends'\nimport { useTooltip } from '@nivo/tooltip'\nimport { useVoronoiMesh, renderVoronoiToCanvas, renderVoronoiCellToCanvas } from '@nivo/voronoi'\nimport { useLine } from './hooks'\nimport PointTooltip from './PointTooltip'\n\nconst LineCanvas = props => {\n    const canvasEl = useRef(null)\n    const {\n        width,\n        height,\n        margin: partialMargin,\n        pixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1,\n\n        data,\n        xScale: xScaleSpec = { type: 'point' },\n        xFormat,\n        yScale: yScaleSpec = {\n            type: 'linear',\n            min: 0,\n            max: 'auto',\n        },\n        yFormat,\n        curve = 'linear',\n\n        layers = [\n            'grid',\n            'markers',\n            'axes',\n            'areas',\n            'crosshair',\n            'lines',\n            'points',\n            'slices',\n            'mesh',\n            'legends',\n        ],\n\n        colors = { scheme: 'nivo' },\n        lineWidth = 2,\n\n        enableArea = false,\n        areaBaselineValue = 0,\n        areaOpacity = 0.2,\n\n        enablePoints = true,\n        pointSize = 6,\n        pointColor = { from: 'color' },\n        pointBorderWidth = 0,\n        pointBorderColor = { theme: 'background' },\n\n        enableGridX = true,\n        gridXValues,\n        enableGridY = true,\n        gridYValues,\n        axisTop,\n        axisRight,\n        axisBottom = {},\n        axisLeft = {},\n\n        legends = [],\n\n        isInteractive = true,\n        debugMesh = false,\n        //onMouseEnter,\n        //onMouseMove,\n        onMouseLeave,\n        onClick,\n        tooltip = PointTooltip,\n        canvasRef,\n    } = props\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n    const theme = useTheme()\n    const [currentPoint, setCurrentPoint] = useState(null)\n\n    const { lineGenerator, areaGenerator, series, xScale, yScale, points } = useLine({\n        data,\n        xScale: xScaleSpec,\n        xFormat,\n        yScale: yScaleSpec,\n        yFormat,\n        width: innerWidth,\n        height: innerHeight,\n        colors,\n        curve,\n        areaBaselineValue,\n        pointColor,\n        pointBorderColor,\n    })\n\n    const { delaunay, voronoi } = useVoronoiMesh({\n        points,\n        width: innerWidth,\n        height: innerHeight,\n        debug: debugMesh,\n    })\n\n    useEffect(() => {\n        if (canvasRef) {\n            canvasRef.current = canvasEl.current\n        }\n\n        canvasEl.current.width = outerWidth * pixelRatio\n        canvasEl.current.height = outerHeight * pixelRatio\n\n        const ctx = canvasEl.current.getContext('2d')\n\n        ctx.scale(pixelRatio, pixelRatio)\n\n        ctx.fillStyle = theme.background\n        ctx.fillRect(0, 0, outerWidth, outerHeight)\n        ctx.translate(margin.left, margin.top)\n\n        layers.forEach(layer => {\n            if (typeof layer === 'function') {\n                layer({\n                    ctx,\n                    innerWidth,\n                    innerHeight,\n                    series,\n                    points,\n                    xScale,\n                    yScale,\n                    lineWidth,\n                    lineGenerator,\n                    areaGenerator,\n                    currentPoint,\n                    setCurrentPoint,\n                })\n            }\n\n            if (layer === 'grid' && theme.grid.line.strokeWidth > 0) {\n                ctx.lineWidth = theme.grid.line.strokeWidth\n                ctx.strokeStyle = theme.grid.line.stroke\n\n                enableGridX &&\n                    renderGridLinesToCanvas(ctx, {\n                        width: innerWidth,\n                        height: innerHeight,\n                        scale: xScale,\n                        axis: 'x',\n                        values: gridXValues,\n                    })\n\n                enableGridY &&\n                    renderGridLinesToCanvas(ctx, {\n                        width: innerWidth,\n                        height: innerHeight,\n                        scale: yScale,\n                        axis: 'y',\n                        values: gridYValues,\n                    })\n            }\n\n            if (layer === 'axes') {\n                renderAxesToCanvas(ctx, {\n                    xScale,\n                    yScale,\n                    width: innerWidth,\n                    height: innerHeight,\n                    top: axisTop,\n                    right: axisRight,\n                    bottom: axisBottom,\n                    left: axisLeft,\n                    theme,\n                })\n            }\n\n            if (layer === 'areas' && enableArea === true) {\n                ctx.save()\n                ctx.globalAlpha = areaOpacity\n\n                areaGenerator.context(ctx)\n                for (let i = series.length - 1; i >= 0; i--) {\n                    ctx.fillStyle = series[i].color\n                    ctx.beginPath()\n                    areaGenerator(series[i].data.map(d => d.position))\n                    ctx.fill()\n                }\n\n                ctx.restore()\n            }\n\n            if (layer === 'lines') {\n                lineGenerator.context(ctx)\n                series.forEach(serie => {\n                    ctx.strokeStyle = serie.color\n                    ctx.lineWidth = lineWidth\n                    ctx.beginPath()\n                    lineGenerator(serie.data.map(d => d.position))\n                    ctx.stroke()\n                })\n            }\n\n            if (layer === 'points' && enablePoints === true && pointSize > 0) {\n                points.forEach(point => {\n                    ctx.fillStyle = point.color\n                    ctx.beginPath()\n                    ctx.arc(point.x, point.y, pointSize / 2, 0, 2 * Math.PI)\n                    ctx.fill()\n\n                    if (pointBorderWidth > 0) {\n                        ctx.strokeStyle = point.borderColor\n                        ctx.lineWidth = pointBorderWidth\n                        ctx.stroke()\n                    }\n                })\n            }\n\n            if (layer === 'mesh' && debugMesh === true) {\n                renderVoronoiToCanvas(ctx, voronoi)\n                if (currentPoint) {\n                    renderVoronoiCellToCanvas(ctx, voronoi, currentPoint.index)\n                }\n            }\n\n            if (layer === 'legends') {\n                const legendData = series\n                    .map(serie => ({\n                        id: serie.id,\n                        label: serie.id,\n                        color: serie.color,\n                    }))\n                    .reverse()\n\n                legends.forEach(legend => {\n                    renderLegendToCanvas(ctx, {\n                        ...legend,\n                        data: legend.data || legendData,\n                        containerWidth: innerWidth,\n                        containerHeight: innerHeight,\n                        theme,\n                    })\n                })\n            }\n        })\n    }, [\n        canvasEl,\n        outerWidth,\n        outerHeight,\n        layers,\n        theme,\n        lineGenerator,\n        series,\n        xScale,\n        yScale,\n        enableGridX,\n        gridXValues,\n        enableGridY,\n        gridYValues,\n        axisTop,\n        axisRight,\n        axisBottom,\n        axisLeft,\n        legends,\n        points,\n        enablePoints,\n        pointSize,\n        currentPoint,\n    ])\n\n    const getPointFromMouseEvent = useCallback(\n        event => {\n            const [x, y] = getRelativeCursor(canvasEl.current, event)\n            if (!isCursorInRect(margin.left, margin.top, innerWidth, innerHeight, x, y)) return null\n\n            const pointIndex = delaunay.find(x - margin.left, y - margin.top)\n            return points[pointIndex]\n        },\n        [canvasEl, margin, innerWidth, innerHeight, delaunay]\n    )\n\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const handleMouseHover = useCallback(\n        event => {\n            const point = getPointFromMouseEvent(event)\n            setCurrentPoint(point)\n\n            if (point) {\n                showTooltipFromEvent(createElement(tooltip, { point }), event)\n            } else {\n                hideTooltip()\n            }\n        },\n        [getPointFromMouseEvent, setCurrentPoint, showTooltipFromEvent, hideTooltip, tooltip]\n    )\n\n    const handleMouseLeave = useCallback(\n        event => {\n            hideTooltip()\n            setCurrentPoint(null)\n            currentPoint && onMouseLeave && onMouseLeave(currentPoint, event)\n        },\n        [hideTooltip, setCurrentPoint, onMouseLeave]\n    )\n\n    const handleClick = useCallback(\n        event => {\n            if (onClick) {\n                const point = getPointFromMouseEvent(event)\n                point && onClick(point, event)\n            }\n        },\n        [getPointFromMouseEvent, onClick]\n    )\n\n    return (\n        <canvas\n            ref={canvasEl}\n            width={outerWidth * pixelRatio}\n            height={outerHeight * pixelRatio}\n            style={{\n                width: outerWidth,\n                height: outerHeight,\n                cursor: isInteractive ? 'auto' : 'normal',\n            }}\n            onMouseEnter={isInteractive ? handleMouseHover : undefined}\n            onMouseMove={isInteractive ? handleMouseHover : undefined}\n            onMouseLeave={isInteractive ? handleMouseLeave : undefined}\n            onClick={isInteractive ? handleClick : undefined}\n        />\n    )\n}\n\nconst LineCanvasWithContainer = withContainer(LineCanvas)\n\nexport default forwardRef((props, ref) => <LineCanvasWithContainer {...props} canvasRef={ref} />)\n","import { forwardRef } from 'react'\nimport { ResponsiveWrapper } from '@nivo/core'\nimport LineCanvas from './LineCanvas'\n\nconst ResponsiveLineCanvas = (props, ref) => (\n    <ResponsiveWrapper>\n        {({ width, height }) => <LineCanvas width={width} height={height} {...props} ref={ref} />}\n    </ResponsiveWrapper>\n)\n\nexport default forwardRef(ResponsiveLineCanvas)\n"],"names":["memo","_ref","point","_jsx","BasicTooltip","id","_jsxs","children","data","xFormatted","yFormatted","enableChip","color","serieColor","slice","axis","theme","useTheme","otherAxis","TableTooltip","rows","points","map","Chip","style","tooltip","chip","serieId","tableCellValue","commonDefaultProps","curve","xScale","type","yScale","min","max","layers","axisBottom","axisLeft","enableGridX","enableGridY","enablePoints","pointSize","pointColor","from","pointBorderWidth","pointBorderColor","enablePointLabel","pointLabel","colors","scheme","enableArea","areaBaselineValue","areaOpacity","areaBlendMode","lineWidth","legends","isInteractive","PointTooltip","enableSlices","debugSlices","sliceTooltip","SliceTooltip","debugMesh","enableCrosshair","crosshairType","LineDefaultProps","_extends","useMesh","enableTouchCrosshair","animate","motionConfig","defs","fill","role","LineCanvasDefaultProps","pixelRatio","window","devicePixelRatio","useLineGenerator","useMemo","line","defined","d","x","y","curveFromProp","useAreaGenerator","_ref2","area","y1","y0","useSlices","_ref4","componentId","width","height","Map","forEach","has","get","push","set","Array","entries","sort","a","b","_ref5","i","slices","x0","sliceWidth","slicePoints","prevSlice","nextSlice","reverse","_ref6","sliceHeight","LINE_UNIQUE_ID_PREFIX","useLine","_ref7","_ref7$xScale","xScaleSpec","xFormat","_ref7$yScale","yScaleSpec","yFormat","_ref7$colors","_ref7$curve","_ref7$areaBaselineVal","_ref7$pointColor","_ref7$pointBorderColo","_ref7$enableSlices","enableSlicesTooltip","useState","uniqueId","formatX","useValueFormatter","formatY","getColor","useOrdinalColorScale","getPointColor","useInheritedColor","getPointBorderColor","_useState2","hiddenIds","setHiddenIds","_useMemo","computeXYScalesForSeries","filter","item","indexOf","rawSeries","series","_useMemo2","dataWithColor","label","datum","find","serie","Boolean","legendData","hidden","toggleSerie","useCallback","state","concat","_ref3","reduce","acc","position","index","length","borderColor","usePoints","lineGenerator","areaGenerator","AreaPath","path","_useMotionConfig","useMotionConfig","springConfig","config","animatedPath","useAnimatedPath","animatedProps","useSpring","immediate","animated","fillOpacity","strokeWidth","mixBlendMode","computedLines","lines","thickness","stroke","LinesItem","debug","isCurrent","setCurrent","onMouseEnter","onMouseMove","onMouseLeave","onClick","onTouchStart","onTouchMove","onTouchEnd","_useTooltip","useTooltip","showTooltipFromEvent","hideTooltip","handleMouseEnter","event","createElement","handleMouseMove","handleMouseLeave","handleClick","handeOnTouchStart","handeOnTouchMove","touchPoint","touches","touchingElement","document","elementFromPoint","clientX","clientY","touchingSliceId","getAttribute","handleOnTouchEnd","strokeOpacity","current","SlicesItem","symbol","size","borderWidth","enableLabel","labelYOffset","getLabel","getLabelGenerator","mappedPoints","DotsItem","margin","showTooltipAt","left","top","handleTouchStart","handleTouchMove","handleTouchEnd","BaseMesh","nodes","withContainer","props","_props$xScale","_props$yScale","_props$layers","_props$curve","_props$areaBaselineVa","_props$colors","partialMargin","axisTop","axisRight","_props$axisBottom","_props$axisLeft","_props$enableGridX","_props$enableGridY","gridXValues","gridYValues","_props$lineWidth","_props$enableArea","_props$areaOpacity","_props$areaBlendMode","_props$enablePoints","pointSymbol","_props$pointSize","_props$pointColor","_props$pointBorderWid","_props$pointBorderCol","_props$enablePointLab","_props$pointLabel","pointLabelYOffset","_props$defs","_props$fill","markers","_props$legends","_props$isInteractive","_props$useMesh","_props$debugMesh","_props$tooltip","_props$enableSlices","_props$debugSlices","_props$sliceTooltip","_props$enableCrosshai","_props$crosshairType","_props$enableTouchCro","_props$role","_useDimensions","useDimensions","innerWidth","innerHeight","outerWidth","outerHeight","_useLine","_useState","currentPoint","setCurrentPoint","currentSlice","setCurrentSlice","layerById","grid","Grid","xValues","yValues","CartesianMarkers","axes","Axes","right","bottom","areas","Lines","crosshair","mesh","legend","BoxLegendSvg","containerWidth","containerHeight","undefined","boundDefs","bindDefs","Areas","Slices","Points","Crosshair","Mesh","SvgWrapper","layer","Fragment","ResponsiveLine","ResponsiveWrapper","Line","LineCanvasWithContainer","canvasEl","useRef","_props$pixelRatio","canvasRef","_useVoronoiMesh","useVoronoiMesh","delaunay","voronoi","useEffect","ctx","getContext","scale","fillStyle","background","fillRect","translate","strokeStyle","renderGridLinesToCanvas","values","renderAxesToCanvas","save","globalAlpha","context","beginPath","restore","arc","Math","PI","renderVoronoiToCanvas","renderVoronoiCellToCanvas","renderLegendToCanvas","getPointFromMouseEvent","_getRelativeCursor","getRelativeCursor","isCursorInRect","pointIndex","handleMouseHover","ref","cursor","LineCanvas$1","forwardRef","LineCanvas"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"nivo-line.es.js","sources":["../src/PointTooltip.js","../src/SliceTooltip.js","../src/props.js","../src/hooks.js","../src/Areas.js","../src/LinesItem.js","../src/Lines.js","../src/SlicesItem.js","../src/Slices.js","../src/Points.js","../src/Mesh.js","../src/Line.js","../src/ResponsiveLine.js","../src/LineCanvas.js","../src/ResponsiveLineCanvas.js"],"sourcesContent":["import { memo } from 'react'\nimport { BasicTooltip } from '@nivo/tooltip'\n\nconst LinePointTooltip = ({ point }) => {\n    return (\n        <BasicTooltip\n            id={\n                <span>\n                    x: <strong>{point.data.xFormatted}</strong>, y:{' '}\n                    <strong>{point.data.yFormatted}</strong>\n                </span>\n            }\n            enableChip={true}\n            color={point.serieColor}\n        />\n    )\n}\n\nexport default memo(LinePointTooltip)\n","import { memo } from 'react'\nimport { useTheme } from '@nivo/core'\nimport { Chip, TableTooltip } from '@nivo/tooltip'\n\nconst SliceTooltip = ({ slice, axis }) => {\n    const theme = useTheme()\n    const otherAxis = axis === 'x' ? 'y' : 'x'\n\n    return (\n        <TableTooltip\n            rows={slice.points.map(point => [\n                <Chip key=\"chip\" color={point.serieColor} style={theme.tooltip.chip} />,\n                point.serieId,\n                <span key=\"value\" style={theme.tooltip.tableCellValue}>\n                    {point.data[`${otherAxis}Formatted`]}\n                </span>,\n            ])}\n        />\n    )\n}\n\nexport default memo(SliceTooltip)\n","import PointTooltip from './PointTooltip'\nimport SliceTooltip from './SliceTooltip'\n\nconst commonDefaultProps = {\n    curve: 'linear',\n\n    xScale: {\n        type: 'point',\n    },\n    yScale: {\n        type: 'linear',\n        min: 0,\n        max: 'auto',\n    },\n\n    layers: [\n        'grid',\n        'markers',\n        'axes',\n        'areas',\n        'crosshair',\n        'lines',\n        'points',\n        'slices',\n        'mesh',\n        'legends',\n    ],\n    axisBottom: {},\n    axisLeft: {},\n    enableGridX: true,\n    enableGridY: true,\n\n    enablePoints: true,\n    pointSize: 6,\n    pointColor: { from: 'color' },\n    pointBorderWidth: 0,\n    pointBorderColor: { theme: 'background' },\n    enablePointLabel: false,\n    pointLabel: 'yFormatted',\n\n    colors: { scheme: 'nivo' },\n    enableArea: false,\n    areaBaselineValue: 0,\n    areaOpacity: 0.2,\n    areaBlendMode: 'normal',\n    lineWidth: 2,\n\n    legends: [],\n\n    isInteractive: true,\n    tooltip: PointTooltip,\n    enableSlices: false,\n    debugSlices: false,\n    sliceTooltip: SliceTooltip,\n    debugMesh: false,\n    enableCrosshair: true,\n    crosshairType: 'bottom-left',\n}\n\nexport const LineDefaultProps = {\n    ...commonDefaultProps,\n    enablePointLabel: false,\n    useMesh: false,\n    enableTouchCrosshair: false,\n    animate: true,\n    motionConfig: 'gentle',\n    defs: [],\n    fill: [],\n    role: 'img',\n    initialHiddenIds: [],\n}\n\nexport const LineCanvasDefaultProps = {\n    ...commonDefaultProps,\n    pixelRatio: typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1,\n}\n","import { useCallback, useMemo, useState } from 'react'\nimport { area, line } from 'd3-shape'\nimport { curveFromProp, useTheme, useValueFormatter } from '@nivo/core'\nimport { useOrdinalColorScale, useInheritedColor } from '@nivo/colors'\nimport { computeXYScalesForSeries } from '@nivo/scales'\nimport uniqueId from 'lodash/uniqueId'\nimport { LineDefaultProps } from './props'\n\nexport const useLineGenerator = ({ curve }) => {\n    return useMemo(\n        () =>\n            line()\n                .defined(d => d.x !== null && d.y !== null)\n                .x(d => d.x)\n                .y(d => d.y)\n                .curve(curveFromProp(curve)),\n        [curve]\n    )\n}\n\nexport const useAreaGenerator = ({ curve, yScale, areaBaselineValue }) => {\n    return useMemo(() => {\n        return area()\n            .defined(d => d.x !== null && d.y !== null)\n            .x(d => d.x)\n            .y1(d => d.y)\n            .curve(curveFromProp(curve))\n            .y0(yScale(areaBaselineValue))\n    }, [curve, yScale, areaBaselineValue])\n}\n\nconst usePoints = ({ series, getPointColor, getPointBorderColor, formatX, formatY }) => {\n    return useMemo(() => {\n        return series.reduce((acc, serie) => {\n            return [\n                ...acc,\n                ...serie.data\n                    .filter(datum => datum.position.x !== null && datum.position.y !== null)\n                    .map((datum, i) => {\n                        const point = {\n                            id: `${serie.id}.${i}`,\n                            index: acc.length + i,\n                            serieId: serie.id,\n                            serieColor: serie.color,\n                            x: datum.position.x,\n                            y: datum.position.y,\n                        }\n                        point.color = getPointColor(serie)\n                        point.borderColor = getPointBorderColor(point)\n                        point.data = {\n                            ...datum.data,\n                            xFormatted: formatX(datum.data.x),\n                            yFormatted: formatY(datum.data.y),\n                        }\n\n                        return point\n                    }),\n            ]\n        }, [])\n    }, [series, getPointColor, getPointBorderColor, formatX, formatY])\n}\n\nexport const useSlices = ({ componentId, enableSlices, points, width, height }) => {\n    return useMemo(() => {\n        if (enableSlices === false) return []\n\n        if (enableSlices === 'x') {\n            const map = new Map()\n            points.forEach(point => {\n                if (point.data.x === null || point.data.y === null) return\n                if (!map.has(point.x)) map.set(point.x, [point])\n                else map.get(point.x).push(point)\n            })\n            return Array.from(map.entries())\n                .sort((a, b) => a[0] - b[0])\n                .map(([x, slicePoints], i, slices) => {\n                    const prevSlice = slices[i - 1]\n                    const nextSlice = slices[i + 1]\n\n                    let x0\n                    if (!prevSlice) x0 = x\n                    else x0 = x - (x - prevSlice[0]) / 2\n\n                    let sliceWidth\n                    if (!nextSlice) sliceWidth = width - x0\n                    else sliceWidth = x - x0 + (nextSlice[0] - x) / 2\n\n                    return {\n                        id: `slice:${componentId}:${x}`,\n                        x0,\n                        x,\n                        y0: 0,\n                        y: 0,\n                        width: sliceWidth,\n                        height,\n                        points: slicePoints.reverse(),\n                    }\n                })\n        } else if (enableSlices === 'y') {\n            const map = new Map()\n            points.forEach(point => {\n                if (point.data.x === null || point.data.y === null) return\n                if (!map.has(point.y)) map.set(point.y, [point])\n                else map.get(point.y).push(point)\n            })\n            return Array.from(map.entries())\n                .sort((a, b) => a[0] - b[0])\n                .map(([y, slicePoints], i, slices) => {\n                    const prevSlice = slices[i - 1]\n                    const nextSlice = slices[i + 1]\n\n                    let y0\n                    if (!prevSlice) y0 = y\n                    else y0 = y - (y - prevSlice[0]) / 2\n\n                    let sliceHeight\n                    if (!nextSlice) sliceHeight = height - y0\n                    else sliceHeight = y - y0 + (nextSlice[0] - y) / 2\n\n                    return {\n                        id: y,\n                        x0: 0,\n                        x: 0,\n                        y0,\n                        y,\n                        width,\n                        height: sliceHeight,\n                        points: slicePoints.reverse(),\n                    }\n                })\n        }\n    }, [componentId, enableSlices, height, points, width])\n}\n\nexport const LINE_UNIQUE_ID_PREFIX = 'line'\n\nexport const useLine = ({\n    data,\n    xScale: xScaleSpec = LineDefaultProps.xScale,\n    xFormat,\n    yScale: yScaleSpec = LineDefaultProps.yScale,\n    yFormat,\n    width,\n    height,\n    colors = LineDefaultProps.colors,\n    curve = LineDefaultProps.curve,\n    areaBaselineValue = LineDefaultProps.areaBaselineValue,\n    pointColor = LineDefaultProps.pointColor,\n    pointBorderColor = LineDefaultProps.pointBorderColor,\n    enableSlices = LineDefaultProps.enableSlicesTooltip,\n    initialHiddenIds = LineDefaultProps.initialHiddenIds,\n}) => {\n    const [componentId] = useState(uniqueId(LINE_UNIQUE_ID_PREFIX))\n    const formatX = useValueFormatter(xFormat)\n    const formatY = useValueFormatter(yFormat)\n    const getColor = useOrdinalColorScale(colors, 'id')\n    const theme = useTheme()\n    const getPointColor = useInheritedColor(pointColor, theme)\n    const getPointBorderColor = useInheritedColor(pointBorderColor, theme)\n    const [hiddenIds, setHiddenIds] = useState(initialHiddenIds ?? [])\n\n    const {\n        xScale,\n        yScale,\n        series: rawSeries,\n    } = useMemo(\n        () =>\n            computeXYScalesForSeries(\n                data.filter(item => hiddenIds.indexOf(item.id) === -1),\n                xScaleSpec,\n                yScaleSpec,\n                width,\n                height\n            ),\n        [data, hiddenIds, xScaleSpec, yScaleSpec, width, height]\n    )\n\n    const { legendData, series } = useMemo(() => {\n        const dataWithColor = data.map(line => ({\n            id: line.id,\n            label: line.id,\n            color: getColor(line),\n        }))\n        const series = dataWithColor\n            .map(datum => ({\n                ...rawSeries.find(serie => serie.id === datum.id),\n                color: datum.color,\n            }))\n            .filter(item => Boolean(item.id))\n        const legendData = dataWithColor\n            .map(item => ({ ...item, hidden: !series.find(serie => serie.id === item.id) }))\n            .reverse()\n\n        return { legendData, series }\n    }, [data, rawSeries, getColor])\n\n    const toggleSerie = useCallback(id => {\n        setHiddenIds(state =>\n            state.indexOf(id) > -1 ? state.filter(item => item !== id) : [...state, id]\n        )\n    }, [])\n\n    const points = usePoints({\n        series,\n        getPointColor,\n        getPointBorderColor,\n        formatX,\n        formatY,\n    })\n\n    const slices = useSlices({\n        componentId,\n        enableSlices,\n        points,\n        width,\n        height,\n    })\n\n    const lineGenerator = useLineGenerator({ curve })\n    const areaGenerator = useAreaGenerator({\n        curve,\n        yScale,\n        areaBaselineValue,\n    })\n\n    return {\n        legendData,\n        toggleSerie,\n        lineGenerator,\n        areaGenerator,\n        getColor,\n        series,\n        xScale,\n        yScale,\n        slices,\n        points,\n    }\n}\n","import { memo } from 'react'\nimport { useSpring, animated } from '@react-spring/web'\nimport { useAnimatedPath, useMotionConfig } from '@nivo/core'\n\nconst AreaPath = ({ areaBlendMode, areaOpacity, color, fill, path }) => {\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedPath = useAnimatedPath(path)\n    const animatedProps = useSpring({\n        color,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <animated.path\n            d={animatedPath}\n            fill={fill ? fill : animatedProps.color}\n            fillOpacity={areaOpacity}\n            strokeWidth={0}\n            style={{\n                mixBlendMode: areaBlendMode,\n            }}\n        />\n    )\n}\n\nconst Areas = ({ areaGenerator, areaOpacity, areaBlendMode, lines }) => {\n    const computedLines = lines.slice(0).reverse()\n\n    return (\n        <g>\n            {computedLines.map(line => (\n                <AreaPath\n                    key={line.id}\n                    path={areaGenerator(line.data.map(d => d.position))}\n                    {...{ areaOpacity, areaBlendMode, ...line }}\n                />\n            ))}\n        </g>\n    )\n}\n\nexport default memo(Areas)\n","import { memo, useMemo } from 'react'\nimport { animated } from '@react-spring/web'\nimport { useAnimatedPath } from '@nivo/core'\n\nconst LinesItem = ({ lineGenerator, points, color, thickness }) => {\n    const path = useMemo(() => lineGenerator(points), [lineGenerator, points])\n    const animatedPath = useAnimatedPath(path)\n\n    return <animated.path d={animatedPath} fill=\"none\" strokeWidth={thickness} stroke={color} />\n}\n\nexport default memo(LinesItem)\n","import { memo } from 'react'\nimport LinesItem from './LinesItem'\n\nconst Lines = ({ lines, lineGenerator, lineWidth }) => {\n    return lines\n        .slice(0)\n        .reverse()\n        .map(({ id, data, color }) => (\n            <LinesItem\n                key={id}\n                id={id}\n                points={data.map(d => d.position)}\n                lineGenerator={lineGenerator}\n                color={color}\n                thickness={lineWidth}\n            />\n        ))\n}\n\nexport default memo(Lines)\n","import { createElement, memo, useCallback } from 'react'\nimport { useTooltip } from '@nivo/tooltip'\n\nconst SlicesItem = ({\n    slice,\n    slices,\n    axis,\n    debug,\n    tooltip,\n    isCurrent,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n}) => {\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const handleMouseEnter = useCallback(\n        event => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n            setCurrent(slice)\n            onMouseEnter && onMouseEnter(slice, event)\n        },\n        [showTooltipFromEvent, tooltip, slice, axis, setCurrent, onMouseEnter]\n    )\n\n    const handleMouseMove = useCallback(\n        event => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n            onMouseMove && onMouseMove(slice, event)\n        },\n        [showTooltipFromEvent, tooltip, slice, axis, onMouseMove]\n    )\n\n    const handleMouseLeave = useCallback(\n        event => {\n            hideTooltip()\n            setCurrent(null)\n            onMouseLeave && onMouseLeave(slice, event)\n        },\n        [hideTooltip, setCurrent, onMouseLeave, slice]\n    )\n\n    const handleClick = useCallback(\n        event => {\n            onClick && onClick(slice, event)\n        },\n        [slice, onClick]\n    )\n\n    const handeOnTouchStart = useCallback(\n        event => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n            setCurrent(slice)\n            onTouchStart && onTouchStart(slice, event)\n        },\n        [axis, onTouchStart, setCurrent, showTooltipFromEvent, slice, tooltip]\n    )\n\n    const handeOnTouchMove = useCallback(\n        event => {\n            // This event will be locked to the element that was touched originally\n            // We find the element that is currently being \"hovered over\" by getting the element at the touch point\n            const touchPoint = event.touches[0]\n            const touchingElement = document.elementFromPoint(\n                touchPoint.clientX,\n                touchPoint.clientY\n            )\n            // Is this a nivo ref?\n            const touchingSliceId = touchingElement?.getAttribute('data-ref')\n            if (touchingSliceId) {\n                // Is this a slice for this graph?\n                const slice = slices.find(slice => slice.id === touchingSliceId)\n                if (slice) {\n                    showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n                    setCurrent(slice)\n                }\n            }\n\n            // Note here, this will pass the original slice, not the one we found\n            // But this can be found with document.elementFromPoint()\n            onTouchMove && onTouchMove(slice, event)\n        },\n        [axis, onTouchMove, setCurrent, showTooltipFromEvent, slice, slices, tooltip]\n    )\n\n    const handleOnTouchEnd = useCallback(\n        event => {\n            hideTooltip()\n            setCurrent(null)\n            onTouchEnd && onTouchEnd(slice, event)\n        },\n        [hideTooltip, setCurrent, onTouchEnd, slice]\n    )\n\n    return (\n        <rect\n            x={slice.x0}\n            y={slice.y0}\n            width={slice.width}\n            height={slice.height}\n            stroke=\"red\"\n            strokeWidth={debug ? 1 : 0}\n            strokeOpacity={0.75}\n            fill=\"red\"\n            fillOpacity={isCurrent && debug ? 0.35 : 0}\n            onMouseEnter={handleMouseEnter}\n            onMouseMove={handleMouseMove}\n            onMouseLeave={handleMouseLeave}\n            onClick={handleClick}\n            onTouchStart={handeOnTouchStart}\n            onTouchMove={handeOnTouchMove}\n            onTouchEnd={handleOnTouchEnd}\n            data-ref={slice.id}\n        />\n    )\n}\n\nexport default memo(SlicesItem)\n","import { memo } from 'react'\nimport SlicesItem from './SlicesItem'\n\nconst Slices = ({\n    slices,\n    axis,\n    debug,\n    height,\n    tooltip,\n    current,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n}) => {\n    return slices.map(slice => (\n        <SlicesItem\n            key={slice.id}\n            slice={slice}\n            slices={slices}\n            axis={axis}\n            debug={debug}\n            height={height}\n            tooltip={tooltip}\n            setCurrent={setCurrent}\n            isCurrent={current !== null && current.id === slice.id}\n            onMouseEnter={onMouseEnter}\n            onMouseMove={onMouseMove}\n            onMouseLeave={onMouseLeave}\n            onClick={onClick}\n            onTouchStart={onTouchStart}\n            onTouchMove={onTouchMove}\n            onTouchEnd={onTouchEnd}\n        />\n    ))\n}\n\nexport default memo(Slices)\n","import { memo } from 'react'\nimport { getLabelGenerator, DotsItem, useTheme } from '@nivo/core'\n\nconst Points = ({ points, symbol, size, borderWidth, enableLabel, label, labelYOffset }) => {\n    const theme = useTheme()\n    const getLabel = getLabelGenerator(label)\n\n    /**\n     * We reverse the `points` array so that points from the lower lines in stacked lines\n     * graph are drawn on top. See https://github.com/plouc/nivo/issues/1051.\n     */\n    const mappedPoints = points\n        .slice(0)\n        .reverse()\n        .map(point => {\n            const mappedPoint = {\n                id: point.id,\n                x: point.x,\n                y: point.y,\n                datum: point.data,\n                fill: point.color,\n                stroke: point.borderColor,\n                label: enableLabel ? getLabel(point) : null,\n            }\n\n            return mappedPoint\n        })\n\n    return (\n        <g>\n            {mappedPoints.map(point => (\n                <DotsItem\n                    key={point.id}\n                    x={point.x}\n                    y={point.y}\n                    datum={point.datum}\n                    symbol={symbol}\n                    size={size}\n                    color={point.fill}\n                    borderWidth={borderWidth}\n                    borderColor={point.stroke}\n                    label={point.label}\n                    labelYOffset={labelYOffset}\n                    theme={theme}\n                />\n            ))}\n        </g>\n    )\n}\n\nexport default memo(Points)\n","import { createElement, memo, useCallback } from 'react'\nimport { useTooltip } from '@nivo/tooltip'\nimport { Mesh as BaseMesh } from '@nivo/voronoi'\n\nconst Mesh = ({\n    points,\n    width,\n    height,\n    margin,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n    tooltip,\n    debug,\n    enableTouchCrosshair,\n}) => {\n    const { showTooltipAt, hideTooltip } = useTooltip()\n\n    const handleMouseEnter = useCallback(\n        (point, event) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onMouseEnter && onMouseEnter(point, event)\n        },\n        [showTooltipAt, tooltip, onMouseEnter, margin]\n    )\n\n    const handleMouseMove = useCallback(\n        (point, event) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onMouseMove && onMouseMove(point, event)\n        },\n        [showTooltipAt, tooltip, margin.left, margin.top, onMouseMove]\n    )\n\n    const handleMouseLeave = useCallback(\n        (point, event) => {\n            hideTooltip()\n            onMouseLeave && onMouseLeave(point, event)\n        },\n        [hideTooltip, onMouseLeave]\n    )\n\n    const handleClick = useCallback(\n        (point, event) => {\n            onClick && onClick(point, event)\n        },\n        [onClick]\n    )\n\n    const handleTouchStart = useCallback(\n        (point, event) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onTouchStart && onTouchStart(point, event)\n        },\n        [margin.left, margin.top, onTouchStart, showTooltipAt, tooltip]\n    )\n\n    const handleTouchMove = useCallback(\n        (point, event) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onTouchMove && onTouchMove(point, event)\n        },\n        [margin.left, margin.top, onTouchMove, showTooltipAt, tooltip]\n    )\n\n    const handleTouchEnd = useCallback(\n        (point, event) => {\n            hideTooltip()\n            onTouchEnd && onTouchEnd(point, event)\n        },\n        [onTouchEnd, hideTooltip]\n    )\n\n    return (\n        <BaseMesh\n            nodes={points}\n            width={width}\n            height={height}\n            setCurrent={setCurrent}\n            onMouseEnter={handleMouseEnter}\n            onMouseMove={handleMouseMove}\n            onMouseLeave={handleMouseLeave}\n            onClick={handleClick}\n            onTouchStart={handleTouchStart}\n            onTouchMove={handleTouchMove}\n            onTouchEnd={handleTouchEnd}\n            enableTouchCrosshair={enableTouchCrosshair}\n            debug={debug}\n        />\n    )\n}\n\nexport default memo(Mesh)\n","import { Fragment, useState } from 'react'\nimport {\n    bindDefs,\n    withContainer,\n    useDimensions,\n    useTheme,\n    SvgWrapper,\n    CartesianMarkers,\n} from '@nivo/core'\nimport { useInheritedColor } from '@nivo/colors'\nimport { Axes, Grid } from '@nivo/axes'\nimport { BoxLegendSvg } from '@nivo/legends'\nimport { Crosshair } from '@nivo/tooltip'\nimport { useLine } from './hooks'\nimport Areas from './Areas'\nimport Lines from './Lines'\nimport Slices from './Slices'\nimport Points from './Points'\nimport Mesh from './Mesh'\nimport PointTooltip from './PointTooltip'\nimport SliceTooltip from './SliceTooltip'\n\nconst Line = props => {\n    const {\n        data,\n        xScale: xScaleSpec = { type: 'point' },\n        xFormat,\n        yScale: yScaleSpec = {\n            type: 'linear',\n            min: 0,\n            max: 'auto',\n        },\n        yFormat,\n        layers = [\n            'grid',\n            'markers',\n            'axes',\n            'areas',\n            'crosshair',\n            'lines',\n            'points',\n            'slices',\n            'mesh',\n            'legends',\n        ],\n        curve = 'linear',\n        areaBaselineValue = 0,\n\n        colors = { scheme: 'nivo' },\n\n        margin: partialMargin,\n        width,\n        height,\n\n        axisTop,\n        axisRight,\n        axisBottom = {},\n        axisLeft = {},\n        enableGridX = true,\n        enableGridY = true,\n        gridXValues,\n        gridYValues,\n\n        lineWidth = 2,\n        enableArea = false,\n        areaOpacity = 0.2,\n        areaBlendMode = 'normal',\n\n        enablePoints = true,\n        pointSymbol,\n        pointSize = 6,\n        pointColor = { from: 'color' },\n        pointBorderWidth = 0,\n        pointBorderColor = { theme: 'background' },\n        enablePointLabel = false,\n        pointLabel = 'data.yFormatted',\n        pointLabelYOffset,\n\n        defs = [],\n        fill = [],\n\n        markers,\n\n        legends = [],\n\n        isInteractive = true,\n\n        useMesh = false,\n        debugMesh = false,\n\n        onMouseEnter,\n        onMouseMove,\n        onMouseLeave,\n        onClick,\n        onTouchStart,\n        onTouchMove,\n        onTouchEnd,\n\n        tooltip = PointTooltip,\n\n        enableSlices = false,\n        debugSlices = false,\n        sliceTooltip = SliceTooltip,\n\n        enableCrosshair = true,\n        crosshairType = 'bottom-left',\n        enableTouchCrosshair = false,\n\n        role = 'img',\n        initialHiddenIds = [],\n    } = props\n\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const {\n        legendData,\n        toggleSerie,\n        lineGenerator,\n        areaGenerator,\n        series,\n        xScale,\n        yScale,\n        slices,\n        points,\n    } = useLine({\n        data,\n        xScale: xScaleSpec,\n        xFormat,\n        yScale: yScaleSpec,\n        yFormat,\n        width: innerWidth,\n        height: innerHeight,\n        colors,\n        curve,\n        areaBaselineValue,\n        pointColor,\n        pointBorderColor,\n        enableSlices,\n        initialHiddenIds,\n    })\n\n    const theme = useTheme()\n    const getPointColor = useInheritedColor(pointColor, theme)\n    const getPointBorderColor = useInheritedColor(pointBorderColor, theme)\n\n    const [currentPoint, setCurrentPoint] = useState(null)\n    const [currentSlice, setCurrentSlice] = useState(null)\n\n    const layerById = {\n        grid: (\n            <Grid\n                key=\"grid\"\n                theme={theme}\n                width={innerWidth}\n                height={innerHeight}\n                xScale={enableGridX ? xScale : null}\n                yScale={enableGridY ? yScale : null}\n                xValues={gridXValues}\n                yValues={gridYValues}\n            />\n        ),\n        markers: (\n            <CartesianMarkers\n                key=\"markers\"\n                markers={markers}\n                width={innerWidth}\n                height={innerHeight}\n                xScale={xScale}\n                yScale={yScale}\n                theme={theme}\n            />\n        ),\n        axes: (\n            <Axes\n                key=\"axes\"\n                xScale={xScale}\n                yScale={yScale}\n                width={innerWidth}\n                height={innerHeight}\n                theme={theme}\n                top={axisTop}\n                right={axisRight}\n                bottom={axisBottom}\n                left={axisLeft}\n            />\n        ),\n        areas: null,\n        lines: (\n            <Lines key=\"lines\" lines={series} lineGenerator={lineGenerator} lineWidth={lineWidth} />\n        ),\n        slices: null,\n        points: null,\n        crosshair: null,\n        mesh: null,\n        legends: legends.map((legend, i) => (\n            <BoxLegendSvg\n                key={`legend.${i}`}\n                {...legend}\n                containerWidth={innerWidth}\n                containerHeight={innerHeight}\n                data={legend.data || legendData}\n                theme={theme}\n                toggleSerie={legend.toggleSerie ? toggleSerie : undefined}\n            />\n        )),\n    }\n\n    const boundDefs = bindDefs(defs, series, fill)\n\n    if (enableArea) {\n        layerById.areas = (\n            <Areas\n                key=\"areas\"\n                areaGenerator={areaGenerator}\n                areaOpacity={areaOpacity}\n                areaBlendMode={areaBlendMode}\n                lines={series}\n            />\n        )\n    }\n\n    if (isInteractive && enableSlices !== false) {\n        layerById.slices = (\n            <Slices\n                key=\"slices\"\n                slices={slices}\n                axis={enableSlices}\n                debug={debugSlices}\n                height={innerHeight}\n                tooltip={sliceTooltip}\n                current={currentSlice}\n                setCurrent={setCurrentSlice}\n                onMouseEnter={onMouseEnter}\n                onMouseMove={onMouseMove}\n                onMouseLeave={onMouseLeave}\n                onClick={onClick}\n                onTouchStart={onTouchStart}\n                onTouchMove={onTouchMove}\n                onTouchEnd={onTouchEnd}\n            />\n        )\n    }\n\n    if (enablePoints) {\n        layerById.points = (\n            <Points\n                key=\"points\"\n                points={points}\n                symbol={pointSymbol}\n                size={pointSize}\n                color={getPointColor}\n                borderWidth={pointBorderWidth}\n                borderColor={getPointBorderColor}\n                enableLabel={enablePointLabel}\n                label={pointLabel}\n                labelYOffset={pointLabelYOffset}\n            />\n        )\n    }\n\n    if (isInteractive && enableCrosshair) {\n        if (currentPoint !== null) {\n            layerById.crosshair = (\n                <Crosshair\n                    key=\"crosshair\"\n                    width={innerWidth}\n                    height={innerHeight}\n                    x={currentPoint.x}\n                    y={currentPoint.y}\n                    type={crosshairType}\n                />\n            )\n        }\n        if (currentSlice !== null) {\n            layerById.crosshair = (\n                <Crosshair\n                    key=\"crosshair\"\n                    width={innerWidth}\n                    height={innerHeight}\n                    x={currentSlice.x}\n                    y={currentSlice.y}\n                    type={enableSlices}\n                />\n            )\n        }\n    }\n\n    if (isInteractive && useMesh && enableSlices === false) {\n        layerById.mesh = (\n            <Mesh\n                key=\"mesh\"\n                points={points}\n                width={innerWidth}\n                height={innerHeight}\n                margin={margin}\n                current={currentPoint}\n                setCurrent={setCurrentPoint}\n                onMouseEnter={onMouseEnter}\n                onMouseMove={onMouseMove}\n                onMouseLeave={onMouseLeave}\n                onClick={onClick}\n                onTouchStart={onTouchStart}\n                onTouchMove={onTouchMove}\n                onTouchEnd={onTouchEnd}\n                tooltip={tooltip}\n                enableTouchCrosshair={enableTouchCrosshair}\n                debug={debugMesh}\n            />\n        )\n    }\n\n    return (\n        <SvgWrapper\n            defs={boundDefs}\n            width={outerWidth}\n            height={outerHeight}\n            margin={margin}\n            role={role}\n        >\n            {layers.map((layer, i) => {\n                if (typeof layer === 'function') {\n                    return (\n                        <Fragment key={i}>\n                            {layer({\n                                ...props,\n                                innerWidth,\n                                innerHeight,\n                                series,\n                                slices,\n                                points,\n                                xScale,\n                                yScale,\n                                lineGenerator,\n                                areaGenerator,\n                                currentPoint,\n                                setCurrentPoint,\n                                currentSlice,\n                                setCurrentSlice,\n                            })}\n                        </Fragment>\n                    )\n                }\n\n                return layerById[layer]\n            })}\n        </SvgWrapper>\n    )\n}\n\nexport default withContainer(Line)\n","import { ResponsiveWrapper } from '@nivo/core'\nimport Line from './Line'\n\nconst ResponsiveLine = props => (\n    <ResponsiveWrapper>\n        {({ width, height }) => <Line width={width} height={height} {...props} />}\n    </ResponsiveWrapper>\n)\n\nexport default ResponsiveLine\n","import { createElement, useRef, useEffect, useState, useCallback, forwardRef } from 'react'\nimport {\n    withContainer,\n    useDimensions,\n    useTheme,\n    getRelativeCursor,\n    isCursorInRect,\n} from '@nivo/core'\nimport { renderAxesToCanvas, renderGridLinesToCanvas } from '@nivo/axes'\nimport { renderLegendToCanvas } from '@nivo/legends'\nimport { useTooltip } from '@nivo/tooltip'\nimport { useVoronoiMesh, renderVoronoiToCanvas, renderVoronoiCellToCanvas } from '@nivo/voronoi'\nimport { useLine } from './hooks'\nimport PointTooltip from './PointTooltip'\n\nconst LineCanvas = props => {\n    const canvasEl = useRef(null)\n    const {\n        width,\n        height,\n        margin: partialMargin,\n        pixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1,\n\n        data,\n        xScale: xScaleSpec = { type: 'point' },\n        xFormat,\n        yScale: yScaleSpec = {\n            type: 'linear',\n            min: 0,\n            max: 'auto',\n        },\n        yFormat,\n        curve = 'linear',\n\n        layers = [\n            'grid',\n            'markers',\n            'axes',\n            'areas',\n            'crosshair',\n            'lines',\n            'points',\n            'slices',\n            'mesh',\n            'legends',\n        ],\n\n        colors = { scheme: 'nivo' },\n        lineWidth = 2,\n\n        enableArea = false,\n        areaBaselineValue = 0,\n        areaOpacity = 0.2,\n\n        enablePoints = true,\n        pointSize = 6,\n        pointColor = { from: 'color' },\n        pointBorderWidth = 0,\n        pointBorderColor = { theme: 'background' },\n\n        enableGridX = true,\n        gridXValues,\n        enableGridY = true,\n        gridYValues,\n        axisTop,\n        axisRight,\n        axisBottom = {},\n        axisLeft = {},\n\n        legends = [],\n\n        isInteractive = true,\n        debugMesh = false,\n        //onMouseEnter,\n        //onMouseMove,\n        onMouseLeave,\n        onClick,\n        tooltip = PointTooltip,\n        canvasRef,\n    } = props\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n    const theme = useTheme()\n    const [currentPoint, setCurrentPoint] = useState(null)\n\n    const { lineGenerator, areaGenerator, series, xScale, yScale, points } = useLine({\n        data,\n        xScale: xScaleSpec,\n        xFormat,\n        yScale: yScaleSpec,\n        yFormat,\n        width: innerWidth,\n        height: innerHeight,\n        colors,\n        curve,\n        areaBaselineValue,\n        pointColor,\n        pointBorderColor,\n    })\n\n    const { delaunay, voronoi } = useVoronoiMesh({\n        points,\n        width: innerWidth,\n        height: innerHeight,\n        debug: debugMesh,\n    })\n\n    useEffect(() => {\n        if (canvasRef) {\n            canvasRef.current = canvasEl.current\n        }\n\n        canvasEl.current.width = outerWidth * pixelRatio\n        canvasEl.current.height = outerHeight * pixelRatio\n\n        const ctx = canvasEl.current.getContext('2d')\n\n        ctx.scale(pixelRatio, pixelRatio)\n\n        ctx.fillStyle = theme.background\n        ctx.fillRect(0, 0, outerWidth, outerHeight)\n        ctx.translate(margin.left, margin.top)\n\n        layers.forEach(layer => {\n            if (typeof layer === 'function') {\n                layer({\n                    ctx,\n                    innerWidth,\n                    innerHeight,\n                    series,\n                    points,\n                    xScale,\n                    yScale,\n                    lineWidth,\n                    lineGenerator,\n                    areaGenerator,\n                    currentPoint,\n                    setCurrentPoint,\n                })\n            }\n\n            if (layer === 'grid' && theme.grid.line.strokeWidth > 0) {\n                ctx.lineWidth = theme.grid.line.strokeWidth\n                ctx.strokeStyle = theme.grid.line.stroke\n\n                enableGridX &&\n                    renderGridLinesToCanvas(ctx, {\n                        width: innerWidth,\n                        height: innerHeight,\n                        scale: xScale,\n                        axis: 'x',\n                        values: gridXValues,\n                    })\n\n                enableGridY &&\n                    renderGridLinesToCanvas(ctx, {\n                        width: innerWidth,\n                        height: innerHeight,\n                        scale: yScale,\n                        axis: 'y',\n                        values: gridYValues,\n                    })\n            }\n\n            if (layer === 'axes') {\n                renderAxesToCanvas(ctx, {\n                    xScale,\n                    yScale,\n                    width: innerWidth,\n                    height: innerHeight,\n                    top: axisTop,\n                    right: axisRight,\n                    bottom: axisBottom,\n                    left: axisLeft,\n                    theme,\n                })\n            }\n\n            if (layer === 'areas' && enableArea === true) {\n                ctx.save()\n                ctx.globalAlpha = areaOpacity\n\n                areaGenerator.context(ctx)\n                for (let i = series.length - 1; i >= 0; i--) {\n                    ctx.fillStyle = series[i].color\n                    ctx.beginPath()\n                    areaGenerator(series[i].data.map(d => d.position))\n                    ctx.fill()\n                }\n\n                ctx.restore()\n            }\n\n            if (layer === 'lines') {\n                lineGenerator.context(ctx)\n                series.forEach(serie => {\n                    ctx.strokeStyle = serie.color\n                    ctx.lineWidth = lineWidth\n                    ctx.beginPath()\n                    lineGenerator(serie.data.map(d => d.position))\n                    ctx.stroke()\n                })\n            }\n\n            if (layer === 'points' && enablePoints === true && pointSize > 0) {\n                points.forEach(point => {\n                    ctx.fillStyle = point.color\n                    ctx.beginPath()\n                    ctx.arc(point.x, point.y, pointSize / 2, 0, 2 * Math.PI)\n                    ctx.fill()\n\n                    if (pointBorderWidth > 0) {\n                        ctx.strokeStyle = point.borderColor\n                        ctx.lineWidth = pointBorderWidth\n                        ctx.stroke()\n                    }\n                })\n            }\n\n            if (layer === 'mesh' && debugMesh === true) {\n                renderVoronoiToCanvas(ctx, voronoi)\n                if (currentPoint) {\n                    renderVoronoiCellToCanvas(ctx, voronoi, currentPoint.index)\n                }\n            }\n\n            if (layer === 'legends') {\n                const legendData = series\n                    .map(serie => ({\n                        id: serie.id,\n                        label: serie.id,\n                        color: serie.color,\n                    }))\n                    .reverse()\n\n                legends.forEach(legend => {\n                    renderLegendToCanvas(ctx, {\n                        ...legend,\n                        data: legend.data || legendData,\n                        containerWidth: innerWidth,\n                        containerHeight: innerHeight,\n                        theme,\n                    })\n                })\n            }\n        })\n    }, [\n        canvasEl,\n        outerWidth,\n        outerHeight,\n        layers,\n        theme,\n        lineGenerator,\n        series,\n        xScale,\n        yScale,\n        enableGridX,\n        gridXValues,\n        enableGridY,\n        gridYValues,\n        axisTop,\n        axisRight,\n        axisBottom,\n        axisLeft,\n        legends,\n        points,\n        enablePoints,\n        pointSize,\n        currentPoint,\n    ])\n\n    const getPointFromMouseEvent = useCallback(\n        event => {\n            const [x, y] = getRelativeCursor(canvasEl.current, event)\n            if (!isCursorInRect(margin.left, margin.top, innerWidth, innerHeight, x, y)) return null\n\n            const pointIndex = delaunay.find(x - margin.left, y - margin.top)\n            return points[pointIndex]\n        },\n        [canvasEl, margin, innerWidth, innerHeight, delaunay]\n    )\n\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const handleMouseHover = useCallback(\n        event => {\n            const point = getPointFromMouseEvent(event)\n            setCurrentPoint(point)\n\n            if (point) {\n                showTooltipFromEvent(createElement(tooltip, { point }), event)\n            } else {\n                hideTooltip()\n            }\n        },\n        [getPointFromMouseEvent, setCurrentPoint, showTooltipFromEvent, hideTooltip, tooltip]\n    )\n\n    const handleMouseLeave = useCallback(\n        event => {\n            hideTooltip()\n            setCurrentPoint(null)\n            currentPoint && onMouseLeave && onMouseLeave(currentPoint, event)\n        },\n        [hideTooltip, setCurrentPoint, onMouseLeave]\n    )\n\n    const handleClick = useCallback(\n        event => {\n            if (onClick) {\n                const point = getPointFromMouseEvent(event)\n                point && onClick(point, event)\n            }\n        },\n        [getPointFromMouseEvent, onClick]\n    )\n\n    return (\n        <canvas\n            ref={canvasEl}\n            width={outerWidth * pixelRatio}\n            height={outerHeight * pixelRatio}\n            style={{\n                width: outerWidth,\n                height: outerHeight,\n                cursor: isInteractive ? 'auto' : 'normal',\n            }}\n            onMouseEnter={isInteractive ? handleMouseHover : undefined}\n            onMouseMove={isInteractive ? handleMouseHover : undefined}\n            onMouseLeave={isInteractive ? handleMouseLeave : undefined}\n            onClick={isInteractive ? handleClick : undefined}\n        />\n    )\n}\n\nconst LineCanvasWithContainer = withContainer(LineCanvas)\n\nexport default forwardRef((props, ref) => <LineCanvasWithContainer {...props} canvasRef={ref} />)\n","import { forwardRef } from 'react'\nimport { ResponsiveWrapper } from '@nivo/core'\nimport LineCanvas from './LineCanvas'\n\nconst ResponsiveLineCanvas = (props, ref) => (\n    <ResponsiveWrapper>\n        {({ width, height }) => <LineCanvas width={width} height={height} {...props} ref={ref} />}\n    </ResponsiveWrapper>\n)\n\nexport default forwardRef(ResponsiveLineCanvas)\n"],"names":["memo","_ref","point","_jsx","BasicTooltip","id","_jsxs","children","data","xFormatted","yFormatted","enableChip","color","serieColor","slice","axis","theme","useTheme","otherAxis","TableTooltip","rows","points","map","Chip","style","tooltip","chip","serieId","tableCellValue","commonDefaultProps","curve","xScale","type","yScale","min","max","layers","axisBottom","axisLeft","enableGridX","enableGridY","enablePoints","pointSize","pointColor","from","pointBorderWidth","pointBorderColor","enablePointLabel","pointLabel","colors","scheme","enableArea","areaBaselineValue","areaOpacity","areaBlendMode","lineWidth","legends","isInteractive","PointTooltip","enableSlices","debugSlices","sliceTooltip","SliceTooltip","debugMesh","enableCrosshair","crosshairType","LineDefaultProps","_extends","useMesh","enableTouchCrosshair","animate","motionConfig","defs","fill","role","initialHiddenIds","LineCanvasDefaultProps","pixelRatio","window","devicePixelRatio","useLineGenerator","useMemo","line","defined","d","x","y","curveFromProp","useAreaGenerator","_ref2","area","y1","y0","useSlices","_ref4","componentId","width","height","Map","forEach","has","get","push","set","Array","entries","sort","a","b","_ref5","i","slices","x0","sliceWidth","slicePoints","prevSlice","nextSlice","reverse","_ref6","sliceHeight","LINE_UNIQUE_ID_PREFIX","useLine","_ref7","_ref7$xScale","xScaleSpec","xFormat","_ref7$yScale","yScaleSpec","yFormat","_ref7$colors","_ref7$curve","_ref7$areaBaselineVal","_ref7$pointColor","_ref7$pointBorderColo","_ref7$enableSlices","enableSlicesTooltip","_ref7$initialHiddenId","useState","uniqueId","formatX","useValueFormatter","formatY","getColor","useOrdinalColorScale","getPointColor","useInheritedColor","getPointBorderColor","_useState2","hiddenIds","setHiddenIds","_useMemo","computeXYScalesForSeries","filter","item","indexOf","rawSeries","series","_useMemo2","dataWithColor","label","datum","find","serie","Boolean","legendData","hidden","toggleSerie","useCallback","state","concat","_ref3","reduce","acc","position","index","length","borderColor","usePoints","lineGenerator","areaGenerator","AreaPath","path","_useMotionConfig","useMotionConfig","springConfig","config","animatedPath","useAnimatedPath","animatedProps","useSpring","immediate","animated","fillOpacity","strokeWidth","mixBlendMode","computedLines","lines","thickness","stroke","LinesItem","debug","isCurrent","setCurrent","onMouseEnter","onMouseMove","onMouseLeave","onClick","onTouchStart","onTouchMove","onTouchEnd","_useTooltip","useTooltip","showTooltipFromEvent","hideTooltip","handleMouseEnter","event","createElement","handleMouseMove","handleMouseLeave","handleClick","handeOnTouchStart","handeOnTouchMove","touchPoint","touches","touchingElement","document","elementFromPoint","clientX","clientY","touchingSliceId","getAttribute","handleOnTouchEnd","strokeOpacity","current","SlicesItem","symbol","size","borderWidth","enableLabel","labelYOffset","getLabel","getLabelGenerator","mappedPoints","DotsItem","margin","showTooltipAt","left","top","handleTouchStart","handleTouchMove","handleTouchEnd","BaseMesh","nodes","withContainer","props","_props$xScale","_props$yScale","_props$layers","_props$curve","_props$areaBaselineVa","_props$colors","partialMargin","axisTop","axisRight","_props$axisBottom","_props$axisLeft","_props$enableGridX","_props$enableGridY","gridXValues","gridYValues","_props$lineWidth","_props$enableArea","_props$areaOpacity","_props$areaBlendMode","_props$enablePoints","pointSymbol","_props$pointSize","_props$pointColor","_props$pointBorderWid","_props$pointBorderCol","_props$enablePointLab","_props$pointLabel","pointLabelYOffset","_props$defs","_props$fill","markers","_props$legends","_props$isInteractive","_props$useMesh","_props$debugMesh","_props$tooltip","_props$enableSlices","_props$debugSlices","_props$sliceTooltip","_props$enableCrosshai","_props$crosshairType","_props$enableTouchCro","_props$role","_props$initialHiddenI","_useDimensions","useDimensions","innerWidth","innerHeight","outerWidth","outerHeight","_useLine","_useState","currentPoint","setCurrentPoint","currentSlice","setCurrentSlice","layerById","grid","Grid","xValues","yValues","CartesianMarkers","axes","Axes","right","bottom","areas","Lines","crosshair","mesh","legend","BoxLegendSvg","containerWidth","containerHeight","undefined","boundDefs","bindDefs","Areas","Slices","Points","Crosshair","Mesh","SvgWrapper","layer","Fragment","ResponsiveLine","ResponsiveWrapper","Line","LineCanvasWithContainer","canvasEl","useRef","_props$pixelRatio","canvasRef","_useVoronoiMesh","useVoronoiMesh","delaunay","voronoi","useEffect","ctx","getContext","scale","fillStyle","background","fillRect","translate","strokeStyle","renderGridLinesToCanvas","values","renderAxesToCanvas","save","globalAlpha","context","beginPath","restore","arc","Math","PI","renderVoronoiToCanvas","renderVoronoiCellToCanvas","renderLegendToCanvas","getPointFromMouseEvent","_getRelativeCursor","getRelativeCursor","isCursorInRect","pointIndex","handleMouseHover","ref","cursor","LineCanvas$1","forwardRef","LineCanvas"],"mappings":"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"}
\ No newline at end of file
