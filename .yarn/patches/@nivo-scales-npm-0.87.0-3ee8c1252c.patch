diff --git a/dist/nivo-scales.cjs.js b/dist/nivo-scales.cjs.js
index 4f79d24777942d674735eb4d8f1b5259b7f03acb..ee48ca6be70e691237ae388659481c3a301b3042 100644
--- a/dist/nivo-scales.cjs.js
+++ b/dist/nivo-scales.cjs.js
@@ -1,2 +1,2 @@
-"use strict";var e=require("lodash/uniq"),t=require("lodash/uniqBy"),n=require("lodash/sortBy"),r=require("lodash/last"),a=require("lodash/isDate"),i=require("d3-time-format"),o=require("d3-scale"),u=require("d3-time");function c(){return c=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},c.apply(this,arguments)}var s=[function(e){return e.setMilliseconds(0)},function(e){return e.setSeconds(0)},function(e){return e.setMinutes(0)},function(e){return e.setHours(0)},function(e){return e.setDate(1)},function(e){return e.setMonth(0)}],d={millisecond:[],second:s.slice(0,1),minute:s.slice(0,2),hour:s.slice(0,3),day:s.slice(0,4),month:s.slice(0,5),year:s.slice(0,6)},l=function(e){return function(t){return d[e].forEach((function(e){e(t)})),t}},f=function(e){var t=e.format,n=void 0===t?"native":t,r=e.precision,a=void 0===r?"millisecond":r,o=e.useUTC,u=void 0===o||o,c=l(a);return function(e){if(void 0===e)return e;if("native"===n||e instanceof Date)return c(e);var t=u?i.utcParse(n):i.timeParse(n);return c(t(e))}},m=function(e,t,n,r){var a,i,u,c,s=e.min,d=void 0===s?0:s,l=e.max,f=void 0===l?"auto":l,m=e.stacked,p=void 0!==m&&m,y=e.reverse,x=void 0!==y&&y,h=e.clamp,g=void 0!==h&&h,S=e.nice,k=void 0!==S&&S;"auto"===d?a=!0===p?null!=(i=t.minStacked)?i:0:t.min:a=d;"auto"===f?u=!0===p?null!=(c=t.maxStacked)?c:0:t.max:u=f;var T=o.scaleLinear().rangeRound("x"===r?[0,n]:[n,0]).domain(x?[u,a]:[a,u]).clamp(g);return!0===k?T.nice():"number"==typeof k&&T.nice(k),v(T,p)},v=function(e,t){void 0===t&&(t=!1);var n=e;return n.type="linear",n.stacked=t,n},p=function(e,t,n){var r=o.scalePoint().range([0,n]).domain(t.all);return r.type="point",r},y=function(e,t,n,r){var a=e.round,i=void 0===a||a,u=o.scaleBand().range("x"===r?[0,n]:[n,0]).domain(t.all).round(i);return x(u)},x=function(e){var t=e;return t.type="band",t},h=function(e,t,n){var r,a,i=e.format,u=void 0===i?"native":i,c=e.precision,s=void 0===c?"millisecond":c,d=e.min,l=void 0===d?"auto":d,m=e.max,v=void 0===m?"auto":m,p=e.useUTC,y=void 0===p||p,x=e.nice,h=void 0!==x&&x,g=f({format:u,precision:s,useUTC:y});r="auto"===l?g(t.min):"native"!==u?g(l):l,a="auto"===v?g(t.max):"native"!==u?g(v):v;var S=y?o.scaleUtc():o.scaleTime();S.range([0,n]),r&&a&&S.domain([r,a]),!0===h?S.nice():"object"!=typeof h&&"number"!=typeof h||S.nice(h);var k=S;return k.type="time",k.useUTC=y,k},g=function(e,t,n,r){var a,i=e.base,u=void 0===i?10:i,c=e.min,s=void 0===c?"auto":c,d=e.max,l=void 0===d?"auto":d;if(t.all.some((function(e){return 0===e})))throw new Error("a log scale domain must not include or cross zero");var f,m,v=!1;if(t.all.filter((function(e){return null!=e})).forEach((function(e){v||(void 0===a?a=Math.sign(e):Math.sign(e)!==a&&(v=!0))})),v)throw new Error("a log scale domain must be strictly-positive or strictly-negative");f="auto"===s?t.min:s,m="auto"===l?t.max:l;var p=o.scaleLog().domain([f,m]).rangeRound("x"===r?[0,n]:[n,0]).base(u).nice();return p.type="log",p},S=function(e,t,n,r){var a,i,u=e.constant,c=void 0===u?1:u,s=e.min,d=void 0===s?"auto":s,l=e.max,f=void 0===l?"auto":l,m=e.reverse,v=void 0!==m&&m;a="auto"===d?t.min:d,i="auto"===f?t.max:f;var p=o.scaleSymlog().constant(c).rangeRound("x"===r?[0,n]:[n,0]).nice();!0===v?p.domain([i,a]):p.domain([a,i]);var y=p;return y.type="symlog",y},k=function(e){return"x"===e?"y":"x"},T=function(e,t){return e===t},M=function(e,t){return e.getTime()===t.getTime()};function b(e,t,n,r){switch(e.type){case"linear":return m(e,t,n,r);case"point":return p(e,t,n);case"band":return y(e,t,n,r);case"time":return h(e,t,n);case"log":return g(e,t,n,r);case"symlog":return S(e,t,n,r);default:throw new Error("invalid scale spec")}}var w=function(e,t,n){var r;if("stacked"in n&&n.stacked){var a=e.data["x"===t?"xStacked":"yStacked"];return null==a?null:n(a)}return null!=(r=n(e.data[t]))?r:null},E=function(e,t,n){return{x:D(e,"x",t),y:D(e,"y",n)}},D=function(a,i,o,u){var c=void 0===u?{}:u,s=c.getValue,d=void 0===s?function(e){return e.data[i]}:s,l=c.setValue,m=void 0===l?function(e,t){e.data[i]=t}:l;if("linear"===o.type)a.forEach((function(e){e.data.forEach((function(e){var t=d(e);t&&m(e,parseFloat(String(t)))}))}));else if("time"===o.type&&"native"!==o.format){var v=f(o);a.forEach((function(e){e.data.forEach((function(e){var t=d(e);t&&m(e,v(t))}))}))}var p=[];switch(a.forEach((function(e){e.data.forEach((function(e){p.push(d(e))}))})),o.type){case"linear":var y=n(e(p).filter((function(e){return null!==e})),(function(e){return e}));return{all:y,min:Math.min.apply(Math,y),max:Math.max.apply(Math,y)};case"time":var x=t(p,(function(e){return e.getTime()})).slice(0).sort((function(e,t){return t.getTime()-e.getTime()})).reverse();return{all:x,min:x[0],max:r(x)};default:var h=e(p);return{all:h,min:h[0],max:r(h)}}},C=function(e,t,n){var i=k(e),o=[];t[i].all.forEach((function(t){var u=a(t)?M:T,c=[];n.forEach((function(n){var a=n.data.find((function(e){return u(e.data[i],t)})),s=null,d=null;if(void 0!==a){if(null!==(s=a.data[e])){var l=r(c);void 0===l?d=s:null!==l&&(d=l+s)}a.data["x"===e?"xStacked":"yStacked"]=d}c.push(d),null!==d&&o.push(d)}))})),t[e].minStacked=Math.min.apply(Math,o),t[e].maxStacked=Math.max.apply(Math,o)},q=function(e,t){return C("x",e,t)},U=function(e,t){return C("y",e,t)},O=u.timeInterval((function(e){return e.setHours(0,0,0,0)}),(function(e,t){return e.setDate(e.getDate()+t)}),(function(e,t){return(t.getTime()-e.getTime())/864e5}),(function(e){return Math.floor(e.getTime()/864e5)})),P=u.timeInterval((function(e){return e.setUTCHours(0,0,0,0)}),(function(e,t){return e.setUTCDate(e.getUTCDate()+t)}),(function(e,t){return(t.getTime()-e.getTime())/864e5}),(function(e){return Math.floor(e.getTime()/864e5)})),j={millisecond:[u.timeMillisecond,u.utcMillisecond],second:[u.timeSecond,u.utcSecond],minute:[u.timeMinute,u.utcMinute],hour:[u.timeHour,u.utcHour],day:[O,P],week:[u.timeWeek,u.utcWeek],sunday:[u.timeSunday,u.utcSunday],monday:[u.timeMonday,u.utcMonday],tuesday:[u.timeTuesday,u.utcTuesday],wednesday:[u.timeWednesday,u.utcWednesday],thursday:[u.timeThursday,u.utcThursday],friday:[u.timeFriday,u.utcFriday],saturday:[u.timeSaturday,u.utcSaturday],month:[u.timeMonth,u.utcMonth],year:[u.timeYear,u.utcYear]},B=Object.keys(j),A=new RegExp("^every\\s*(\\d+)?\\s*("+B.join("|")+")s?$","i");exports.castBandScale=x,exports.castLinearScale=v,exports.castPointScale=function(e){var t=e;return t.type="point",t},exports.centerScale=function(e){var t=e.bandwidth();if(0===t)return e;var n=t/2;return e.round()&&(n=Math.round(n)),function(t){var r;return(null!=(r=e(t))?r:0)+n}},exports.compareDateValues=M,exports.compareValues=T,exports.computeScale=b,exports.computeXYScalesForSeries=function(e,t,n,r,a){var i=e.map((function(e){return function(e){return c({},e,{data:e.data.map((function(e){return{data:c({},e)}}))})}(e)})),o=E(i,t,n);"stacked"in t&&!0===t.stacked&&q(o,i),"stacked"in n&&!0===n.stacked&&U(o,i);var u=b(t,o.x,r,"x"),s=b(n,o.y,a,"y"),d=i.map((function(e){return c({},e,{data:e.data.map((function(e){return c({},e,{position:{x:w(e,"x",u),y:w(e,"y",s)}})}))})}));return c({},o,{series:d,xScale:u,yScale:s})},exports.createBandScale=y,exports.createDateNormalizer=f,exports.createLinearScale=m,exports.createLogScale=g,exports.createPointScale=p,exports.createPrecisionMethod=l,exports.createSymlogScale=S,exports.createTimeScale=h,exports.generateSeriesAxis=D,exports.generateSeriesXY=E,exports.getOtherAxis=k,exports.getScaleTicks=function(e,t){if(Array.isArray(t))return t;if("string"==typeof t&&"useUTC"in e){var n=t.match(A);if(n){var r=n[1],a=n[2],i=j[a][e.useUTC?1:0];if("day"===a){var o,u,c=e.domain(),s=c[0],d=c[1],l=new Date(d);return l.setDate(l.getDate()+1),null!=(o=null==(u=i.every(Number(null!=r?r:1)))?void 0:u.range(s,l))?o:[]}if(void 0===r)return e.ticks(i);var f=i.every(Number(r));if(f)return e.ticks(f)}throw new Error("Invalid tickValues: "+t)}if("ticks"in e){if(void 0===t)return e.ticks();if("number"==typeof(m=t)&&isFinite(m)&&Math.floor(m)===m)return e.ticks(t)}var m;return e.domain()},exports.precisionCutOffs=s,exports.precisionCutOffsByType=d,exports.stackAxis=C,exports.timePrecisions=["millisecond","second","minute","hour","day","month","year"];
+"use strict";var e=require("lodash/uniq"),t=require("lodash/uniqBy"),n=require("lodash/sortBy"),r=require("lodash/last"),a=require("lodash/isDate"),i=require("d3-time-format"),o=require("d3-scale"),u=require("d3-time");function c(){return c=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},c.apply(this,arguments)}var s=[function(e){return e.setMilliseconds(0)},function(e){return e.setSeconds(0)},function(e){return e.setMinutes(0)},function(e){return e.setHours(0)},function(e){return e.setDate(1)},function(e){return e.setMonth(0)}],d={millisecond:[],second:s.slice(0,1),minute:s.slice(0,2),hour:s.slice(0,3),day:s.slice(0,4),month:s.slice(0,5),year:s.slice(0,6)},l=function(e){return function(t){return d[e].forEach((function(e){e(t)})),t}},f=function(e){var t=e.format,n=void 0===t?"native":t,r=e.precision,a=void 0===r?"millisecond":r,o=e.useUTC,u=void 0===o||o,c=l(a);return function(e){if(void 0===e)return e;if("native"===n||e instanceof Date)return c(e);var t=u?i.utcParse(n):i.timeParse(n);return c(t(e))}},m=function(e,t,n,r){var a,i,u,c,s=e.min,d=void 0===s?0:s,l=e.max,f=void 0===l?"auto":l,m=e.stacked,p=void 0!==m&&m,y=e.reverse,x=void 0!==y&&y,h=e.clamp,g=void 0!==h&&h,S=e.nice,k=void 0!==S&&S;"auto"===d?a=!0===p?null!=(i=t.minStacked)?i:0:t.min:a=d;"auto"===f?u=!0===p?null!=(c=t.maxStacked)?c:0:t.max:u=f;var T=o.scaleLinear().rangeRound("x"===r?[0,n]:[n,0]).domain(x?[u,a]:[a,u]).clamp(g);return!0===k?T.nice():"number"==typeof k&&T.nice(k),v(T,p)},v=function(e,t){void 0===t&&(t=!1);var n=e;return n.type="linear",n.stacked=t,n},p=function(e,t,n){var r=o.scalePoint().range([0,n]).domain(t.all);return r.type="point",r},y=function(e,t,n,r){var a=e.round,i=void 0===a||a,u=o.scaleBand().range("x"===r?[0,n]:[n,0]).domain(t.all).round(i);return x(u)},x=function(e){var t=e;return t.type="band",t},h=function(e,t,n){var r,a,i=e.format,u=void 0===i?"native":i,c=e.precision,s=void 0===c?"millisecond":c,d=e.min,l=void 0===d?"auto":d,m=e.max,v=void 0===m?"auto":m,p=e.useUTC,y=void 0===p||p,x=e.nice,h=void 0!==x&&x,g=f({format:u,precision:s,useUTC:y});r="auto"===l?g(t.min):"native"!==u?g(l):l,a="auto"===v?g(t.max):"native"!==u?g(v):v;var S=y?o.scaleUtc():o.scaleTime();S.range([0,n]),r&&a&&S.domain([r,a]),!0===h?S.nice():"object"!=typeof h&&"number"!=typeof h||S.nice(h);var k=S;return k.type="time",k.useUTC=y,k},g=function(e,t,n,r){var a,i=e.base,u=void 0===i?10:i,c=e.min,s=void 0===c?"auto":c,d=e.max,l=void 0===d?"auto":d,f=e.nice,m=void 0!==f&&f;if(t.all.some((function(e){return 0===e})))throw new Error("a log scale domain must not include or cross zero");var v,p,y=!1;if(t.all.filter((function(e){return null!=e})).forEach((function(e){y||(void 0===a?a=Math.sign(e):Math.sign(e)!==a&&(y=!0))})),y)throw new Error("a log scale domain must be strictly-positive or strictly-negative");v="auto"===s?t.min:s,p="auto"===l?t.max:l;var x=o.scaleLog().domain([v,p]).rangeRound("x"===r?[0,n]:[n,0]).base(u),h=m?x.nice():x;return h.type="log",h},S=function(e,t,n,r){var a,i,u=e.constant,c=void 0===u?1:u,s=e.min,d=void 0===s?"auto":s,l=e.max,f=void 0===l?"auto":l,m=e.reverse,v=void 0!==m&&m;a="auto"===d?t.min:d,i="auto"===f?t.max:f;var p=o.scaleSymlog().constant(c).rangeRound("x"===r?[0,n]:[n,0]).nice();!0===v?p.domain([i,a]):p.domain([a,i]);var y=p;return y.type="symlog",y},k=function(e){return"x"===e?"y":"x"},T=function(e,t){return e===t},M=function(e,t){return e.getTime()===t.getTime()};function b(e,t,n,r){switch(e.type){case"linear":return m(e,t,n,r);case"point":return p(e,t,n);case"band":return y(e,t,n,r);case"time":return h(e,t,n);case"log":return g(e,t,n,r);case"symlog":return S(e,t,n,r);default:throw new Error("invalid scale spec")}}var w=function(e,t,n){var r;if("stacked"in n&&n.stacked){var a=e.data["x"===t?"xStacked":"yStacked"];return null==a?null:n(a)}return null!=(r=n(e.data[t]))?r:null},E=function(e,t,n){return{x:D(e,"x",t),y:D(e,"y",n)}},D=function(a,i,o,u){var c=void 0===u?{}:u,s=c.getValue,d=void 0===s?function(e){return e.data[i]}:s,l=c.setValue,m=void 0===l?function(e,t){e.data[i]=t}:l;if("linear"===o.type)a.forEach((function(e){e.data.forEach((function(e){var t=d(e);t&&m(e,parseFloat(String(t)))}))}));else if("time"===o.type&&"native"!==o.format){var v=f(o);a.forEach((function(e){e.data.forEach((function(e){var t=d(e);t&&m(e,v(t))}))}))}var p=[];switch(a.forEach((function(e){e.data.forEach((function(e){p.push(d(e))}))})),o.type){case"linear":var y=n(e(p).filter((function(e){return null!==e})),(function(e){return e}));return{all:y,min:Math.min.apply(Math,y),max:Math.max.apply(Math,y)};case"time":var x=t(p,(function(e){return e.getTime()})).slice(0).sort((function(e,t){return t.getTime()-e.getTime()})).reverse();return{all:x,min:x[0],max:r(x)};default:var h=e(p);return{all:h,min:h[0],max:r(h)}}},C=function(e,t,n){var i=k(e),o=[];t[i].all.forEach((function(t){var u=a(t)?M:T,c=[];n.forEach((function(n){var a=n.data.find((function(e){return u(e.data[i],t)})),s=null,d=null;if(void 0!==a){if(null!==(s=a.data[e])){var l=r(c);void 0===l?d=s:null!==l&&(d=l+s)}a.data["x"===e?"xStacked":"yStacked"]=d}c.push(d),null!==d&&o.push(d)}))})),t[e].minStacked=Math.min.apply(Math,o),t[e].maxStacked=Math.max.apply(Math,o)},q=function(e,t){return C("x",e,t)},U=function(e,t){return C("y",e,t)},O=u.timeInterval((function(e){return e.setHours(0,0,0,0)}),(function(e,t){return e.setDate(e.getDate()+t)}),(function(e,t){return(t.getTime()-e.getTime())/864e5}),(function(e){return Math.floor(e.getTime()/864e5)})),P=u.timeInterval((function(e){return e.setUTCHours(0,0,0,0)}),(function(e,t){return e.setUTCDate(e.getUTCDate()+t)}),(function(e,t){return(t.getTime()-e.getTime())/864e5}),(function(e){return Math.floor(e.getTime()/864e5)})),j={millisecond:[u.timeMillisecond,u.utcMillisecond],second:[u.timeSecond,u.utcSecond],minute:[u.timeMinute,u.utcMinute],hour:[u.timeHour,u.utcHour],day:[O,P],week:[u.timeWeek,u.utcWeek],sunday:[u.timeSunday,u.utcSunday],monday:[u.timeMonday,u.utcMonday],tuesday:[u.timeTuesday,u.utcTuesday],wednesday:[u.timeWednesday,u.utcWednesday],thursday:[u.timeThursday,u.utcThursday],friday:[u.timeFriday,u.utcFriday],saturday:[u.timeSaturday,u.utcSaturday],month:[u.timeMonth,u.utcMonth],year:[u.timeYear,u.utcYear]},B=Object.keys(j),A=new RegExp("^every\\s*(\\d+)?\\s*("+B.join("|")+")s?$","i");exports.castBandScale=x,exports.castLinearScale=v,exports.castPointScale=function(e){var t=e;return t.type="point",t},exports.centerScale=function(e){var t=e.bandwidth();if(0===t)return e;var n=t/2;return e.round()&&(n=Math.round(n)),function(t){var r;return(null!=(r=e(t))?r:0)+n}},exports.compareDateValues=M,exports.compareValues=T,exports.computeScale=b,exports.computeXYScalesForSeries=function(e,t,n,r,a){var i=e.map((function(e){return function(e){return c({},e,{data:e.data.map((function(e){return{data:c({},e)}}))})}(e)})),o=E(i,t,n);"stacked"in t&&!0===t.stacked&&q(o,i),"stacked"in n&&!0===n.stacked&&U(o,i);var u=b(t,o.x,r,"x"),s=b(n,o.y,a,"y"),d=i.map((function(e){return c({},e,{data:e.data.map((function(e){return c({},e,{position:{x:w(e,"x",u),y:w(e,"y",s)}})}))})}));return c({},o,{series:d,xScale:u,yScale:s})},exports.createBandScale=y,exports.createDateNormalizer=f,exports.createLinearScale=m,exports.createLogScale=g,exports.createPointScale=p,exports.createPrecisionMethod=l,exports.createSymlogScale=S,exports.createTimeScale=h,exports.generateSeriesAxis=D,exports.generateSeriesXY=E,exports.getOtherAxis=k,exports.getScaleTicks=function(e,t){if(Array.isArray(t))return t;if("string"==typeof t&&"useUTC"in e){var n=t.match(A);if(n){var r=n[1],a=n[2],i=j[a][e.useUTC?1:0];if("day"===a){var o,u,c=e.domain(),s=c[0],d=c[1],l=new Date(d);return l.setDate(l.getDate()+1),null!=(o=null==(u=i.every(Number(null!=r?r:1)))?void 0:u.range(s,l))?o:[]}if(void 0===r)return e.ticks(i);var f=i.every(Number(r));if(f)return e.ticks(f)}throw new Error("Invalid tickValues: "+t)}if("ticks"in e){if(void 0===t)return e.ticks();if("number"==typeof(m=t)&&isFinite(m)&&Math.floor(m)===m)return e.ticks(t)}var m;return e.domain()},exports.precisionCutOffs=s,exports.precisionCutOffsByType=d,exports.stackAxis=C,exports.timePrecisions=["millisecond","second","minute","hour","day","month","year"];
 //# sourceMappingURL=nivo-scales.cjs.js.map
diff --git a/dist/nivo-scales.cjs.js.map b/dist/nivo-scales.cjs.js.map
index 576fff88d078064b4f3e84a9a9bfd96b6328d0a8..16e6b1e6978253279d083e7770c9108086bcbb82 100644
--- a/dist/nivo-scales.cjs.js.map
+++ b/dist/nivo-scales.cjs.js.map
@@ -1 +1 @@
-{"version":3,"file":"nivo-scales.cjs.js","sources":["../src/timeHelpers.ts","../src/linearScale.ts","../src/pointScale.ts","../src/bandScale.ts","../src/timeScale.ts","../src/logScale.ts","../src/symlogScale.ts","../src/compute.ts","../src/ticks.ts"],"sourcesContent":["import { timeParse, utcParse } from 'd3-time-format'\n\nexport const timePrecisions = [\n    'millisecond',\n    'second',\n    'minute',\n    'hour',\n    'day',\n    'month',\n    'year',\n] as const\n\nexport type TIME_PRECISION = (typeof timePrecisions)[number]\n\nexport const precisionCutOffs: ((date: Date) => void)[] = [\n    date => date.setMilliseconds(0),\n    date => date.setSeconds(0),\n    date => date.setMinutes(0),\n    date => date.setHours(0),\n    date => date.setDate(1),\n    date => date.setMonth(0),\n]\n\nexport const precisionCutOffsByType: Record<TIME_PRECISION, ((date: Date) => void)[]> = {\n    millisecond: [],\n    second: precisionCutOffs.slice(0, 1),\n    minute: precisionCutOffs.slice(0, 2),\n    hour: precisionCutOffs.slice(0, 3),\n    day: precisionCutOffs.slice(0, 4),\n    month: precisionCutOffs.slice(0, 5),\n    year: precisionCutOffs.slice(0, 6),\n}\n\nexport const createPrecisionMethod = (precision: TIME_PRECISION) => (date: Date) => {\n    precisionCutOffsByType[precision].forEach(cutOff => {\n        cutOff(date)\n    })\n\n    return date\n}\n\nexport const createDateNormalizer = ({\n    format = 'native',\n    precision = 'millisecond',\n    useUTC = true,\n}: {\n    format?: 'native' | string\n    precision?: TIME_PRECISION\n    useUTC?: boolean\n}) => {\n    const precisionFn = createPrecisionMethod(precision)\n\n    return (value: Date | string | undefined) => {\n        if (value === undefined) {\n            return value\n        }\n\n        if (format === 'native' || value instanceof Date) {\n            return precisionFn(value as Date)\n        }\n\n        const parseTime = useUTC ? utcParse(format) : timeParse(format)\n        return precisionFn(parseTime(value as string) as Date)\n    }\n}\n","import { NumberValue, scaleLinear, ScaleLinear as D3ScaleLinear } from 'd3-scale'\nimport { ScaleLinearSpec, ScaleLinear, ComputedSerieAxis, ScaleAxis } from './types'\n\nexport const createLinearScale = <Output extends NumberValue>(\n    {\n        min = 0,\n        max = 'auto',\n        stacked = false,\n        reverse = false,\n        clamp = false,\n        nice = false,\n    }: ScaleLinearSpec,\n    data: ComputedSerieAxis<Output>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    let minValue: NumberValue\n    if (min === 'auto') {\n        minValue = stacked === true ? data.minStacked ?? 0 : data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: NumberValue\n    if (max === 'auto') {\n        maxValue = stacked === true ? data.maxStacked ?? 0 : data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleLinear<number, Output>()\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .domain(reverse ? [maxValue, minValue] : [minValue, maxValue])\n        .clamp(clamp)\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'number') scale.nice(nice)\n\n    return castLinearScale<number, Output>(scale, stacked)\n}\n\nexport const castLinearScale = <Range, Output>(\n    scale: D3ScaleLinear<Range, Output>,\n    stacked = false\n) => {\n    const typedScale = scale as unknown as ScaleLinear<number>\n    typedScale.type = 'linear'\n    typedScale.stacked = stacked\n\n    return typedScale\n}\n","import { scalePoint, ScalePoint as D3ScalePoint } from 'd3-scale'\nimport { ComputedSerieAxis, ScalePoint, ScalePointSpec, StringValue } from './types'\n\nexport const createPointScale = <Input extends StringValue>(\n    _spec: ScalePointSpec,\n    data: ComputedSerieAxis<Input>,\n    size: number\n) => {\n    const scale = scalePoint<Input>().range([0, size]).domain(data.all)\n\n    const typedScale = scale as ScalePoint<Input>\n    typedScale.type = 'point'\n\n    return typedScale\n}\n\nexport const castPointScale = <Input extends StringValue>(scale: D3ScalePoint<Input>) => {\n    const typedScale = scale as ScalePoint<Input>\n    typedScale.type = 'point'\n\n    return typedScale\n}\n","import { scaleBand, ScaleBand as D3ScaleBand } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleBand, ScaleBandSpec, StringValue, ScaleAxis } from './types'\n\nexport const createBandScale = <Input extends StringValue>(\n    { round = true }: ScaleBandSpec,\n    data: ComputedSerieAxis<Input>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    const scale = scaleBand<Input>()\n        .range(axis === 'x' ? [0, size] : [size, 0])\n        .domain(data.all)\n        .round(round)\n\n    return castBandScale<Input>(scale)\n}\n\nexport const castBandScale = <Input extends StringValue>(scale: D3ScaleBand<Input>) => {\n    const typedScale = scale as ScaleBand<Input>\n    typedScale.type = 'band'\n\n    return typedScale\n}\n","import { NumberValue, scaleTime, scaleUtc } from 'd3-scale'\nimport { createDateNormalizer } from './timeHelpers'\nimport { ComputedSerieAxis, ScaleTime, ScaleTimeSpec } from './types'\n\nexport const createTimeScale = <Input extends Date | NumberValue>(\n    {\n        format = 'native',\n        precision = 'millisecond',\n        min = 'auto',\n        max = 'auto',\n        useUTC = true,\n        nice = false,\n    }: ScaleTimeSpec,\n    data: ComputedSerieAxis<string | Date>,\n    size: number\n) => {\n    const normalize = createDateNormalizer({ format, precision, useUTC })\n\n    let minValue: Date | undefined\n    if (min === 'auto') {\n        minValue = normalize(data.min)\n    } else if (format !== 'native') {\n        minValue = normalize(min)\n    } else {\n        minValue = min as Date\n    }\n\n    let maxValue: Date | undefined\n    if (max === 'auto') {\n        maxValue = normalize(data.max)\n    } else if (format !== 'native') {\n        maxValue = normalize(max)\n    } else {\n        maxValue = max as Date\n    }\n\n    const scale = useUTC ? scaleUtc() : scaleTime()\n\n    scale.range([0, size])\n\n    if (minValue && maxValue) scale.domain([minValue, maxValue])\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'object' || typeof nice === 'number') scale.nice(nice)\n\n    const typedScale = scale as unknown as ScaleTime<Input>\n\n    typedScale.type = 'time'\n    typedScale.useUTC = useUTC\n\n    return typedScale\n}\n","import { scaleLog } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleAxis, ScaleLog, ScaleLogSpec } from './types'\n\nexport const createLogScale = (\n    { base = 10, min = 'auto', max = 'auto' }: ScaleLogSpec,\n    data: ComputedSerieAxis<number>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    const hasZero = data.all.some(v => v === 0)\n    if (hasZero) {\n        throw new Error(`a log scale domain must not include or cross zero`)\n    }\n\n    let sign: number\n    let hasMixedSign = false\n    data.all\n        .filter(v => v != null)\n        .forEach(v => {\n            if (hasMixedSign) return\n            if (sign === undefined) {\n                sign = Math.sign(v)\n            } else if (Math.sign(v) !== sign) {\n                hasMixedSign = true\n            }\n        })\n\n    if (hasMixedSign) {\n        throw new Error(`a log scale domain must be strictly-positive or strictly-negative`)\n    }\n\n    let minValue: number\n    if (min === 'auto') {\n        minValue = data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: number\n    if (max === 'auto') {\n        maxValue = data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleLog<number, number>()\n        .domain([minValue, maxValue])\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .base(base)\n        .nice()\n\n    const typedScale = scale as ScaleLog\n    typedScale.type = 'log'\n\n    return typedScale\n}\n","import { scaleSymlog } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleAxis, ScaleSymlog, ScaleSymlogSpec } from './types'\n\nexport const createSymlogScale = (\n    { constant = 1, min = 'auto', max = 'auto', reverse = false }: ScaleSymlogSpec,\n    data: ComputedSerieAxis<number>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    let minValue: number\n    if (min === 'auto') {\n        minValue = data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: number\n    if (max === 'auto') {\n        maxValue = data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleSymlog<number, number>()\n        .constant(constant)\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .nice()\n\n    if (reverse === true) scale.domain([maxValue, minValue])\n    else scale.domain([minValue, maxValue])\n\n    const typedScale = scale as ScaleSymlog\n    typedScale.type = 'symlog'\n\n    return typedScale\n}\n","import uniq from 'lodash/uniq'\nimport uniqBy from 'lodash/uniqBy'\nimport sortBy from 'lodash/sortBy'\nimport last from 'lodash/last'\nimport isDate from 'lodash/isDate'\nimport { createDateNormalizer } from './timeHelpers'\nimport { ScaleAxis, ScaleSpec, ScaleValue, SerieAxis, ComputedSerieAxis } from './types'\nimport { createLinearScale } from './linearScale'\nimport { createPointScale } from './pointScale'\nimport { createBandScale } from './bandScale'\nimport { createTimeScale } from './timeScale'\nimport { createLogScale } from './logScale'\nimport { createSymlogScale } from './symlogScale'\n\ntype XY = ReturnType<typeof generateSeriesXY>\n\ntype StackedXY = {\n    [K in keyof XY]: XY[K] & {\n        maxStacked: number\n        minStacked: number\n    }\n}\n\ninterface SerieDatum {\n    x: number | string | Date\n    // only numbers can be stacked\n    xStacked?: number | null\n    y: number | string | Date\n    // only numbers can be stacked\n    yStacked?: number | null\n}\n\ntype Serie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: D[]\n}\n\ntype NestedSerie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: {\n        data: D\n    }[]\n}\n\nexport type ComputedSerie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: {\n        data: D\n        position: {\n            x: number | null\n            y: number | null\n        }\n    }[]\n}\n\ntype Compare = <T>(a: T, b: T) => boolean\n\nexport const getOtherAxis = (axis: ScaleAxis): ScaleAxis => (axis === 'x' ? 'y' : 'x')\n\nexport const compareValues = (a: string | number, b: string | number) => a === b\nexport const compareDateValues = (a: Date, b: Date) => a.getTime() === b.getTime()\n\nexport function computeScale<Input extends ScaleValue>(\n    spec: ScaleSpec,\n    data: ComputedSerieAxis<any>,\n    size: number,\n    axis: ScaleAxis\n) {\n    switch (spec.type) {\n        case 'linear':\n            return createLinearScale(spec, data, size, axis)\n        case 'point':\n            return createPointScale<Input>(spec, data, size)\n        case 'band':\n            return createBandScale<Input>(spec, data, size, axis)\n        case 'time':\n            return createTimeScale(spec, data, size)\n        case 'log':\n            return createLogScale(spec, data, size, axis)\n        case 'symlog':\n            return createSymlogScale(spec, data, size, axis)\n        default:\n            throw new Error('invalid scale spec')\n    }\n}\n\n/**\n * Convert serie data to have the original data stored in a nested prop.\n *\n * We do this in order to avoid conflicts between raw & computed properties.\n * <- { data: { x: 1, y: 3 }[] }\n * -> { data: { data: { x: 1, y: 3 } }[] }\n */\nconst nestSerieData = <S = never, D extends SerieDatum = SerieDatum>(\n    serie: Serie<S, D>\n): NestedSerie<S, D> => ({\n    ...serie,\n    data: serie.data.map(d => ({ data: { ...d } })),\n})\n\nconst getDatumAxisPosition = <D extends SerieDatum = SerieDatum>(\n    datum: { data: D },\n    axis: ScaleAxis,\n    scale: any\n): number | null => {\n    if ('stacked' in scale && scale.stacked) {\n        const stackedValue = datum.data[axis === 'x' ? 'xStacked' : 'yStacked']\n        if (stackedValue === null || stackedValue === undefined) {\n            return null\n        }\n\n        return scale(stackedValue)\n    }\n\n    return scale(datum.data[axis]) ?? null\n}\n\n/**\n * Compute x/y d3 scales from an array of data series, and scale specifications.\n *\n * We use generics as it's not uncommon to have extra properties such as an id\n * added to the series, or extra props on data, in such case, you should override\n * the default types.\n */\nexport const computeXYScalesForSeries = <S = never, D extends SerieDatum = SerieDatum>(\n    series: Serie<S, D>[],\n    xScaleSpec: ScaleSpec,\n    yScaleSpec: ScaleSpec,\n    width: number,\n    height: number\n) => {\n    // first nest series to avoid property conflicts\n    const nestedSeries = series.map(serie => nestSerieData<S, D>(serie))\n\n    // then compute data for each axis: all, min, max values\n    const xy = generateSeriesXY<S, D>(nestedSeries, xScaleSpec, yScaleSpec)\n\n    // stack x values depending on xScale\n    if ('stacked' in xScaleSpec && xScaleSpec.stacked === true) {\n        stackX<S, D>(xy as StackedXY, nestedSeries)\n    }\n\n    // stack y values depending on yScale\n    if ('stacked' in yScaleSpec && yScaleSpec.stacked === true) {\n        stackY<S, D>(xy as StackedXY, nestedSeries)\n    }\n\n    // computes scales\n    const xScale = computeScale<D['x']>(xScaleSpec, xy.x, width, 'x')\n    const yScale = computeScale<D['y']>(yScaleSpec, xy.y, height, 'y')\n\n    // assign position to each datum in every scale\n    const computedSeries: ComputedSerie<S, D>[] = nestedSeries.map(serie => ({\n        ...serie,\n        data: serie.data.map(datum => ({\n            ...datum,\n            position: {\n                x: getDatumAxisPosition(datum, 'x', xScale),\n                y: getDatumAxisPosition(datum, 'y', yScale),\n            },\n        })),\n    }))\n\n    return {\n        ...xy,\n        series: computedSeries,\n        xScale,\n        yScale,\n    }\n}\n\nexport const generateSeriesXY = <S = never, D extends SerieDatum = SerieDatum>(\n    series: NestedSerie<S, D>[],\n    xScaleSpec: ScaleSpec,\n    yScaleSpec: ScaleSpec\n) => ({\n    x: generateSeriesAxis<'x', D['x']>(series, 'x', xScaleSpec),\n    y: generateSeriesAxis<'y', D['y']>(series, 'y', yScaleSpec),\n})\n\n/**\n * Normalize data according to scale type, (time => Date, linear => Number)\n * compute sorted unique values and min/max.\n */\nexport const generateSeriesAxis = <Axis extends ScaleAxis, Value extends ScaleValue>(\n    series: SerieAxis<Axis, Value>,\n    axis: Axis,\n    scaleSpec: ScaleSpec,\n    {\n        getValue = d => d.data[axis],\n        setValue = (d, v) => {\n            d.data[axis] = v\n        },\n    }: {\n        getValue?: (d: { data: Record<Axis, Value | null> }) => Value | null\n        setValue?: (d: { data: Record<Axis, Value | null> }, v: Value) => void\n    } = {}\n) => {\n    if (scaleSpec.type === 'linear') {\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                const value = getValue(d)\n\n                if (value) {\n                    setValue(d, parseFloat(String(value)) as unknown as Value)\n                }\n            })\n        })\n    } else if (scaleSpec.type === 'time' && scaleSpec.format !== 'native') {\n        // `native` means we already have Date instances,\n        // otherwise we have to convert the values to Date.\n        const parseTime = createDateNormalizer(scaleSpec)\n\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                const value = getValue(d)\n\n                if (value) {\n                    setValue(d, parseTime(value as Date) as unknown as Value)\n                }\n            })\n        })\n    }\n\n    const values: unknown[] = []\n\n    series.forEach(serie => {\n        serie.data.forEach(d => {\n            values.push(getValue(d))\n        })\n    })\n\n    switch (scaleSpec.type) {\n        case 'linear': {\n            const all = sortBy(\n                // filer null values to deal with holes in linechart\n                uniq(values as number[]).filter(v => v !== null),\n                v => v\n            )\n\n            return { all, min: Math.min(...all), max: Math.max(...all) }\n        }\n        case 'time': {\n            const all = uniqBy(values as Date[], v => v.getTime())\n                .slice(0)\n                .sort((a, b) => b.getTime() - a.getTime())\n                .reverse()\n\n            return { all, min: all[0], max: last(all) }\n        }\n        default: {\n            const all = uniq(values)\n\n            return { all, min: all[0], max: last(all) }\n        }\n    }\n}\n\nexport const stackAxis = <S = never, D extends SerieDatum = SerieDatum>(\n    axis: ScaleAxis,\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => {\n    const otherAxis = getOtherAxis(axis)\n    const all: number[] = []\n\n    xy[otherAxis].all.forEach(v => {\n        const compare = (isDate(v) ? compareDateValues : compareValues) as Compare\n        const stack: Array<number | null> = []\n\n        series.forEach(serie => {\n            const datum = serie.data.find(d => compare(d.data[otherAxis], v))\n            let value = null\n            let stackValue = null\n\n            if (datum !== undefined) {\n                // stacked values only support numbers\n                value = datum.data[axis] as number\n                if (value !== null) {\n                    const head = last(stack)\n                    if (head === undefined) {\n                        stackValue = value\n                    } else if (head !== null) {\n                        stackValue = head + value\n                    }\n                }\n\n                datum.data[axis === 'x' ? 'xStacked' : 'yStacked'] = stackValue\n            }\n\n            stack.push(stackValue)\n\n            if (stackValue !== null) {\n                all.push(stackValue)\n            }\n        })\n    })\n\n    xy[axis].minStacked = Math.min(...all)\n    xy[axis].maxStacked = Math.max(...all)\n}\n\nconst stackX = <S = never, D extends SerieDatum = SerieDatum>(\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => stackAxis<S, D>('x', xy, series)\n\nconst stackY = <S = never, D extends SerieDatum = SerieDatum>(\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => stackAxis<S, D>('y', xy, series)\n","import {\n    CountableTimeInterval,\n    timeMillisecond,\n    utcMillisecond,\n    timeSecond,\n    utcSecond,\n    timeMinute,\n    utcMinute,\n    timeHour,\n    utcHour,\n    timeWeek,\n    utcWeek,\n    timeSunday,\n    utcSunday,\n    timeMonday,\n    utcMonday,\n    timeTuesday,\n    utcTuesday,\n    timeWednesday,\n    utcWednesday,\n    timeThursday,\n    utcThursday,\n    timeFriday,\n    utcFriday,\n    timeSaturday,\n    utcSaturday,\n    timeMonth,\n    utcMonth,\n    timeYear,\n    utcYear,\n    timeInterval,\n} from 'd3-time'\nimport { ScaleValue, TicksSpec, AnyScale, ScaleWithBandwidth } from './types'\n\nexport const centerScale = <Value>(scale: ScaleWithBandwidth) => {\n    const bandwidth = scale.bandwidth()\n\n    if (bandwidth === 0) return scale\n\n    let offset = bandwidth / 2\n    if (scale.round()) {\n        offset = Math.round(offset)\n    }\n\n    return <T extends Value>(d: T) => (scale(d) ?? 0) + offset\n}\n\nconst timeDay = timeInterval(\n    date => date.setHours(0, 0, 0, 0),\n    (date, step) => date.setDate(date.getDate() + step),\n    (start, end) => (end.getTime() - start.getTime()) / 864e5,\n    date => Math.floor(date.getTime() / 864e5)\n)\n\nconst utcDay = timeInterval(\n    date => date.setUTCHours(0, 0, 0, 0),\n    (date, step) => date.setUTCDate(date.getUTCDate() + step),\n    (start, end) => (end.getTime() - start.getTime()) / 864e5,\n    date => Math.floor(date.getTime() / 864e5)\n)\n\nconst timeByType: Record<string, [CountableTimeInterval, CountableTimeInterval]> = {\n    millisecond: [timeMillisecond, utcMillisecond],\n    second: [timeSecond, utcSecond],\n    minute: [timeMinute, utcMinute],\n    hour: [timeHour, utcHour],\n    day: [timeDay, utcDay],\n    week: [timeWeek, utcWeek],\n    sunday: [timeSunday, utcSunday],\n    monday: [timeMonday, utcMonday],\n    tuesday: [timeTuesday, utcTuesday],\n    wednesday: [timeWednesday, utcWednesday],\n    thursday: [timeThursday, utcThursday],\n    friday: [timeFriday, utcFriday],\n    saturday: [timeSaturday, utcSaturday],\n    month: [timeMonth, utcMonth],\n    year: [timeYear, utcYear],\n}\n\nconst timeTypes = Object.keys(timeByType)\nconst timeIntervalRegexp = new RegExp(`^every\\\\s*(\\\\d+)?\\\\s*(${timeTypes.join('|')})s?$`, 'i')\n\nconst isInteger = (value: unknown): value is number =>\n    typeof value === 'number' && isFinite(value) && Math.floor(value) === value\n\nexport const getScaleTicks = <Value extends ScaleValue>(\n    scale: AnyScale,\n    spec?: TicksSpec<Value>\n) => {\n    // specific values\n    if (Array.isArray(spec)) {\n        return spec\n    }\n\n    if (typeof spec === 'string' && 'useUTC' in scale) {\n        // time interval\n        const matches = spec.match(timeIntervalRegexp)\n\n        if (matches) {\n            const [, amount, type] = matches\n            // UTC is used as it's more predictable\n            // however local time could be used too\n            // let's see how it fits users' requirements\n            const timeType = timeByType[type][scale.useUTC ? 1 : 0]\n\n            if (type === 'day') {\n                const [start, originalStop] = scale.domain()\n                const stop = new Date(originalStop)\n\n                // Set range to include last day in the domain since `interval.range` function is exclusive stop\n                stop.setDate(stop.getDate() + 1)\n\n                return timeType.every(Number(amount ?? 1))?.range(start, stop) ?? []\n            }\n\n            if (amount === undefined) {\n                return scale.ticks(timeType)\n            }\n\n            const interval = timeType.every(Number(amount))\n\n            if (interval) {\n                return scale.ticks(interval)\n            }\n        }\n\n        throw new Error(`Invalid tickValues: ${spec}`)\n    }\n\n    // continuous scales\n    if ('ticks' in scale) {\n        // default behaviour\n        if (spec === undefined) {\n            return scale.ticks()\n        }\n\n        // specific tick count\n        if (isInteger(spec)) {\n            return scale.ticks(spec)\n        }\n    }\n\n    // non linear scale default\n    return scale.domain()\n}\n"],"names":["precisionCutOffs","date","setMilliseconds","setSeconds","setMinutes","setHours","setDate","setMonth","precisionCutOffsByType","millisecond","second","slice","minute","hour","day","month","year","createPrecisionMethod","precision","forEach","cutOff","createDateNormalizer","_ref","_ref$format","format","_ref$precision","_ref$useUTC","useUTC","precisionFn","value","undefined","Date","parseTime","utcParse","timeParse","createLinearScale","data","size","axis","minValue","_data$minStacked","maxValue","_data$maxStacked","_ref$min","min","_ref$max","max","_ref$stacked","stacked","_ref$reverse","reverse","_ref$clamp","clamp","_ref$nice","nice","minStacked","maxStacked","scale","scaleLinear","rangeRound","domain","castLinearScale","typedScale","type","createPointScale","_spec","scalePoint","range","all","createBandScale","_ref$round","round","scaleBand","castBandScale","createTimeScale","normalize","scaleUtc","scaleTime","createLogScale","sign","_ref$base","base","some","v","Error","hasMixedSign","filter","Math","scaleLog","createSymlogScale","_ref$constant","constant","scaleSymlog","getOtherAxis","compareValues","a","b","compareDateValues","getTime","computeScale","spec","getDatumAxisPosition","datum","_scale","stackedValue","generateSeriesXY","series","xScaleSpec","yScaleSpec","x","generateSeriesAxis","y","scaleSpec","_temp","_ref$getValue","getValue","d","_ref$setValue","setValue","serie","parseFloat","String","values","push","sortBy","uniq","apply","uniqBy","sort","last","stackAxis","xy","otherAxis","compare","isDate","stack","find","stackValue","head","stackX","stackY","timeDay","timeInterval","step","getDate","start","end","floor","utcDay","setUTCHours","setUTCDate","getUTCDate","timeByType","timeMillisecond","utcMillisecond","timeSecond","utcSecond","timeMinute","utcMinute","timeHour","utcHour","week","timeWeek","utcWeek","sunday","timeSunday","utcSunday","monday","timeMonday","utcMonday","tuesday","timeTuesday","utcTuesday","wednesday","timeWednesday","utcWednesday","thursday","timeThursday","utcThursday","friday","timeFriday","utcFriday","saturday","timeSaturday","utcSaturday","timeMonth","utcMonth","timeYear","utcYear","timeTypes","Object","keys","timeIntervalRegexp","RegExp","join","bandwidth","offset","width","height","nestedSeries","map","_extends","nestSerieData","xScale","yScale","computedSeries","position","Array","isArray","matches","match","amount","timeType","_timeType$every$range","_timeType$every","_scale$domain","originalStop","stop","every","Number","ticks","interval","isFinite"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"nivo-scales.cjs.js","sources":["../src/timeHelpers.ts","../src/linearScale.ts","../src/pointScale.ts","../src/bandScale.ts","../src/timeScale.ts","../src/logScale.ts","../src/symlogScale.ts","../src/compute.ts","../src/ticks.ts"],"sourcesContent":["import { timeParse, utcParse } from 'd3-time-format'\n\nexport const timePrecisions = [\n    'millisecond',\n    'second',\n    'minute',\n    'hour',\n    'day',\n    'month',\n    'year',\n] as const\n\nexport type TIME_PRECISION = (typeof timePrecisions)[number]\n\nexport const precisionCutOffs: ((date: Date) => void)[] = [\n    date => date.setMilliseconds(0),\n    date => date.setSeconds(0),\n    date => date.setMinutes(0),\n    date => date.setHours(0),\n    date => date.setDate(1),\n    date => date.setMonth(0),\n]\n\nexport const precisionCutOffsByType: Record<TIME_PRECISION, ((date: Date) => void)[]> = {\n    millisecond: [],\n    second: precisionCutOffs.slice(0, 1),\n    minute: precisionCutOffs.slice(0, 2),\n    hour: precisionCutOffs.slice(0, 3),\n    day: precisionCutOffs.slice(0, 4),\n    month: precisionCutOffs.slice(0, 5),\n    year: precisionCutOffs.slice(0, 6),\n}\n\nexport const createPrecisionMethod = (precision: TIME_PRECISION) => (date: Date) => {\n    precisionCutOffsByType[precision].forEach(cutOff => {\n        cutOff(date)\n    })\n\n    return date\n}\n\nexport const createDateNormalizer = ({\n    format = 'native',\n    precision = 'millisecond',\n    useUTC = true,\n}: {\n    format?: 'native' | string\n    precision?: TIME_PRECISION\n    useUTC?: boolean\n}) => {\n    const precisionFn = createPrecisionMethod(precision)\n\n    return (value: Date | string | undefined) => {\n        if (value === undefined) {\n            return value\n        }\n\n        if (format === 'native' || value instanceof Date) {\n            return precisionFn(value as Date)\n        }\n\n        const parseTime = useUTC ? utcParse(format) : timeParse(format)\n        return precisionFn(parseTime(value as string) as Date)\n    }\n}\n","import { NumberValue, scaleLinear, ScaleLinear as D3ScaleLinear } from 'd3-scale'\nimport { ScaleLinearSpec, ScaleLinear, ComputedSerieAxis, ScaleAxis } from './types'\n\nexport const createLinearScale = <Output extends NumberValue>(\n    {\n        min = 0,\n        max = 'auto',\n        stacked = false,\n        reverse = false,\n        clamp = false,\n        nice = false,\n    }: ScaleLinearSpec,\n    data: ComputedSerieAxis<Output>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    let minValue: NumberValue\n    if (min === 'auto') {\n        minValue = stacked === true ? data.minStacked ?? 0 : data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: NumberValue\n    if (max === 'auto') {\n        maxValue = stacked === true ? data.maxStacked ?? 0 : data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleLinear<number, Output>()\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .domain(reverse ? [maxValue, minValue] : [minValue, maxValue])\n        .clamp(clamp)\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'number') scale.nice(nice)\n\n    return castLinearScale<number, Output>(scale, stacked)\n}\n\nexport const castLinearScale = <Range, Output>(\n    scale: D3ScaleLinear<Range, Output>,\n    stacked = false\n) => {\n    const typedScale = scale as unknown as ScaleLinear<number>\n    typedScale.type = 'linear'\n    typedScale.stacked = stacked\n\n    return typedScale\n}\n","import { scalePoint, ScalePoint as D3ScalePoint } from 'd3-scale'\nimport { ComputedSerieAxis, ScalePoint, ScalePointSpec, StringValue } from './types'\n\nexport const createPointScale = <Input extends StringValue>(\n    _spec: ScalePointSpec,\n    data: ComputedSerieAxis<Input>,\n    size: number\n) => {\n    const scale = scalePoint<Input>().range([0, size]).domain(data.all)\n\n    const typedScale = scale as ScalePoint<Input>\n    typedScale.type = 'point'\n\n    return typedScale\n}\n\nexport const castPointScale = <Input extends StringValue>(scale: D3ScalePoint<Input>) => {\n    const typedScale = scale as ScalePoint<Input>\n    typedScale.type = 'point'\n\n    return typedScale\n}\n","import { scaleBand, ScaleBand as D3ScaleBand } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleBand, ScaleBandSpec, StringValue, ScaleAxis } from './types'\n\nexport const createBandScale = <Input extends StringValue>(\n    { round = true }: ScaleBandSpec,\n    data: ComputedSerieAxis<Input>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    const scale = scaleBand<Input>()\n        .range(axis === 'x' ? [0, size] : [size, 0])\n        .domain(data.all)\n        .round(round)\n\n    return castBandScale<Input>(scale)\n}\n\nexport const castBandScale = <Input extends StringValue>(scale: D3ScaleBand<Input>) => {\n    const typedScale = scale as ScaleBand<Input>\n    typedScale.type = 'band'\n\n    return typedScale\n}\n","import { NumberValue, scaleTime, scaleUtc } from 'd3-scale'\nimport { createDateNormalizer } from './timeHelpers'\nimport { ComputedSerieAxis, ScaleTime, ScaleTimeSpec } from './types'\n\nexport const createTimeScale = <Input extends Date | NumberValue>(\n    {\n        format = 'native',\n        precision = 'millisecond',\n        min = 'auto',\n        max = 'auto',\n        useUTC = true,\n        nice = false,\n    }: ScaleTimeSpec,\n    data: ComputedSerieAxis<string | Date>,\n    size: number\n) => {\n    const normalize = createDateNormalizer({ format, precision, useUTC })\n\n    let minValue: Date | undefined\n    if (min === 'auto') {\n        minValue = normalize(data.min)\n    } else if (format !== 'native') {\n        minValue = normalize(min)\n    } else {\n        minValue = min as Date\n    }\n\n    let maxValue: Date | undefined\n    if (max === 'auto') {\n        maxValue = normalize(data.max)\n    } else if (format !== 'native') {\n        maxValue = normalize(max)\n    } else {\n        maxValue = max as Date\n    }\n\n    const scale = useUTC ? scaleUtc() : scaleTime()\n\n    scale.range([0, size])\n\n    if (minValue && maxValue) scale.domain([minValue, maxValue])\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'object' || typeof nice === 'number') scale.nice(nice)\n\n    const typedScale = scale as unknown as ScaleTime<Input>\n\n    typedScale.type = 'time'\n    typedScale.useUTC = useUTC\n\n    return typedScale\n}\n","import { scaleLog } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleAxis, ScaleLog, ScaleLogSpec } from './types'\n\nexport const createLogScale = (\n    { base = 10, min = 'auto', max = 'auto', nice = false }: ScaleLogSpec,\n    data: ComputedSerieAxis<number>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    const hasZero = data.all.some(v => v === 0)\n    if (hasZero) {\n        throw new Error(`a log scale domain must not include or cross zero`)\n    }\n\n    let sign: number\n    let hasMixedSign = false\n    data.all\n        .filter(v => v != null)\n        .forEach(v => {\n            if (hasMixedSign) return\n            if (sign === undefined) {\n                sign = Math.sign(v)\n            } else if (Math.sign(v) !== sign) {\n                hasMixedSign = true\n            }\n        })\n\n    if (hasMixedSign) {\n        throw new Error(`a log scale domain must be strictly-positive or strictly-negative`)\n    }\n\n    let minValue: number\n    if (min === 'auto') {\n        minValue = data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: number\n    if (max === 'auto') {\n        maxValue = data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleLog<number, number>()\n        .domain([minValue, maxValue])\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .base(base)\n\n    const typedScale = (nice ? scale.nice() : scale) as ScaleLog\n    typedScale.type = 'log'\n\n    return typedScale\n}\n","import { scaleSymlog } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleAxis, ScaleSymlog, ScaleSymlogSpec } from './types'\n\nexport const createSymlogScale = (\n    { constant = 1, min = 'auto', max = 'auto', reverse = false }: ScaleSymlogSpec,\n    data: ComputedSerieAxis<number>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    let minValue: number\n    if (min === 'auto') {\n        minValue = data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: number\n    if (max === 'auto') {\n        maxValue = data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleSymlog<number, number>()\n        .constant(constant)\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .nice()\n\n    if (reverse === true) scale.domain([maxValue, minValue])\n    else scale.domain([minValue, maxValue])\n\n    const typedScale = scale as ScaleSymlog\n    typedScale.type = 'symlog'\n\n    return typedScale\n}\n","import uniq from 'lodash/uniq'\nimport uniqBy from 'lodash/uniqBy'\nimport sortBy from 'lodash/sortBy'\nimport last from 'lodash/last'\nimport isDate from 'lodash/isDate'\nimport { createDateNormalizer } from './timeHelpers'\nimport { ScaleAxis, ScaleSpec, ScaleValue, SerieAxis, ComputedSerieAxis } from './types'\nimport { createLinearScale } from './linearScale'\nimport { createPointScale } from './pointScale'\nimport { createBandScale } from './bandScale'\nimport { createTimeScale } from './timeScale'\nimport { createLogScale } from './logScale'\nimport { createSymlogScale } from './symlogScale'\n\ntype XY = ReturnType<typeof generateSeriesXY>\n\ntype StackedXY = {\n    [K in keyof XY]: XY[K] & {\n        maxStacked: number\n        minStacked: number\n    }\n}\n\ninterface SerieDatum {\n    x: number | string | Date\n    // only numbers can be stacked\n    xStacked?: number | null\n    y: number | string | Date\n    // only numbers can be stacked\n    yStacked?: number | null\n}\n\ntype Serie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: D[]\n}\n\ntype NestedSerie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: {\n        data: D\n    }[]\n}\n\nexport type ComputedSerie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: {\n        data: D\n        position: {\n            x: number | null\n            y: number | null\n        }\n    }[]\n}\n\ntype Compare = <T>(a: T, b: T) => boolean\n\nexport const getOtherAxis = (axis: ScaleAxis): ScaleAxis => (axis === 'x' ? 'y' : 'x')\n\nexport const compareValues = (a: string | number, b: string | number) => a === b\nexport const compareDateValues = (a: Date, b: Date) => a.getTime() === b.getTime()\n\nexport function computeScale<Input extends ScaleValue>(\n    spec: ScaleSpec,\n    data: ComputedSerieAxis<any>,\n    size: number,\n    axis: ScaleAxis\n) {\n    switch (spec.type) {\n        case 'linear':\n            return createLinearScale(spec, data, size, axis)\n        case 'point':\n            return createPointScale<Input>(spec, data, size)\n        case 'band':\n            return createBandScale<Input>(spec, data, size, axis)\n        case 'time':\n            return createTimeScale(spec, data, size)\n        case 'log':\n            return createLogScale(spec, data, size, axis)\n        case 'symlog':\n            return createSymlogScale(spec, data, size, axis)\n        default:\n            throw new Error('invalid scale spec')\n    }\n}\n\n/**\n * Convert serie data to have the original data stored in a nested prop.\n *\n * We do this in order to avoid conflicts between raw & computed properties.\n * <- { data: { x: 1, y: 3 }[] }\n * -> { data: { data: { x: 1, y: 3 } }[] }\n */\nconst nestSerieData = <S = never, D extends SerieDatum = SerieDatum>(\n    serie: Serie<S, D>\n): NestedSerie<S, D> => ({\n    ...serie,\n    data: serie.data.map(d => ({ data: { ...d } })),\n})\n\nconst getDatumAxisPosition = <D extends SerieDatum = SerieDatum>(\n    datum: { data: D },\n    axis: ScaleAxis,\n    scale: any\n): number | null => {\n    if ('stacked' in scale && scale.stacked) {\n        const stackedValue = datum.data[axis === 'x' ? 'xStacked' : 'yStacked']\n        if (stackedValue === null || stackedValue === undefined) {\n            return null\n        }\n\n        return scale(stackedValue)\n    }\n\n    return scale(datum.data[axis]) ?? null\n}\n\n/**\n * Compute x/y d3 scales from an array of data series, and scale specifications.\n *\n * We use generics as it's not uncommon to have extra properties such as an id\n * added to the series, or extra props on data, in such case, you should override\n * the default types.\n */\nexport const computeXYScalesForSeries = <S = never, D extends SerieDatum = SerieDatum>(\n    series: Serie<S, D>[],\n    xScaleSpec: ScaleSpec,\n    yScaleSpec: ScaleSpec,\n    width: number,\n    height: number\n) => {\n    // first nest series to avoid property conflicts\n    const nestedSeries = series.map(serie => nestSerieData<S, D>(serie))\n\n    // then compute data for each axis: all, min, max values\n    const xy = generateSeriesXY<S, D>(nestedSeries, xScaleSpec, yScaleSpec)\n\n    // stack x values depending on xScale\n    if ('stacked' in xScaleSpec && xScaleSpec.stacked === true) {\n        stackX<S, D>(xy as StackedXY, nestedSeries)\n    }\n\n    // stack y values depending on yScale\n    if ('stacked' in yScaleSpec && yScaleSpec.stacked === true) {\n        stackY<S, D>(xy as StackedXY, nestedSeries)\n    }\n\n    // computes scales\n    const xScale = computeScale<D['x']>(xScaleSpec, xy.x, width, 'x')\n    const yScale = computeScale<D['y']>(yScaleSpec, xy.y, height, 'y')\n\n    // assign position to each datum in every scale\n    const computedSeries: ComputedSerie<S, D>[] = nestedSeries.map(serie => ({\n        ...serie,\n        data: serie.data.map(datum => ({\n            ...datum,\n            position: {\n                x: getDatumAxisPosition(datum, 'x', xScale),\n                y: getDatumAxisPosition(datum, 'y', yScale),\n            },\n        })),\n    }))\n\n    return {\n        ...xy,\n        series: computedSeries,\n        xScale,\n        yScale,\n    }\n}\n\nexport const generateSeriesXY = <S = never, D extends SerieDatum = SerieDatum>(\n    series: NestedSerie<S, D>[],\n    xScaleSpec: ScaleSpec,\n    yScaleSpec: ScaleSpec\n) => ({\n    x: generateSeriesAxis<'x', D['x']>(series, 'x', xScaleSpec),\n    y: generateSeriesAxis<'y', D['y']>(series, 'y', yScaleSpec),\n})\n\n/**\n * Normalize data according to scale type, (time => Date, linear => Number)\n * compute sorted unique values and min/max.\n */\nexport const generateSeriesAxis = <Axis extends ScaleAxis, Value extends ScaleValue>(\n    series: SerieAxis<Axis, Value>,\n    axis: Axis,\n    scaleSpec: ScaleSpec,\n    {\n        getValue = d => d.data[axis],\n        setValue = (d, v) => {\n            d.data[axis] = v\n        },\n    }: {\n        getValue?: (d: { data: Record<Axis, Value | null> }) => Value | null\n        setValue?: (d: { data: Record<Axis, Value | null> }, v: Value) => void\n    } = {}\n) => {\n    if (scaleSpec.type === 'linear') {\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                const value = getValue(d)\n\n                if (value) {\n                    setValue(d, parseFloat(String(value)) as unknown as Value)\n                }\n            })\n        })\n    } else if (scaleSpec.type === 'time' && scaleSpec.format !== 'native') {\n        // `native` means we already have Date instances,\n        // otherwise we have to convert the values to Date.\n        const parseTime = createDateNormalizer(scaleSpec)\n\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                const value = getValue(d)\n\n                if (value) {\n                    setValue(d, parseTime(value as Date) as unknown as Value)\n                }\n            })\n        })\n    }\n\n    const values: unknown[] = []\n\n    series.forEach(serie => {\n        serie.data.forEach(d => {\n            values.push(getValue(d))\n        })\n    })\n\n    switch (scaleSpec.type) {\n        case 'linear': {\n            const all = sortBy(\n                // filer null values to deal with holes in linechart\n                uniq(values as number[]).filter(v => v !== null),\n                v => v\n            )\n\n            return { all, min: Math.min(...all), max: Math.max(...all) }\n        }\n        case 'time': {\n            const all = uniqBy(values as Date[], v => v.getTime())\n                .slice(0)\n                .sort((a, b) => b.getTime() - a.getTime())\n                .reverse()\n\n            return { all, min: all[0], max: last(all) }\n        }\n        default: {\n            const all = uniq(values)\n\n            return { all, min: all[0], max: last(all) }\n        }\n    }\n}\n\nexport const stackAxis = <S = never, D extends SerieDatum = SerieDatum>(\n    axis: ScaleAxis,\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => {\n    const otherAxis = getOtherAxis(axis)\n    const all: number[] = []\n\n    xy[otherAxis].all.forEach(v => {\n        const compare = (isDate(v) ? compareDateValues : compareValues) as Compare\n        const stack: Array<number | null> = []\n\n        series.forEach(serie => {\n            const datum = serie.data.find(d => compare(d.data[otherAxis], v))\n            let value = null\n            let stackValue = null\n\n            if (datum !== undefined) {\n                // stacked values only support numbers\n                value = datum.data[axis] as number\n                if (value !== null) {\n                    const head = last(stack)\n                    if (head === undefined) {\n                        stackValue = value\n                    } else if (head !== null) {\n                        stackValue = head + value\n                    }\n                }\n\n                datum.data[axis === 'x' ? 'xStacked' : 'yStacked'] = stackValue\n            }\n\n            stack.push(stackValue)\n\n            if (stackValue !== null) {\n                all.push(stackValue)\n            }\n        })\n    })\n\n    xy[axis].minStacked = Math.min(...all)\n    xy[axis].maxStacked = Math.max(...all)\n}\n\nconst stackX = <S = never, D extends SerieDatum = SerieDatum>(\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => stackAxis<S, D>('x', xy, series)\n\nconst stackY = <S = never, D extends SerieDatum = SerieDatum>(\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => stackAxis<S, D>('y', xy, series)\n","import {\n    CountableTimeInterval,\n    timeMillisecond,\n    utcMillisecond,\n    timeSecond,\n    utcSecond,\n    timeMinute,\n    utcMinute,\n    timeHour,\n    utcHour,\n    timeWeek,\n    utcWeek,\n    timeSunday,\n    utcSunday,\n    timeMonday,\n    utcMonday,\n    timeTuesday,\n    utcTuesday,\n    timeWednesday,\n    utcWednesday,\n    timeThursday,\n    utcThursday,\n    timeFriday,\n    utcFriday,\n    timeSaturday,\n    utcSaturday,\n    timeMonth,\n    utcMonth,\n    timeYear,\n    utcYear,\n    timeInterval,\n} from 'd3-time'\nimport { ScaleValue, TicksSpec, AnyScale, ScaleWithBandwidth } from './types'\n\nexport const centerScale = <Value>(scale: ScaleWithBandwidth) => {\n    const bandwidth = scale.bandwidth()\n\n    if (bandwidth === 0) return scale\n\n    let offset = bandwidth / 2\n    if (scale.round()) {\n        offset = Math.round(offset)\n    }\n\n    return <T extends Value>(d: T) => (scale(d) ?? 0) + offset\n}\n\nconst timeDay = timeInterval(\n    date => date.setHours(0, 0, 0, 0),\n    (date, step) => date.setDate(date.getDate() + step),\n    (start, end) => (end.getTime() - start.getTime()) / 864e5,\n    date => Math.floor(date.getTime() / 864e5)\n)\n\nconst utcDay = timeInterval(\n    date => date.setUTCHours(0, 0, 0, 0),\n    (date, step) => date.setUTCDate(date.getUTCDate() + step),\n    (start, end) => (end.getTime() - start.getTime()) / 864e5,\n    date => Math.floor(date.getTime() / 864e5)\n)\n\nconst timeByType: Record<string, [CountableTimeInterval, CountableTimeInterval]> = {\n    millisecond: [timeMillisecond, utcMillisecond],\n    second: [timeSecond, utcSecond],\n    minute: [timeMinute, utcMinute],\n    hour: [timeHour, utcHour],\n    day: [timeDay, utcDay],\n    week: [timeWeek, utcWeek],\n    sunday: [timeSunday, utcSunday],\n    monday: [timeMonday, utcMonday],\n    tuesday: [timeTuesday, utcTuesday],\n    wednesday: [timeWednesday, utcWednesday],\n    thursday: [timeThursday, utcThursday],\n    friday: [timeFriday, utcFriday],\n    saturday: [timeSaturday, utcSaturday],\n    month: [timeMonth, utcMonth],\n    year: [timeYear, utcYear],\n}\n\nconst timeTypes = Object.keys(timeByType)\nconst timeIntervalRegexp = new RegExp(`^every\\\\s*(\\\\d+)?\\\\s*(${timeTypes.join('|')})s?$`, 'i')\n\nconst isInteger = (value: unknown): value is number =>\n    typeof value === 'number' && isFinite(value) && Math.floor(value) === value\n\nexport const getScaleTicks = <Value extends ScaleValue>(\n    scale: AnyScale,\n    spec?: TicksSpec<Value>\n) => {\n    // specific values\n    if (Array.isArray(spec)) {\n        return spec\n    }\n\n    if (typeof spec === 'string' && 'useUTC' in scale) {\n        // time interval\n        const matches = spec.match(timeIntervalRegexp)\n\n        if (matches) {\n            const [, amount, type] = matches\n            // UTC is used as it's more predictable\n            // however local time could be used too\n            // let's see how it fits users' requirements\n            const timeType = timeByType[type][scale.useUTC ? 1 : 0]\n\n            if (type === 'day') {\n                const [start, originalStop] = scale.domain()\n                const stop = new Date(originalStop)\n\n                // Set range to include last day in the domain since `interval.range` function is exclusive stop\n                stop.setDate(stop.getDate() + 1)\n\n                return timeType.every(Number(amount ?? 1))?.range(start, stop) ?? []\n            }\n\n            if (amount === undefined) {\n                return scale.ticks(timeType)\n            }\n\n            const interval = timeType.every(Number(amount))\n\n            if (interval) {\n                return scale.ticks(interval)\n            }\n        }\n\n        throw new Error(`Invalid tickValues: ${spec}`)\n    }\n\n    // continuous scales\n    if ('ticks' in scale) {\n        // default behaviour\n        if (spec === undefined) {\n            return scale.ticks()\n        }\n\n        // specific tick count\n        if (isInteger(spec)) {\n            return scale.ticks(spec)\n        }\n    }\n\n    // non linear scale default\n    return scale.domain()\n}\n"],"names":["precisionCutOffs","date","setMilliseconds","setSeconds","setMinutes","setHours","setDate","setMonth","precisionCutOffsByType","millisecond","second","slice","minute","hour","day","month","year","createPrecisionMethod","precision","forEach","cutOff","createDateNormalizer","_ref","_ref$format","format","_ref$precision","_ref$useUTC","useUTC","precisionFn","value","undefined","Date","parseTime","utcParse","timeParse","createLinearScale","data","size","axis","minValue","_data$minStacked","maxValue","_data$maxStacked","_ref$min","min","_ref$max","max","_ref$stacked","stacked","_ref$reverse","reverse","_ref$clamp","clamp","_ref$nice","nice","minStacked","maxStacked","scale","scaleLinear","rangeRound","domain","castLinearScale","typedScale","type","createPointScale","_spec","scalePoint","range","all","createBandScale","_ref$round","round","scaleBand","castBandScale","createTimeScale","normalize","scaleUtc","scaleTime","createLogScale","sign","_ref$base","base","some","v","Error","hasMixedSign","filter","Math","scaleLog","createSymlogScale","_ref$constant","constant","scaleSymlog","getOtherAxis","compareValues","a","b","compareDateValues","getTime","computeScale","spec","getDatumAxisPosition","datum","_scale","stackedValue","generateSeriesXY","series","xScaleSpec","yScaleSpec","x","generateSeriesAxis","y","scaleSpec","_temp","_ref$getValue","getValue","d","_ref$setValue","setValue","serie","parseFloat","String","values","push","sortBy","uniq","apply","uniqBy","sort","last","stackAxis","xy","otherAxis","compare","isDate","stack","find","stackValue","head","stackX","stackY","timeDay","timeInterval","step","getDate","start","end","floor","utcDay","setUTCHours","setUTCDate","getUTCDate","timeByType","timeMillisecond","utcMillisecond","timeSecond","utcSecond","timeMinute","utcMinute","timeHour","utcHour","week","timeWeek","utcWeek","sunday","timeSunday","utcSunday","monday","timeMonday","utcMonday","tuesday","timeTuesday","utcTuesday","wednesday","timeWednesday","utcWednesday","thursday","timeThursday","utcThursday","friday","timeFriday","utcFriday","saturday","timeSaturday","utcSaturday","timeMonth","utcMonth","timeYear","utcYear","timeTypes","Object","keys","timeIntervalRegexp","RegExp","join","bandwidth","offset","width","height","nestedSeries","map","_extends","nestSerieData","xScale","yScale","computedSeries","position","Array","isArray","matches","match","amount","timeType","_timeType$every$range","_timeType$every","_scale$domain","originalStop","stop","every","Number","ticks","interval","isFinite"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/nivo-scales.es.js b/dist/nivo-scales.es.js
index 5941b1978f7e82ff1f4c3e6e0fe7277af86d95a8..327aae19d42b85fe2c5be5c9c6001ef0328319b1 100644
--- a/dist/nivo-scales.es.js
+++ b/dist/nivo-scales.es.js
@@ -1,2 +1,2 @@
-import n from"lodash/uniq";import t from"lodash/uniqBy";import r from"lodash/sortBy";import e from"lodash/last";import a from"lodash/isDate";import{utcParse as i,timeParse as o}from"d3-time-format";import{scaleLinear as u,scalePoint as c,scaleBand as s,scaleUtc as d,scaleTime as f,scaleLog as l,scaleSymlog as m}from"d3-scale";import{timeInterval as v,timeMillisecond as y,utcMillisecond as p,timeSecond as h,utcSecond as g,timeMinute as x,utcMinute as k,timeHour as T,utcHour as b,timeWeek as M,utcWeek as w,timeSunday as E,utcSunday as S,timeMonday as D,utcMonday as C,timeTuesday as U,utcTuesday as j,timeWednesday as O,utcWednesday as R,timeThursday as H,utcThursday as V,timeFriday as q,utcFriday as A,timeSaturday as B,utcSaturday as F,timeMonth as N,utcMonth as z,timeYear as I,utcYear as P}from"d3-time";function $(){return $=Object.assign?Object.assign.bind():function(n){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var e in r)Object.prototype.hasOwnProperty.call(r,e)&&(n[e]=r[e])}return n},$.apply(this,arguments)}var G=["millisecond","second","minute","hour","day","month","year"],J=[function(n){return n.setMilliseconds(0)},function(n){return n.setSeconds(0)},function(n){return n.setMinutes(0)},function(n){return n.setHours(0)},function(n){return n.setDate(1)},function(n){return n.setMonth(0)}],K={millisecond:[],second:J.slice(0,1),minute:J.slice(0,2),hour:J.slice(0,3),day:J.slice(0,4),month:J.slice(0,5),year:J.slice(0,6)},L=function(n){return function(t){return K[n].forEach((function(n){n(t)})),t}},Q=function(n){var t=n.format,r=void 0===t?"native":t,e=n.precision,a=void 0===e?"millisecond":e,u=n.useUTC,c=void 0===u||u,s=L(a);return function(n){if(void 0===n)return n;if("native"===r||n instanceof Date)return s(n);var t=c?i(r):o(r);return s(t(n))}},W=function(n,t,r,e){var a,i,o,c,s=n.min,d=void 0===s?0:s,f=n.max,l=void 0===f?"auto":f,m=n.stacked,v=void 0!==m&&m,y=n.reverse,p=void 0!==y&&y,h=n.clamp,g=void 0!==h&&h,x=n.nice,k=void 0!==x&&x;"auto"===d?a=!0===v?null!=(i=t.minStacked)?i:0:t.min:a=d;"auto"===l?o=!0===v?null!=(c=t.maxStacked)?c:0:t.max:o=l;var T=u().rangeRound("x"===e?[0,r]:[r,0]).domain(p?[o,a]:[a,o]).clamp(g);return!0===k?T.nice():"number"==typeof k&&T.nice(k),X(T,v)},X=function(n,t){void 0===t&&(t=!1);var r=n;return r.type="linear",r.stacked=t,r},Y=function(n,t,r){var e=c().range([0,r]).domain(t.all);return e.type="point",e},Z=function(n){var t=n;return t.type="point",t},_=function(n,t,r,e){var a=n.round,i=void 0===a||a,o=s().range("x"===e?[0,r]:[r,0]).domain(t.all).round(i);return nn(o)},nn=function(n){var t=n;return t.type="band",t},tn=function(n,t,r){var e,a,i=n.format,o=void 0===i?"native":i,u=n.precision,c=void 0===u?"millisecond":u,s=n.min,l=void 0===s?"auto":s,m=n.max,v=void 0===m?"auto":m,y=n.useUTC,p=void 0===y||y,h=n.nice,g=void 0!==h&&h,x=Q({format:o,precision:c,useUTC:p});e="auto"===l?x(t.min):"native"!==o?x(l):l,a="auto"===v?x(t.max):"native"!==o?x(v):v;var k=p?d():f();k.range([0,r]),e&&a&&k.domain([e,a]),!0===g?k.nice():"object"!=typeof g&&"number"!=typeof g||k.nice(g);var T=k;return T.type="time",T.useUTC=p,T},rn=function(n,t,r,e){var a,i=n.base,o=void 0===i?10:i,u=n.min,c=void 0===u?"auto":u,s=n.max,d=void 0===s?"auto":s;if(t.all.some((function(n){return 0===n})))throw new Error("a log scale domain must not include or cross zero");var f,m,v=!1;if(t.all.filter((function(n){return null!=n})).forEach((function(n){v||(void 0===a?a=Math.sign(n):Math.sign(n)!==a&&(v=!0))})),v)throw new Error("a log scale domain must be strictly-positive or strictly-negative");f="auto"===c?t.min:c,m="auto"===d?t.max:d;var y=l().domain([f,m]).rangeRound("x"===e?[0,r]:[r,0]).base(o).nice();return y.type="log",y},en=function(n,t,r,e){var a,i,o=n.constant,u=void 0===o?1:o,c=n.min,s=void 0===c?"auto":c,d=n.max,f=void 0===d?"auto":d,l=n.reverse,v=void 0!==l&&l;a="auto"===s?t.min:s,i="auto"===f?t.max:f;var y=m().constant(u).rangeRound("x"===e?[0,r]:[r,0]).nice();!0===v?y.domain([i,a]):y.domain([a,i]);var p=y;return p.type="symlog",p},an=function(n){return"x"===n?"y":"x"},on=function(n,t){return n===t},un=function(n,t){return n.getTime()===t.getTime()};function cn(n,t,r,e){switch(n.type){case"linear":return W(n,t,r,e);case"point":return Y(n,t,r);case"band":return _(n,t,r,e);case"time":return tn(n,t,r);case"log":return rn(n,t,r,e);case"symlog":return en(n,t,r,e);default:throw new Error("invalid scale spec")}}var sn=function(n,t,r){var e;if("stacked"in r&&r.stacked){var a=n.data["x"===t?"xStacked":"yStacked"];return null==a?null:r(a)}return null!=(e=r(n.data[t]))?e:null},dn=function(n,t,r,e,a){var i=n.map((function(n){return function(n){return $({},n,{data:n.data.map((function(n){return{data:$({},n)}}))})}(n)})),o=fn(i,t,r);"stacked"in t&&!0===t.stacked&&vn(o,i),"stacked"in r&&!0===r.stacked&&yn(o,i);var u=cn(t,o.x,e,"x"),c=cn(r,o.y,a,"y"),s=i.map((function(n){return $({},n,{data:n.data.map((function(n){return $({},n,{position:{x:sn(n,"x",u),y:sn(n,"y",c)}})}))})}));return $({},o,{series:s,xScale:u,yScale:c})},fn=function(n,t,r){return{x:ln(n,"x",t),y:ln(n,"y",r)}},ln=function(a,i,o,u){var c=void 0===u?{}:u,s=c.getValue,d=void 0===s?function(n){return n.data[i]}:s,f=c.setValue,l=void 0===f?function(n,t){n.data[i]=t}:f;if("linear"===o.type)a.forEach((function(n){n.data.forEach((function(n){var t=d(n);t&&l(n,parseFloat(String(t)))}))}));else if("time"===o.type&&"native"!==o.format){var m=Q(o);a.forEach((function(n){n.data.forEach((function(n){var t=d(n);t&&l(n,m(t))}))}))}var v=[];switch(a.forEach((function(n){n.data.forEach((function(n){v.push(d(n))}))})),o.type){case"linear":var y=r(n(v).filter((function(n){return null!==n})),(function(n){return n}));return{all:y,min:Math.min.apply(Math,y),max:Math.max.apply(Math,y)};case"time":var p=t(v,(function(n){return n.getTime()})).slice(0).sort((function(n,t){return t.getTime()-n.getTime()})).reverse();return{all:p,min:p[0],max:e(p)};default:var h=n(v);return{all:h,min:h[0],max:e(h)}}},mn=function(n,t,r){var i=an(n),o=[];t[i].all.forEach((function(t){var u=a(t)?un:on,c=[];r.forEach((function(r){var a=r.data.find((function(n){return u(n.data[i],t)})),s=null,d=null;if(void 0!==a){if(null!==(s=a.data[n])){var f=e(c);void 0===f?d=s:null!==f&&(d=f+s)}a.data["x"===n?"xStacked":"yStacked"]=d}c.push(d),null!==d&&o.push(d)}))})),t[n].minStacked=Math.min.apply(Math,o),t[n].maxStacked=Math.max.apply(Math,o)},vn=function(n,t){return mn("x",n,t)},yn=function(n,t){return mn("y",n,t)},pn=function(n){var t=n.bandwidth();if(0===t)return n;var r=t/2;return n.round()&&(r=Math.round(r)),function(t){var e;return(null!=(e=n(t))?e:0)+r}},hn={millisecond:[y,p],second:[h,g],minute:[x,k],hour:[T,b],day:[v((function(n){return n.setHours(0,0,0,0)}),(function(n,t){return n.setDate(n.getDate()+t)}),(function(n,t){return(t.getTime()-n.getTime())/864e5}),(function(n){return Math.floor(n.getTime()/864e5)})),v((function(n){return n.setUTCHours(0,0,0,0)}),(function(n,t){return n.setUTCDate(n.getUTCDate()+t)}),(function(n,t){return(t.getTime()-n.getTime())/864e5}),(function(n){return Math.floor(n.getTime()/864e5)}))],week:[M,w],sunday:[E,S],monday:[D,C],tuesday:[U,j],wednesday:[O,R],thursday:[H,V],friday:[q,A],saturday:[B,F],month:[N,z],year:[I,P]},gn=Object.keys(hn),xn=new RegExp("^every\\s*(\\d+)?\\s*("+gn.join("|")+")s?$","i"),kn=function(n,t){if(Array.isArray(t))return t;if("string"==typeof t&&"useUTC"in n){var r=t.match(xn);if(r){var e=r[1],a=r[2],i=hn[a][n.useUTC?1:0];if("day"===a){var o,u,c=n.domain(),s=c[0],d=c[1],f=new Date(d);return f.setDate(f.getDate()+1),null!=(o=null==(u=i.every(Number(null!=e?e:1)))?void 0:u.range(s,f))?o:[]}if(void 0===e)return n.ticks(i);var l=i.every(Number(e));if(l)return n.ticks(l)}throw new Error("Invalid tickValues: "+t)}if("ticks"in n){if(void 0===t)return n.ticks();if("number"==typeof(m=t)&&isFinite(m)&&Math.floor(m)===m)return n.ticks(t)}var m;return n.domain()};export{nn as castBandScale,X as castLinearScale,Z as castPointScale,pn as centerScale,un as compareDateValues,on as compareValues,cn as computeScale,dn as computeXYScalesForSeries,_ as createBandScale,Q as createDateNormalizer,W as createLinearScale,rn as createLogScale,Y as createPointScale,L as createPrecisionMethod,en as createSymlogScale,tn as createTimeScale,ln as generateSeriesAxis,fn as generateSeriesXY,an as getOtherAxis,kn as getScaleTicks,J as precisionCutOffs,K as precisionCutOffsByType,mn as stackAxis,G as timePrecisions};
+import n from"lodash/uniq";import t from"lodash/uniqBy";import r from"lodash/sortBy";import e from"lodash/last";import a from"lodash/isDate";import{utcParse as i,timeParse as o}from"d3-time-format";import{scaleLinear as u,scalePoint as c,scaleBand as d,scaleUtc as s,scaleTime as f,scaleLog as l,scaleSymlog as m}from"d3-scale";import{timeInterval as v,timeMillisecond as y,utcMillisecond as p,timeSecond as h,utcSecond as g,timeMinute as x,utcMinute as k,timeHour as T,utcHour as b,timeWeek as M,utcWeek as w,timeSunday as E,utcSunday as S,timeMonday as D,utcMonday as C,timeTuesday as U,utcTuesday as j,timeWednesday as O,utcWednesday as R,timeThursday as H,utcThursday as V,timeFriday as q,utcFriday as A,timeSaturday as B,utcSaturday as F,timeMonth as N,utcMonth as z,timeYear as I,utcYear as P}from"d3-time";function $(){return $=Object.assign?Object.assign.bind():function(n){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var e in r)Object.prototype.hasOwnProperty.call(r,e)&&(n[e]=r[e])}return n},$.apply(this,arguments)}var G=["millisecond","second","minute","hour","day","month","year"],J=[function(n){return n.setMilliseconds(0)},function(n){return n.setSeconds(0)},function(n){return n.setMinutes(0)},function(n){return n.setHours(0)},function(n){return n.setDate(1)},function(n){return n.setMonth(0)}],K={millisecond:[],second:J.slice(0,1),minute:J.slice(0,2),hour:J.slice(0,3),day:J.slice(0,4),month:J.slice(0,5),year:J.slice(0,6)},L=function(n){return function(t){return K[n].forEach((function(n){n(t)})),t}},Q=function(n){var t=n.format,r=void 0===t?"native":t,e=n.precision,a=void 0===e?"millisecond":e,u=n.useUTC,c=void 0===u||u,d=L(a);return function(n){if(void 0===n)return n;if("native"===r||n instanceof Date)return d(n);var t=c?i(r):o(r);return d(t(n))}},W=function(n,t,r,e){var a,i,o,c,d=n.min,s=void 0===d?0:d,f=n.max,l=void 0===f?"auto":f,m=n.stacked,v=void 0!==m&&m,y=n.reverse,p=void 0!==y&&y,h=n.clamp,g=void 0!==h&&h,x=n.nice,k=void 0!==x&&x;"auto"===s?a=!0===v?null!=(i=t.minStacked)?i:0:t.min:a=s;"auto"===l?o=!0===v?null!=(c=t.maxStacked)?c:0:t.max:o=l;var T=u().rangeRound("x"===e?[0,r]:[r,0]).domain(p?[o,a]:[a,o]).clamp(g);return!0===k?T.nice():"number"==typeof k&&T.nice(k),X(T,v)},X=function(n,t){void 0===t&&(t=!1);var r=n;return r.type="linear",r.stacked=t,r},Y=function(n,t,r){var e=c().range([0,r]).domain(t.all);return e.type="point",e},Z=function(n){var t=n;return t.type="point",t},_=function(n,t,r,e){var a=n.round,i=void 0===a||a,o=d().range("x"===e?[0,r]:[r,0]).domain(t.all).round(i);return nn(o)},nn=function(n){var t=n;return t.type="band",t},tn=function(n,t,r){var e,a,i=n.format,o=void 0===i?"native":i,u=n.precision,c=void 0===u?"millisecond":u,d=n.min,l=void 0===d?"auto":d,m=n.max,v=void 0===m?"auto":m,y=n.useUTC,p=void 0===y||y,h=n.nice,g=void 0!==h&&h,x=Q({format:o,precision:c,useUTC:p});e="auto"===l?x(t.min):"native"!==o?x(l):l,a="auto"===v?x(t.max):"native"!==o?x(v):v;var k=p?s():f();k.range([0,r]),e&&a&&k.domain([e,a]),!0===g?k.nice():"object"!=typeof g&&"number"!=typeof g||k.nice(g);var T=k;return T.type="time",T.useUTC=p,T},rn=function(n,t,r,e){var a,i=n.base,o=void 0===i?10:i,u=n.min,c=void 0===u?"auto":u,d=n.max,s=void 0===d?"auto":d,f=n.nice,m=void 0!==f&&f;if(t.all.some((function(n){return 0===n})))throw new Error("a log scale domain must not include or cross zero");var v,y,p=!1;if(t.all.filter((function(n){return null!=n})).forEach((function(n){p||(void 0===a?a=Math.sign(n):Math.sign(n)!==a&&(p=!0))})),p)throw new Error("a log scale domain must be strictly-positive or strictly-negative");v="auto"===c?t.min:c,y="auto"===s?t.max:s;var h=l().domain([v,y]).rangeRound("x"===e?[0,r]:[r,0]).base(o),g=m?h.nice():h;return g.type="log",g},en=function(n,t,r,e){var a,i,o=n.constant,u=void 0===o?1:o,c=n.min,d=void 0===c?"auto":c,s=n.max,f=void 0===s?"auto":s,l=n.reverse,v=void 0!==l&&l;a="auto"===d?t.min:d,i="auto"===f?t.max:f;var y=m().constant(u).rangeRound("x"===e?[0,r]:[r,0]).nice();!0===v?y.domain([i,a]):y.domain([a,i]);var p=y;return p.type="symlog",p},an=function(n){return"x"===n?"y":"x"},on=function(n,t){return n===t},un=function(n,t){return n.getTime()===t.getTime()};function cn(n,t,r,e){switch(n.type){case"linear":return W(n,t,r,e);case"point":return Y(n,t,r);case"band":return _(n,t,r,e);case"time":return tn(n,t,r);case"log":return rn(n,t,r,e);case"symlog":return en(n,t,r,e);default:throw new Error("invalid scale spec")}}var dn=function(n,t,r){var e;if("stacked"in r&&r.stacked){var a=n.data["x"===t?"xStacked":"yStacked"];return null==a?null:r(a)}return null!=(e=r(n.data[t]))?e:null},sn=function(n,t,r,e,a){var i=n.map((function(n){return function(n){return $({},n,{data:n.data.map((function(n){return{data:$({},n)}}))})}(n)})),o=fn(i,t,r);"stacked"in t&&!0===t.stacked&&vn(o,i),"stacked"in r&&!0===r.stacked&&yn(o,i);var u=cn(t,o.x,e,"x"),c=cn(r,o.y,a,"y"),d=i.map((function(n){return $({},n,{data:n.data.map((function(n){return $({},n,{position:{x:dn(n,"x",u),y:dn(n,"y",c)}})}))})}));return $({},o,{series:d,xScale:u,yScale:c})},fn=function(n,t,r){return{x:ln(n,"x",t),y:ln(n,"y",r)}},ln=function(a,i,o,u){var c=void 0===u?{}:u,d=c.getValue,s=void 0===d?function(n){return n.data[i]}:d,f=c.setValue,l=void 0===f?function(n,t){n.data[i]=t}:f;if("linear"===o.type)a.forEach((function(n){n.data.forEach((function(n){var t=s(n);t&&l(n,parseFloat(String(t)))}))}));else if("time"===o.type&&"native"!==o.format){var m=Q(o);a.forEach((function(n){n.data.forEach((function(n){var t=s(n);t&&l(n,m(t))}))}))}var v=[];switch(a.forEach((function(n){n.data.forEach((function(n){v.push(s(n))}))})),o.type){case"linear":var y=r(n(v).filter((function(n){return null!==n})),(function(n){return n}));return{all:y,min:Math.min.apply(Math,y),max:Math.max.apply(Math,y)};case"time":var p=t(v,(function(n){return n.getTime()})).slice(0).sort((function(n,t){return t.getTime()-n.getTime()})).reverse();return{all:p,min:p[0],max:e(p)};default:var h=n(v);return{all:h,min:h[0],max:e(h)}}},mn=function(n,t,r){var i=an(n),o=[];t[i].all.forEach((function(t){var u=a(t)?un:on,c=[];r.forEach((function(r){var a=r.data.find((function(n){return u(n.data[i],t)})),d=null,s=null;if(void 0!==a){if(null!==(d=a.data[n])){var f=e(c);void 0===f?s=d:null!==f&&(s=f+d)}a.data["x"===n?"xStacked":"yStacked"]=s}c.push(s),null!==s&&o.push(s)}))})),t[n].minStacked=Math.min.apply(Math,o),t[n].maxStacked=Math.max.apply(Math,o)},vn=function(n,t){return mn("x",n,t)},yn=function(n,t){return mn("y",n,t)},pn=function(n){var t=n.bandwidth();if(0===t)return n;var r=t/2;return n.round()&&(r=Math.round(r)),function(t){var e;return(null!=(e=n(t))?e:0)+r}},hn={millisecond:[y,p],second:[h,g],minute:[x,k],hour:[T,b],day:[v((function(n){return n.setHours(0,0,0,0)}),(function(n,t){return n.setDate(n.getDate()+t)}),(function(n,t){return(t.getTime()-n.getTime())/864e5}),(function(n){return Math.floor(n.getTime()/864e5)})),v((function(n){return n.setUTCHours(0,0,0,0)}),(function(n,t){return n.setUTCDate(n.getUTCDate()+t)}),(function(n,t){return(t.getTime()-n.getTime())/864e5}),(function(n){return Math.floor(n.getTime()/864e5)}))],week:[M,w],sunday:[E,S],monday:[D,C],tuesday:[U,j],wednesday:[O,R],thursday:[H,V],friday:[q,A],saturday:[B,F],month:[N,z],year:[I,P]},gn=Object.keys(hn),xn=new RegExp("^every\\s*(\\d+)?\\s*("+gn.join("|")+")s?$","i"),kn=function(n,t){if(Array.isArray(t))return t;if("string"==typeof t&&"useUTC"in n){var r=t.match(xn);if(r){var e=r[1],a=r[2],i=hn[a][n.useUTC?1:0];if("day"===a){var o,u,c=n.domain(),d=c[0],s=c[1],f=new Date(s);return f.setDate(f.getDate()+1),null!=(o=null==(u=i.every(Number(null!=e?e:1)))?void 0:u.range(d,f))?o:[]}if(void 0===e)return n.ticks(i);var l=i.every(Number(e));if(l)return n.ticks(l)}throw new Error("Invalid tickValues: "+t)}if("ticks"in n){if(void 0===t)return n.ticks();if("number"==typeof(m=t)&&isFinite(m)&&Math.floor(m)===m)return n.ticks(t)}var m;return n.domain()};export{nn as castBandScale,X as castLinearScale,Z as castPointScale,pn as centerScale,un as compareDateValues,on as compareValues,cn as computeScale,sn as computeXYScalesForSeries,_ as createBandScale,Q as createDateNormalizer,W as createLinearScale,rn as createLogScale,Y as createPointScale,L as createPrecisionMethod,en as createSymlogScale,tn as createTimeScale,ln as generateSeriesAxis,fn as generateSeriesXY,an as getOtherAxis,kn as getScaleTicks,J as precisionCutOffs,K as precisionCutOffsByType,mn as stackAxis,G as timePrecisions};
 //# sourceMappingURL=nivo-scales.es.js.map
diff --git a/dist/nivo-scales.es.js.map b/dist/nivo-scales.es.js.map
index 6dff635e5e4305431bb9f338105fab2c8063b69f..dd63823bd840500836b1eb63a8cd92177f975235 100644
--- a/dist/nivo-scales.es.js.map
+++ b/dist/nivo-scales.es.js.map
@@ -1 +1 @@
-{"version":3,"file":"nivo-scales.es.js","sources":["../src/timeHelpers.ts","../src/linearScale.ts","../src/pointScale.ts","../src/bandScale.ts","../src/timeScale.ts","../src/logScale.ts","../src/symlogScale.ts","../src/compute.ts","../src/ticks.ts"],"sourcesContent":["import { timeParse, utcParse } from 'd3-time-format'\n\nexport const timePrecisions = [\n    'millisecond',\n    'second',\n    'minute',\n    'hour',\n    'day',\n    'month',\n    'year',\n] as const\n\nexport type TIME_PRECISION = (typeof timePrecisions)[number]\n\nexport const precisionCutOffs: ((date: Date) => void)[] = [\n    date => date.setMilliseconds(0),\n    date => date.setSeconds(0),\n    date => date.setMinutes(0),\n    date => date.setHours(0),\n    date => date.setDate(1),\n    date => date.setMonth(0),\n]\n\nexport const precisionCutOffsByType: Record<TIME_PRECISION, ((date: Date) => void)[]> = {\n    millisecond: [],\n    second: precisionCutOffs.slice(0, 1),\n    minute: precisionCutOffs.slice(0, 2),\n    hour: precisionCutOffs.slice(0, 3),\n    day: precisionCutOffs.slice(0, 4),\n    month: precisionCutOffs.slice(0, 5),\n    year: precisionCutOffs.slice(0, 6),\n}\n\nexport const createPrecisionMethod = (precision: TIME_PRECISION) => (date: Date) => {\n    precisionCutOffsByType[precision].forEach(cutOff => {\n        cutOff(date)\n    })\n\n    return date\n}\n\nexport const createDateNormalizer = ({\n    format = 'native',\n    precision = 'millisecond',\n    useUTC = true,\n}: {\n    format?: 'native' | string\n    precision?: TIME_PRECISION\n    useUTC?: boolean\n}) => {\n    const precisionFn = createPrecisionMethod(precision)\n\n    return (value: Date | string | undefined) => {\n        if (value === undefined) {\n            return value\n        }\n\n        if (format === 'native' || value instanceof Date) {\n            return precisionFn(value as Date)\n        }\n\n        const parseTime = useUTC ? utcParse(format) : timeParse(format)\n        return precisionFn(parseTime(value as string) as Date)\n    }\n}\n","import { NumberValue, scaleLinear, ScaleLinear as D3ScaleLinear } from 'd3-scale'\nimport { ScaleLinearSpec, ScaleLinear, ComputedSerieAxis, ScaleAxis } from './types'\n\nexport const createLinearScale = <Output extends NumberValue>(\n    {\n        min = 0,\n        max = 'auto',\n        stacked = false,\n        reverse = false,\n        clamp = false,\n        nice = false,\n    }: ScaleLinearSpec,\n    data: ComputedSerieAxis<Output>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    let minValue: NumberValue\n    if (min === 'auto') {\n        minValue = stacked === true ? data.minStacked ?? 0 : data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: NumberValue\n    if (max === 'auto') {\n        maxValue = stacked === true ? data.maxStacked ?? 0 : data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleLinear<number, Output>()\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .domain(reverse ? [maxValue, minValue] : [minValue, maxValue])\n        .clamp(clamp)\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'number') scale.nice(nice)\n\n    return castLinearScale<number, Output>(scale, stacked)\n}\n\nexport const castLinearScale = <Range, Output>(\n    scale: D3ScaleLinear<Range, Output>,\n    stacked = false\n) => {\n    const typedScale = scale as unknown as ScaleLinear<number>\n    typedScale.type = 'linear'\n    typedScale.stacked = stacked\n\n    return typedScale\n}\n","import { scalePoint, ScalePoint as D3ScalePoint } from 'd3-scale'\nimport { ComputedSerieAxis, ScalePoint, ScalePointSpec, StringValue } from './types'\n\nexport const createPointScale = <Input extends StringValue>(\n    _spec: ScalePointSpec,\n    data: ComputedSerieAxis<Input>,\n    size: number\n) => {\n    const scale = scalePoint<Input>().range([0, size]).domain(data.all)\n\n    const typedScale = scale as ScalePoint<Input>\n    typedScale.type = 'point'\n\n    return typedScale\n}\n\nexport const castPointScale = <Input extends StringValue>(scale: D3ScalePoint<Input>) => {\n    const typedScale = scale as ScalePoint<Input>\n    typedScale.type = 'point'\n\n    return typedScale\n}\n","import { scaleBand, ScaleBand as D3ScaleBand } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleBand, ScaleBandSpec, StringValue, ScaleAxis } from './types'\n\nexport const createBandScale = <Input extends StringValue>(\n    { round = true }: ScaleBandSpec,\n    data: ComputedSerieAxis<Input>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    const scale = scaleBand<Input>()\n        .range(axis === 'x' ? [0, size] : [size, 0])\n        .domain(data.all)\n        .round(round)\n\n    return castBandScale<Input>(scale)\n}\n\nexport const castBandScale = <Input extends StringValue>(scale: D3ScaleBand<Input>) => {\n    const typedScale = scale as ScaleBand<Input>\n    typedScale.type = 'band'\n\n    return typedScale\n}\n","import { NumberValue, scaleTime, scaleUtc } from 'd3-scale'\nimport { createDateNormalizer } from './timeHelpers'\nimport { ComputedSerieAxis, ScaleTime, ScaleTimeSpec } from './types'\n\nexport const createTimeScale = <Input extends Date | NumberValue>(\n    {\n        format = 'native',\n        precision = 'millisecond',\n        min = 'auto',\n        max = 'auto',\n        useUTC = true,\n        nice = false,\n    }: ScaleTimeSpec,\n    data: ComputedSerieAxis<string | Date>,\n    size: number\n) => {\n    const normalize = createDateNormalizer({ format, precision, useUTC })\n\n    let minValue: Date | undefined\n    if (min === 'auto') {\n        minValue = normalize(data.min)\n    } else if (format !== 'native') {\n        minValue = normalize(min)\n    } else {\n        minValue = min as Date\n    }\n\n    let maxValue: Date | undefined\n    if (max === 'auto') {\n        maxValue = normalize(data.max)\n    } else if (format !== 'native') {\n        maxValue = normalize(max)\n    } else {\n        maxValue = max as Date\n    }\n\n    const scale = useUTC ? scaleUtc() : scaleTime()\n\n    scale.range([0, size])\n\n    if (minValue && maxValue) scale.domain([minValue, maxValue])\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'object' || typeof nice === 'number') scale.nice(nice)\n\n    const typedScale = scale as unknown as ScaleTime<Input>\n\n    typedScale.type = 'time'\n    typedScale.useUTC = useUTC\n\n    return typedScale\n}\n","import { scaleLog } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleAxis, ScaleLog, ScaleLogSpec } from './types'\n\nexport const createLogScale = (\n    { base = 10, min = 'auto', max = 'auto' }: ScaleLogSpec,\n    data: ComputedSerieAxis<number>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    const hasZero = data.all.some(v => v === 0)\n    if (hasZero) {\n        throw new Error(`a log scale domain must not include or cross zero`)\n    }\n\n    let sign: number\n    let hasMixedSign = false\n    data.all\n        .filter(v => v != null)\n        .forEach(v => {\n            if (hasMixedSign) return\n            if (sign === undefined) {\n                sign = Math.sign(v)\n            } else if (Math.sign(v) !== sign) {\n                hasMixedSign = true\n            }\n        })\n\n    if (hasMixedSign) {\n        throw new Error(`a log scale domain must be strictly-positive or strictly-negative`)\n    }\n\n    let minValue: number\n    if (min === 'auto') {\n        minValue = data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: number\n    if (max === 'auto') {\n        maxValue = data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleLog<number, number>()\n        .domain([minValue, maxValue])\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .base(base)\n        .nice()\n\n    const typedScale = scale as ScaleLog\n    typedScale.type = 'log'\n\n    return typedScale\n}\n","import { scaleSymlog } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleAxis, ScaleSymlog, ScaleSymlogSpec } from './types'\n\nexport const createSymlogScale = (\n    { constant = 1, min = 'auto', max = 'auto', reverse = false }: ScaleSymlogSpec,\n    data: ComputedSerieAxis<number>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    let minValue: number\n    if (min === 'auto') {\n        minValue = data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: number\n    if (max === 'auto') {\n        maxValue = data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleSymlog<number, number>()\n        .constant(constant)\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .nice()\n\n    if (reverse === true) scale.domain([maxValue, minValue])\n    else scale.domain([minValue, maxValue])\n\n    const typedScale = scale as ScaleSymlog\n    typedScale.type = 'symlog'\n\n    return typedScale\n}\n","import uniq from 'lodash/uniq'\nimport uniqBy from 'lodash/uniqBy'\nimport sortBy from 'lodash/sortBy'\nimport last from 'lodash/last'\nimport isDate from 'lodash/isDate'\nimport { createDateNormalizer } from './timeHelpers'\nimport { ScaleAxis, ScaleSpec, ScaleValue, SerieAxis, ComputedSerieAxis } from './types'\nimport { createLinearScale } from './linearScale'\nimport { createPointScale } from './pointScale'\nimport { createBandScale } from './bandScale'\nimport { createTimeScale } from './timeScale'\nimport { createLogScale } from './logScale'\nimport { createSymlogScale } from './symlogScale'\n\ntype XY = ReturnType<typeof generateSeriesXY>\n\ntype StackedXY = {\n    [K in keyof XY]: XY[K] & {\n        maxStacked: number\n        minStacked: number\n    }\n}\n\ninterface SerieDatum {\n    x: number | string | Date\n    // only numbers can be stacked\n    xStacked?: number | null\n    y: number | string | Date\n    // only numbers can be stacked\n    yStacked?: number | null\n}\n\ntype Serie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: D[]\n}\n\ntype NestedSerie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: {\n        data: D\n    }[]\n}\n\nexport type ComputedSerie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: {\n        data: D\n        position: {\n            x: number | null\n            y: number | null\n        }\n    }[]\n}\n\ntype Compare = <T>(a: T, b: T) => boolean\n\nexport const getOtherAxis = (axis: ScaleAxis): ScaleAxis => (axis === 'x' ? 'y' : 'x')\n\nexport const compareValues = (a: string | number, b: string | number) => a === b\nexport const compareDateValues = (a: Date, b: Date) => a.getTime() === b.getTime()\n\nexport function computeScale<Input extends ScaleValue>(\n    spec: ScaleSpec,\n    data: ComputedSerieAxis<any>,\n    size: number,\n    axis: ScaleAxis\n) {\n    switch (spec.type) {\n        case 'linear':\n            return createLinearScale(spec, data, size, axis)\n        case 'point':\n            return createPointScale<Input>(spec, data, size)\n        case 'band':\n            return createBandScale<Input>(spec, data, size, axis)\n        case 'time':\n            return createTimeScale(spec, data, size)\n        case 'log':\n            return createLogScale(spec, data, size, axis)\n        case 'symlog':\n            return createSymlogScale(spec, data, size, axis)\n        default:\n            throw new Error('invalid scale spec')\n    }\n}\n\n/**\n * Convert serie data to have the original data stored in a nested prop.\n *\n * We do this in order to avoid conflicts between raw & computed properties.\n * <- { data: { x: 1, y: 3 }[] }\n * -> { data: { data: { x: 1, y: 3 } }[] }\n */\nconst nestSerieData = <S = never, D extends SerieDatum = SerieDatum>(\n    serie: Serie<S, D>\n): NestedSerie<S, D> => ({\n    ...serie,\n    data: serie.data.map(d => ({ data: { ...d } })),\n})\n\nconst getDatumAxisPosition = <D extends SerieDatum = SerieDatum>(\n    datum: { data: D },\n    axis: ScaleAxis,\n    scale: any\n): number | null => {\n    if ('stacked' in scale && scale.stacked) {\n        const stackedValue = datum.data[axis === 'x' ? 'xStacked' : 'yStacked']\n        if (stackedValue === null || stackedValue === undefined) {\n            return null\n        }\n\n        return scale(stackedValue)\n    }\n\n    return scale(datum.data[axis]) ?? null\n}\n\n/**\n * Compute x/y d3 scales from an array of data series, and scale specifications.\n *\n * We use generics as it's not uncommon to have extra properties such as an id\n * added to the series, or extra props on data, in such case, you should override\n * the default types.\n */\nexport const computeXYScalesForSeries = <S = never, D extends SerieDatum = SerieDatum>(\n    series: Serie<S, D>[],\n    xScaleSpec: ScaleSpec,\n    yScaleSpec: ScaleSpec,\n    width: number,\n    height: number\n) => {\n    // first nest series to avoid property conflicts\n    const nestedSeries = series.map(serie => nestSerieData<S, D>(serie))\n\n    // then compute data for each axis: all, min, max values\n    const xy = generateSeriesXY<S, D>(nestedSeries, xScaleSpec, yScaleSpec)\n\n    // stack x values depending on xScale\n    if ('stacked' in xScaleSpec && xScaleSpec.stacked === true) {\n        stackX<S, D>(xy as StackedXY, nestedSeries)\n    }\n\n    // stack y values depending on yScale\n    if ('stacked' in yScaleSpec && yScaleSpec.stacked === true) {\n        stackY<S, D>(xy as StackedXY, nestedSeries)\n    }\n\n    // computes scales\n    const xScale = computeScale<D['x']>(xScaleSpec, xy.x, width, 'x')\n    const yScale = computeScale<D['y']>(yScaleSpec, xy.y, height, 'y')\n\n    // assign position to each datum in every scale\n    const computedSeries: ComputedSerie<S, D>[] = nestedSeries.map(serie => ({\n        ...serie,\n        data: serie.data.map(datum => ({\n            ...datum,\n            position: {\n                x: getDatumAxisPosition(datum, 'x', xScale),\n                y: getDatumAxisPosition(datum, 'y', yScale),\n            },\n        })),\n    }))\n\n    return {\n        ...xy,\n        series: computedSeries,\n        xScale,\n        yScale,\n    }\n}\n\nexport const generateSeriesXY = <S = never, D extends SerieDatum = SerieDatum>(\n    series: NestedSerie<S, D>[],\n    xScaleSpec: ScaleSpec,\n    yScaleSpec: ScaleSpec\n) => ({\n    x: generateSeriesAxis<'x', D['x']>(series, 'x', xScaleSpec),\n    y: generateSeriesAxis<'y', D['y']>(series, 'y', yScaleSpec),\n})\n\n/**\n * Normalize data according to scale type, (time => Date, linear => Number)\n * compute sorted unique values and min/max.\n */\nexport const generateSeriesAxis = <Axis extends ScaleAxis, Value extends ScaleValue>(\n    series: SerieAxis<Axis, Value>,\n    axis: Axis,\n    scaleSpec: ScaleSpec,\n    {\n        getValue = d => d.data[axis],\n        setValue = (d, v) => {\n            d.data[axis] = v\n        },\n    }: {\n        getValue?: (d: { data: Record<Axis, Value | null> }) => Value | null\n        setValue?: (d: { data: Record<Axis, Value | null> }, v: Value) => void\n    } = {}\n) => {\n    if (scaleSpec.type === 'linear') {\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                const value = getValue(d)\n\n                if (value) {\n                    setValue(d, parseFloat(String(value)) as unknown as Value)\n                }\n            })\n        })\n    } else if (scaleSpec.type === 'time' && scaleSpec.format !== 'native') {\n        // `native` means we already have Date instances,\n        // otherwise we have to convert the values to Date.\n        const parseTime = createDateNormalizer(scaleSpec)\n\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                const value = getValue(d)\n\n                if (value) {\n                    setValue(d, parseTime(value as Date) as unknown as Value)\n                }\n            })\n        })\n    }\n\n    const values: unknown[] = []\n\n    series.forEach(serie => {\n        serie.data.forEach(d => {\n            values.push(getValue(d))\n        })\n    })\n\n    switch (scaleSpec.type) {\n        case 'linear': {\n            const all = sortBy(\n                // filer null values to deal with holes in linechart\n                uniq(values as number[]).filter(v => v !== null),\n                v => v\n            )\n\n            return { all, min: Math.min(...all), max: Math.max(...all) }\n        }\n        case 'time': {\n            const all = uniqBy(values as Date[], v => v.getTime())\n                .slice(0)\n                .sort((a, b) => b.getTime() - a.getTime())\n                .reverse()\n\n            return { all, min: all[0], max: last(all) }\n        }\n        default: {\n            const all = uniq(values)\n\n            return { all, min: all[0], max: last(all) }\n        }\n    }\n}\n\nexport const stackAxis = <S = never, D extends SerieDatum = SerieDatum>(\n    axis: ScaleAxis,\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => {\n    const otherAxis = getOtherAxis(axis)\n    const all: number[] = []\n\n    xy[otherAxis].all.forEach(v => {\n        const compare = (isDate(v) ? compareDateValues : compareValues) as Compare\n        const stack: Array<number | null> = []\n\n        series.forEach(serie => {\n            const datum = serie.data.find(d => compare(d.data[otherAxis], v))\n            let value = null\n            let stackValue = null\n\n            if (datum !== undefined) {\n                // stacked values only support numbers\n                value = datum.data[axis] as number\n                if (value !== null) {\n                    const head = last(stack)\n                    if (head === undefined) {\n                        stackValue = value\n                    } else if (head !== null) {\n                        stackValue = head + value\n                    }\n                }\n\n                datum.data[axis === 'x' ? 'xStacked' : 'yStacked'] = stackValue\n            }\n\n            stack.push(stackValue)\n\n            if (stackValue !== null) {\n                all.push(stackValue)\n            }\n        })\n    })\n\n    xy[axis].minStacked = Math.min(...all)\n    xy[axis].maxStacked = Math.max(...all)\n}\n\nconst stackX = <S = never, D extends SerieDatum = SerieDatum>(\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => stackAxis<S, D>('x', xy, series)\n\nconst stackY = <S = never, D extends SerieDatum = SerieDatum>(\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => stackAxis<S, D>('y', xy, series)\n","import {\n    CountableTimeInterval,\n    timeMillisecond,\n    utcMillisecond,\n    timeSecond,\n    utcSecond,\n    timeMinute,\n    utcMinute,\n    timeHour,\n    utcHour,\n    timeWeek,\n    utcWeek,\n    timeSunday,\n    utcSunday,\n    timeMonday,\n    utcMonday,\n    timeTuesday,\n    utcTuesday,\n    timeWednesday,\n    utcWednesday,\n    timeThursday,\n    utcThursday,\n    timeFriday,\n    utcFriday,\n    timeSaturday,\n    utcSaturday,\n    timeMonth,\n    utcMonth,\n    timeYear,\n    utcYear,\n    timeInterval,\n} from 'd3-time'\nimport { ScaleValue, TicksSpec, AnyScale, ScaleWithBandwidth } from './types'\n\nexport const centerScale = <Value>(scale: ScaleWithBandwidth) => {\n    const bandwidth = scale.bandwidth()\n\n    if (bandwidth === 0) return scale\n\n    let offset = bandwidth / 2\n    if (scale.round()) {\n        offset = Math.round(offset)\n    }\n\n    return <T extends Value>(d: T) => (scale(d) ?? 0) + offset\n}\n\nconst timeDay = timeInterval(\n    date => date.setHours(0, 0, 0, 0),\n    (date, step) => date.setDate(date.getDate() + step),\n    (start, end) => (end.getTime() - start.getTime()) / 864e5,\n    date => Math.floor(date.getTime() / 864e5)\n)\n\nconst utcDay = timeInterval(\n    date => date.setUTCHours(0, 0, 0, 0),\n    (date, step) => date.setUTCDate(date.getUTCDate() + step),\n    (start, end) => (end.getTime() - start.getTime()) / 864e5,\n    date => Math.floor(date.getTime() / 864e5)\n)\n\nconst timeByType: Record<string, [CountableTimeInterval, CountableTimeInterval]> = {\n    millisecond: [timeMillisecond, utcMillisecond],\n    second: [timeSecond, utcSecond],\n    minute: [timeMinute, utcMinute],\n    hour: [timeHour, utcHour],\n    day: [timeDay, utcDay],\n    week: [timeWeek, utcWeek],\n    sunday: [timeSunday, utcSunday],\n    monday: [timeMonday, utcMonday],\n    tuesday: [timeTuesday, utcTuesday],\n    wednesday: [timeWednesday, utcWednesday],\n    thursday: [timeThursday, utcThursday],\n    friday: [timeFriday, utcFriday],\n    saturday: [timeSaturday, utcSaturday],\n    month: [timeMonth, utcMonth],\n    year: [timeYear, utcYear],\n}\n\nconst timeTypes = Object.keys(timeByType)\nconst timeIntervalRegexp = new RegExp(`^every\\\\s*(\\\\d+)?\\\\s*(${timeTypes.join('|')})s?$`, 'i')\n\nconst isInteger = (value: unknown): value is number =>\n    typeof value === 'number' && isFinite(value) && Math.floor(value) === value\n\nexport const getScaleTicks = <Value extends ScaleValue>(\n    scale: AnyScale,\n    spec?: TicksSpec<Value>\n) => {\n    // specific values\n    if (Array.isArray(spec)) {\n        return spec\n    }\n\n    if (typeof spec === 'string' && 'useUTC' in scale) {\n        // time interval\n        const matches = spec.match(timeIntervalRegexp)\n\n        if (matches) {\n            const [, amount, type] = matches\n            // UTC is used as it's more predictable\n            // however local time could be used too\n            // let's see how it fits users' requirements\n            const timeType = timeByType[type][scale.useUTC ? 1 : 0]\n\n            if (type === 'day') {\n                const [start, originalStop] = scale.domain()\n                const stop = new Date(originalStop)\n\n                // Set range to include last day in the domain since `interval.range` function is exclusive stop\n                stop.setDate(stop.getDate() + 1)\n\n                return timeType.every(Number(amount ?? 1))?.range(start, stop) ?? []\n            }\n\n            if (amount === undefined) {\n                return scale.ticks(timeType)\n            }\n\n            const interval = timeType.every(Number(amount))\n\n            if (interval) {\n                return scale.ticks(interval)\n            }\n        }\n\n        throw new Error(`Invalid tickValues: ${spec}`)\n    }\n\n    // continuous scales\n    if ('ticks' in scale) {\n        // default behaviour\n        if (spec === undefined) {\n            return scale.ticks()\n        }\n\n        // specific tick count\n        if (isInteger(spec)) {\n            return scale.ticks(spec)\n        }\n    }\n\n    // non linear scale default\n    return scale.domain()\n}\n"],"names":["timePrecisions","precisionCutOffs","date","setMilliseconds","setSeconds","setMinutes","setHours","setDate","setMonth","precisionCutOffsByType","millisecond","second","slice","minute","hour","day","month","year","createPrecisionMethod","precision","forEach","cutOff","createDateNormalizer","_ref","_ref$format","format","_ref$precision","_ref$useUTC","useUTC","precisionFn","value","undefined","Date","parseTime","utcParse","timeParse","createLinearScale","data","size","axis","minValue","_data$minStacked","maxValue","_data$maxStacked","_ref$min","min","_ref$max","max","_ref$stacked","stacked","_ref$reverse","reverse","_ref$clamp","clamp","_ref$nice","nice","minStacked","maxStacked","scale","scaleLinear","rangeRound","domain","castLinearScale","typedScale","type","createPointScale","_spec","scalePoint","range","all","castPointScale","createBandScale","_ref$round","round","scaleBand","castBandScale","createTimeScale","normalize","scaleUtc","scaleTime","createLogScale","sign","_ref$base","base","some","v","Error","hasMixedSign","filter","Math","scaleLog","createSymlogScale","_ref$constant","constant","scaleSymlog","getOtherAxis","compareValues","a","b","compareDateValues","getTime","computeScale","spec","getDatumAxisPosition","datum","_scale","stackedValue","computeXYScalesForSeries","series","xScaleSpec","yScaleSpec","width","height","nestedSeries","map","serie","_extends","d","nestSerieData","xy","generateSeriesXY","stackX","stackY","xScale","x","yScale","y","computedSeries","position","generateSeriesAxis","scaleSpec","_temp","_ref$getValue","getValue","_ref$setValue","setValue","parseFloat","String","values","push","sortBy","uniq","apply","uniqBy","sort","last","stackAxis","otherAxis","compare","isDate","stack","find","stackValue","head","centerScale","bandwidth","offset","timeByType","timeMillisecond","utcMillisecond","timeSecond","utcSecond","timeMinute","utcMinute","timeHour","utcHour","timeInterval","step","getDate","start","end","floor","setUTCHours","setUTCDate","getUTCDate","week","timeWeek","utcWeek","sunday","timeSunday","utcSunday","monday","timeMonday","utcMonday","tuesday","timeTuesday","utcTuesday","wednesday","timeWednesday","utcWednesday","thursday","timeThursday","utcThursday","friday","timeFriday","utcFriday","saturday","timeSaturday","utcSaturday","timeMonth","utcMonth","timeYear","utcYear","timeTypes","Object","keys","timeIntervalRegexp","RegExp","join","getScaleTicks","Array","isArray","matches","match","amount","timeType","_timeType$every$range","_timeType$every","_scale$domain","originalStop","stop","every","Number","ticks","interval","isFinite"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"nivo-scales.es.js","sources":["../src/timeHelpers.ts","../src/linearScale.ts","../src/pointScale.ts","../src/bandScale.ts","../src/timeScale.ts","../src/logScale.ts","../src/symlogScale.ts","../src/compute.ts","../src/ticks.ts"],"sourcesContent":["import { timeParse, utcParse } from 'd3-time-format'\n\nexport const timePrecisions = [\n    'millisecond',\n    'second',\n    'minute',\n    'hour',\n    'day',\n    'month',\n    'year',\n] as const\n\nexport type TIME_PRECISION = (typeof timePrecisions)[number]\n\nexport const precisionCutOffs: ((date: Date) => void)[] = [\n    date => date.setMilliseconds(0),\n    date => date.setSeconds(0),\n    date => date.setMinutes(0),\n    date => date.setHours(0),\n    date => date.setDate(1),\n    date => date.setMonth(0),\n]\n\nexport const precisionCutOffsByType: Record<TIME_PRECISION, ((date: Date) => void)[]> = {\n    millisecond: [],\n    second: precisionCutOffs.slice(0, 1),\n    minute: precisionCutOffs.slice(0, 2),\n    hour: precisionCutOffs.slice(0, 3),\n    day: precisionCutOffs.slice(0, 4),\n    month: precisionCutOffs.slice(0, 5),\n    year: precisionCutOffs.slice(0, 6),\n}\n\nexport const createPrecisionMethod = (precision: TIME_PRECISION) => (date: Date) => {\n    precisionCutOffsByType[precision].forEach(cutOff => {\n        cutOff(date)\n    })\n\n    return date\n}\n\nexport const createDateNormalizer = ({\n    format = 'native',\n    precision = 'millisecond',\n    useUTC = true,\n}: {\n    format?: 'native' | string\n    precision?: TIME_PRECISION\n    useUTC?: boolean\n}) => {\n    const precisionFn = createPrecisionMethod(precision)\n\n    return (value: Date | string | undefined) => {\n        if (value === undefined) {\n            return value\n        }\n\n        if (format === 'native' || value instanceof Date) {\n            return precisionFn(value as Date)\n        }\n\n        const parseTime = useUTC ? utcParse(format) : timeParse(format)\n        return precisionFn(parseTime(value as string) as Date)\n    }\n}\n","import { NumberValue, scaleLinear, ScaleLinear as D3ScaleLinear } from 'd3-scale'\nimport { ScaleLinearSpec, ScaleLinear, ComputedSerieAxis, ScaleAxis } from './types'\n\nexport const createLinearScale = <Output extends NumberValue>(\n    {\n        min = 0,\n        max = 'auto',\n        stacked = false,\n        reverse = false,\n        clamp = false,\n        nice = false,\n    }: ScaleLinearSpec,\n    data: ComputedSerieAxis<Output>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    let minValue: NumberValue\n    if (min === 'auto') {\n        minValue = stacked === true ? data.minStacked ?? 0 : data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: NumberValue\n    if (max === 'auto') {\n        maxValue = stacked === true ? data.maxStacked ?? 0 : data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleLinear<number, Output>()\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .domain(reverse ? [maxValue, minValue] : [minValue, maxValue])\n        .clamp(clamp)\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'number') scale.nice(nice)\n\n    return castLinearScale<number, Output>(scale, stacked)\n}\n\nexport const castLinearScale = <Range, Output>(\n    scale: D3ScaleLinear<Range, Output>,\n    stacked = false\n) => {\n    const typedScale = scale as unknown as ScaleLinear<number>\n    typedScale.type = 'linear'\n    typedScale.stacked = stacked\n\n    return typedScale\n}\n","import { scalePoint, ScalePoint as D3ScalePoint } from 'd3-scale'\nimport { ComputedSerieAxis, ScalePoint, ScalePointSpec, StringValue } from './types'\n\nexport const createPointScale = <Input extends StringValue>(\n    _spec: ScalePointSpec,\n    data: ComputedSerieAxis<Input>,\n    size: number\n) => {\n    const scale = scalePoint<Input>().range([0, size]).domain(data.all)\n\n    const typedScale = scale as ScalePoint<Input>\n    typedScale.type = 'point'\n\n    return typedScale\n}\n\nexport const castPointScale = <Input extends StringValue>(scale: D3ScalePoint<Input>) => {\n    const typedScale = scale as ScalePoint<Input>\n    typedScale.type = 'point'\n\n    return typedScale\n}\n","import { scaleBand, ScaleBand as D3ScaleBand } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleBand, ScaleBandSpec, StringValue, ScaleAxis } from './types'\n\nexport const createBandScale = <Input extends StringValue>(\n    { round = true }: ScaleBandSpec,\n    data: ComputedSerieAxis<Input>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    const scale = scaleBand<Input>()\n        .range(axis === 'x' ? [0, size] : [size, 0])\n        .domain(data.all)\n        .round(round)\n\n    return castBandScale<Input>(scale)\n}\n\nexport const castBandScale = <Input extends StringValue>(scale: D3ScaleBand<Input>) => {\n    const typedScale = scale as ScaleBand<Input>\n    typedScale.type = 'band'\n\n    return typedScale\n}\n","import { NumberValue, scaleTime, scaleUtc } from 'd3-scale'\nimport { createDateNormalizer } from './timeHelpers'\nimport { ComputedSerieAxis, ScaleTime, ScaleTimeSpec } from './types'\n\nexport const createTimeScale = <Input extends Date | NumberValue>(\n    {\n        format = 'native',\n        precision = 'millisecond',\n        min = 'auto',\n        max = 'auto',\n        useUTC = true,\n        nice = false,\n    }: ScaleTimeSpec,\n    data: ComputedSerieAxis<string | Date>,\n    size: number\n) => {\n    const normalize = createDateNormalizer({ format, precision, useUTC })\n\n    let minValue: Date | undefined\n    if (min === 'auto') {\n        minValue = normalize(data.min)\n    } else if (format !== 'native') {\n        minValue = normalize(min)\n    } else {\n        minValue = min as Date\n    }\n\n    let maxValue: Date | undefined\n    if (max === 'auto') {\n        maxValue = normalize(data.max)\n    } else if (format !== 'native') {\n        maxValue = normalize(max)\n    } else {\n        maxValue = max as Date\n    }\n\n    const scale = useUTC ? scaleUtc() : scaleTime()\n\n    scale.range([0, size])\n\n    if (minValue && maxValue) scale.domain([minValue, maxValue])\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'object' || typeof nice === 'number') scale.nice(nice)\n\n    const typedScale = scale as unknown as ScaleTime<Input>\n\n    typedScale.type = 'time'\n    typedScale.useUTC = useUTC\n\n    return typedScale\n}\n","import { scaleLog } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleAxis, ScaleLog, ScaleLogSpec } from './types'\n\nexport const createLogScale = (\n    { base = 10, min = 'auto', max = 'auto', nice = false }: ScaleLogSpec,\n    data: ComputedSerieAxis<number>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    const hasZero = data.all.some(v => v === 0)\n    if (hasZero) {\n        throw new Error(`a log scale domain must not include or cross zero`)\n    }\n\n    let sign: number\n    let hasMixedSign = false\n    data.all\n        .filter(v => v != null)\n        .forEach(v => {\n            if (hasMixedSign) return\n            if (sign === undefined) {\n                sign = Math.sign(v)\n            } else if (Math.sign(v) !== sign) {\n                hasMixedSign = true\n            }\n        })\n\n    if (hasMixedSign) {\n        throw new Error(`a log scale domain must be strictly-positive or strictly-negative`)\n    }\n\n    let minValue: number\n    if (min === 'auto') {\n        minValue = data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: number\n    if (max === 'auto') {\n        maxValue = data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleLog<number, number>()\n        .domain([minValue, maxValue])\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .base(base)\n\n    const typedScale = (nice ? scale.nice() : scale) as ScaleLog\n    typedScale.type = 'log'\n\n    return typedScale\n}\n","import { scaleSymlog } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleAxis, ScaleSymlog, ScaleSymlogSpec } from './types'\n\nexport const createSymlogScale = (\n    { constant = 1, min = 'auto', max = 'auto', reverse = false }: ScaleSymlogSpec,\n    data: ComputedSerieAxis<number>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    let minValue: number\n    if (min === 'auto') {\n        minValue = data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: number\n    if (max === 'auto') {\n        maxValue = data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleSymlog<number, number>()\n        .constant(constant)\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .nice()\n\n    if (reverse === true) scale.domain([maxValue, minValue])\n    else scale.domain([minValue, maxValue])\n\n    const typedScale = scale as ScaleSymlog\n    typedScale.type = 'symlog'\n\n    return typedScale\n}\n","import uniq from 'lodash/uniq'\nimport uniqBy from 'lodash/uniqBy'\nimport sortBy from 'lodash/sortBy'\nimport last from 'lodash/last'\nimport isDate from 'lodash/isDate'\nimport { createDateNormalizer } from './timeHelpers'\nimport { ScaleAxis, ScaleSpec, ScaleValue, SerieAxis, ComputedSerieAxis } from './types'\nimport { createLinearScale } from './linearScale'\nimport { createPointScale } from './pointScale'\nimport { createBandScale } from './bandScale'\nimport { createTimeScale } from './timeScale'\nimport { createLogScale } from './logScale'\nimport { createSymlogScale } from './symlogScale'\n\ntype XY = ReturnType<typeof generateSeriesXY>\n\ntype StackedXY = {\n    [K in keyof XY]: XY[K] & {\n        maxStacked: number\n        minStacked: number\n    }\n}\n\ninterface SerieDatum {\n    x: number | string | Date\n    // only numbers can be stacked\n    xStacked?: number | null\n    y: number | string | Date\n    // only numbers can be stacked\n    yStacked?: number | null\n}\n\ntype Serie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: D[]\n}\n\ntype NestedSerie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: {\n        data: D\n    }[]\n}\n\nexport type ComputedSerie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: {\n        data: D\n        position: {\n            x: number | null\n            y: number | null\n        }\n    }[]\n}\n\ntype Compare = <T>(a: T, b: T) => boolean\n\nexport const getOtherAxis = (axis: ScaleAxis): ScaleAxis => (axis === 'x' ? 'y' : 'x')\n\nexport const compareValues = (a: string | number, b: string | number) => a === b\nexport const compareDateValues = (a: Date, b: Date) => a.getTime() === b.getTime()\n\nexport function computeScale<Input extends ScaleValue>(\n    spec: ScaleSpec,\n    data: ComputedSerieAxis<any>,\n    size: number,\n    axis: ScaleAxis\n) {\n    switch (spec.type) {\n        case 'linear':\n            return createLinearScale(spec, data, size, axis)\n        case 'point':\n            return createPointScale<Input>(spec, data, size)\n        case 'band':\n            return createBandScale<Input>(spec, data, size, axis)\n        case 'time':\n            return createTimeScale(spec, data, size)\n        case 'log':\n            return createLogScale(spec, data, size, axis)\n        case 'symlog':\n            return createSymlogScale(spec, data, size, axis)\n        default:\n            throw new Error('invalid scale spec')\n    }\n}\n\n/**\n * Convert serie data to have the original data stored in a nested prop.\n *\n * We do this in order to avoid conflicts between raw & computed properties.\n * <- { data: { x: 1, y: 3 }[] }\n * -> { data: { data: { x: 1, y: 3 } }[] }\n */\nconst nestSerieData = <S = never, D extends SerieDatum = SerieDatum>(\n    serie: Serie<S, D>\n): NestedSerie<S, D> => ({\n    ...serie,\n    data: serie.data.map(d => ({ data: { ...d } })),\n})\n\nconst getDatumAxisPosition = <D extends SerieDatum = SerieDatum>(\n    datum: { data: D },\n    axis: ScaleAxis,\n    scale: any\n): number | null => {\n    if ('stacked' in scale && scale.stacked) {\n        const stackedValue = datum.data[axis === 'x' ? 'xStacked' : 'yStacked']\n        if (stackedValue === null || stackedValue === undefined) {\n            return null\n        }\n\n        return scale(stackedValue)\n    }\n\n    return scale(datum.data[axis]) ?? null\n}\n\n/**\n * Compute x/y d3 scales from an array of data series, and scale specifications.\n *\n * We use generics as it's not uncommon to have extra properties such as an id\n * added to the series, or extra props on data, in such case, you should override\n * the default types.\n */\nexport const computeXYScalesForSeries = <S = never, D extends SerieDatum = SerieDatum>(\n    series: Serie<S, D>[],\n    xScaleSpec: ScaleSpec,\n    yScaleSpec: ScaleSpec,\n    width: number,\n    height: number\n) => {\n    // first nest series to avoid property conflicts\n    const nestedSeries = series.map(serie => nestSerieData<S, D>(serie))\n\n    // then compute data for each axis: all, min, max values\n    const xy = generateSeriesXY<S, D>(nestedSeries, xScaleSpec, yScaleSpec)\n\n    // stack x values depending on xScale\n    if ('stacked' in xScaleSpec && xScaleSpec.stacked === true) {\n        stackX<S, D>(xy as StackedXY, nestedSeries)\n    }\n\n    // stack y values depending on yScale\n    if ('stacked' in yScaleSpec && yScaleSpec.stacked === true) {\n        stackY<S, D>(xy as StackedXY, nestedSeries)\n    }\n\n    // computes scales\n    const xScale = computeScale<D['x']>(xScaleSpec, xy.x, width, 'x')\n    const yScale = computeScale<D['y']>(yScaleSpec, xy.y, height, 'y')\n\n    // assign position to each datum in every scale\n    const computedSeries: ComputedSerie<S, D>[] = nestedSeries.map(serie => ({\n        ...serie,\n        data: serie.data.map(datum => ({\n            ...datum,\n            position: {\n                x: getDatumAxisPosition(datum, 'x', xScale),\n                y: getDatumAxisPosition(datum, 'y', yScale),\n            },\n        })),\n    }))\n\n    return {\n        ...xy,\n        series: computedSeries,\n        xScale,\n        yScale,\n    }\n}\n\nexport const generateSeriesXY = <S = never, D extends SerieDatum = SerieDatum>(\n    series: NestedSerie<S, D>[],\n    xScaleSpec: ScaleSpec,\n    yScaleSpec: ScaleSpec\n) => ({\n    x: generateSeriesAxis<'x', D['x']>(series, 'x', xScaleSpec),\n    y: generateSeriesAxis<'y', D['y']>(series, 'y', yScaleSpec),\n})\n\n/**\n * Normalize data according to scale type, (time => Date, linear => Number)\n * compute sorted unique values and min/max.\n */\nexport const generateSeriesAxis = <Axis extends ScaleAxis, Value extends ScaleValue>(\n    series: SerieAxis<Axis, Value>,\n    axis: Axis,\n    scaleSpec: ScaleSpec,\n    {\n        getValue = d => d.data[axis],\n        setValue = (d, v) => {\n            d.data[axis] = v\n        },\n    }: {\n        getValue?: (d: { data: Record<Axis, Value | null> }) => Value | null\n        setValue?: (d: { data: Record<Axis, Value | null> }, v: Value) => void\n    } = {}\n) => {\n    if (scaleSpec.type === 'linear') {\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                const value = getValue(d)\n\n                if (value) {\n                    setValue(d, parseFloat(String(value)) as unknown as Value)\n                }\n            })\n        })\n    } else if (scaleSpec.type === 'time' && scaleSpec.format !== 'native') {\n        // `native` means we already have Date instances,\n        // otherwise we have to convert the values to Date.\n        const parseTime = createDateNormalizer(scaleSpec)\n\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                const value = getValue(d)\n\n                if (value) {\n                    setValue(d, parseTime(value as Date) as unknown as Value)\n                }\n            })\n        })\n    }\n\n    const values: unknown[] = []\n\n    series.forEach(serie => {\n        serie.data.forEach(d => {\n            values.push(getValue(d))\n        })\n    })\n\n    switch (scaleSpec.type) {\n        case 'linear': {\n            const all = sortBy(\n                // filer null values to deal with holes in linechart\n                uniq(values as number[]).filter(v => v !== null),\n                v => v\n            )\n\n            return { all, min: Math.min(...all), max: Math.max(...all) }\n        }\n        case 'time': {\n            const all = uniqBy(values as Date[], v => v.getTime())\n                .slice(0)\n                .sort((a, b) => b.getTime() - a.getTime())\n                .reverse()\n\n            return { all, min: all[0], max: last(all) }\n        }\n        default: {\n            const all = uniq(values)\n\n            return { all, min: all[0], max: last(all) }\n        }\n    }\n}\n\nexport const stackAxis = <S = never, D extends SerieDatum = SerieDatum>(\n    axis: ScaleAxis,\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => {\n    const otherAxis = getOtherAxis(axis)\n    const all: number[] = []\n\n    xy[otherAxis].all.forEach(v => {\n        const compare = (isDate(v) ? compareDateValues : compareValues) as Compare\n        const stack: Array<number | null> = []\n\n        series.forEach(serie => {\n            const datum = serie.data.find(d => compare(d.data[otherAxis], v))\n            let value = null\n            let stackValue = null\n\n            if (datum !== undefined) {\n                // stacked values only support numbers\n                value = datum.data[axis] as number\n                if (value !== null) {\n                    const head = last(stack)\n                    if (head === undefined) {\n                        stackValue = value\n                    } else if (head !== null) {\n                        stackValue = head + value\n                    }\n                }\n\n                datum.data[axis === 'x' ? 'xStacked' : 'yStacked'] = stackValue\n            }\n\n            stack.push(stackValue)\n\n            if (stackValue !== null) {\n                all.push(stackValue)\n            }\n        })\n    })\n\n    xy[axis].minStacked = Math.min(...all)\n    xy[axis].maxStacked = Math.max(...all)\n}\n\nconst stackX = <S = never, D extends SerieDatum = SerieDatum>(\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => stackAxis<S, D>('x', xy, series)\n\nconst stackY = <S = never, D extends SerieDatum = SerieDatum>(\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => stackAxis<S, D>('y', xy, series)\n","import {\n    CountableTimeInterval,\n    timeMillisecond,\n    utcMillisecond,\n    timeSecond,\n    utcSecond,\n    timeMinute,\n    utcMinute,\n    timeHour,\n    utcHour,\n    timeWeek,\n    utcWeek,\n    timeSunday,\n    utcSunday,\n    timeMonday,\n    utcMonday,\n    timeTuesday,\n    utcTuesday,\n    timeWednesday,\n    utcWednesday,\n    timeThursday,\n    utcThursday,\n    timeFriday,\n    utcFriday,\n    timeSaturday,\n    utcSaturday,\n    timeMonth,\n    utcMonth,\n    timeYear,\n    utcYear,\n    timeInterval,\n} from 'd3-time'\nimport { ScaleValue, TicksSpec, AnyScale, ScaleWithBandwidth } from './types'\n\nexport const centerScale = <Value>(scale: ScaleWithBandwidth) => {\n    const bandwidth = scale.bandwidth()\n\n    if (bandwidth === 0) return scale\n\n    let offset = bandwidth / 2\n    if (scale.round()) {\n        offset = Math.round(offset)\n    }\n\n    return <T extends Value>(d: T) => (scale(d) ?? 0) + offset\n}\n\nconst timeDay = timeInterval(\n    date => date.setHours(0, 0, 0, 0),\n    (date, step) => date.setDate(date.getDate() + step),\n    (start, end) => (end.getTime() - start.getTime()) / 864e5,\n    date => Math.floor(date.getTime() / 864e5)\n)\n\nconst utcDay = timeInterval(\n    date => date.setUTCHours(0, 0, 0, 0),\n    (date, step) => date.setUTCDate(date.getUTCDate() + step),\n    (start, end) => (end.getTime() - start.getTime()) / 864e5,\n    date => Math.floor(date.getTime() / 864e5)\n)\n\nconst timeByType: Record<string, [CountableTimeInterval, CountableTimeInterval]> = {\n    millisecond: [timeMillisecond, utcMillisecond],\n    second: [timeSecond, utcSecond],\n    minute: [timeMinute, utcMinute],\n    hour: [timeHour, utcHour],\n    day: [timeDay, utcDay],\n    week: [timeWeek, utcWeek],\n    sunday: [timeSunday, utcSunday],\n    monday: [timeMonday, utcMonday],\n    tuesday: [timeTuesday, utcTuesday],\n    wednesday: [timeWednesday, utcWednesday],\n    thursday: [timeThursday, utcThursday],\n    friday: [timeFriday, utcFriday],\n    saturday: [timeSaturday, utcSaturday],\n    month: [timeMonth, utcMonth],\n    year: [timeYear, utcYear],\n}\n\nconst timeTypes = Object.keys(timeByType)\nconst timeIntervalRegexp = new RegExp(`^every\\\\s*(\\\\d+)?\\\\s*(${timeTypes.join('|')})s?$`, 'i')\n\nconst isInteger = (value: unknown): value is number =>\n    typeof value === 'number' && isFinite(value) && Math.floor(value) === value\n\nexport const getScaleTicks = <Value extends ScaleValue>(\n    scale: AnyScale,\n    spec?: TicksSpec<Value>\n) => {\n    // specific values\n    if (Array.isArray(spec)) {\n        return spec\n    }\n\n    if (typeof spec === 'string' && 'useUTC' in scale) {\n        // time interval\n        const matches = spec.match(timeIntervalRegexp)\n\n        if (matches) {\n            const [, amount, type] = matches\n            // UTC is used as it's more predictable\n            // however local time could be used too\n            // let's see how it fits users' requirements\n            const timeType = timeByType[type][scale.useUTC ? 1 : 0]\n\n            if (type === 'day') {\n                const [start, originalStop] = scale.domain()\n                const stop = new Date(originalStop)\n\n                // Set range to include last day in the domain since `interval.range` function is exclusive stop\n                stop.setDate(stop.getDate() + 1)\n\n                return timeType.every(Number(amount ?? 1))?.range(start, stop) ?? []\n            }\n\n            if (amount === undefined) {\n                return scale.ticks(timeType)\n            }\n\n            const interval = timeType.every(Number(amount))\n\n            if (interval) {\n                return scale.ticks(interval)\n            }\n        }\n\n        throw new Error(`Invalid tickValues: ${spec}`)\n    }\n\n    // continuous scales\n    if ('ticks' in scale) {\n        // default behaviour\n        if (spec === undefined) {\n            return scale.ticks()\n        }\n\n        // specific tick count\n        if (isInteger(spec)) {\n            return scale.ticks(spec)\n        }\n    }\n\n    // non linear scale default\n    return scale.domain()\n}\n"],"names":["timePrecisions","precisionCutOffs","date","setMilliseconds","setSeconds","setMinutes","setHours","setDate","setMonth","precisionCutOffsByType","millisecond","second","slice","minute","hour","day","month","year","createPrecisionMethod","precision","forEach","cutOff","createDateNormalizer","_ref","_ref$format","format","_ref$precision","_ref$useUTC","useUTC","precisionFn","value","undefined","Date","parseTime","utcParse","timeParse","createLinearScale","data","size","axis","minValue","_data$minStacked","maxValue","_data$maxStacked","_ref$min","min","_ref$max","max","_ref$stacked","stacked","_ref$reverse","reverse","_ref$clamp","clamp","_ref$nice","nice","minStacked","maxStacked","scale","scaleLinear","rangeRound","domain","castLinearScale","typedScale","type","createPointScale","_spec","scalePoint","range","all","castPointScale","createBandScale","_ref$round","round","scaleBand","castBandScale","createTimeScale","normalize","scaleUtc","scaleTime","createLogScale","sign","_ref$base","base","some","v","Error","hasMixedSign","filter","Math","scaleLog","createSymlogScale","_ref$constant","constant","scaleSymlog","getOtherAxis","compareValues","a","b","compareDateValues","getTime","computeScale","spec","getDatumAxisPosition","datum","_scale","stackedValue","computeXYScalesForSeries","series","xScaleSpec","yScaleSpec","width","height","nestedSeries","map","serie","_extends","d","nestSerieData","xy","generateSeriesXY","stackX","stackY","xScale","x","yScale","y","computedSeries","position","generateSeriesAxis","scaleSpec","_temp","_ref$getValue","getValue","_ref$setValue","setValue","parseFloat","String","values","push","sortBy","uniq","apply","uniqBy","sort","last","stackAxis","otherAxis","compare","isDate","stack","find","stackValue","head","centerScale","bandwidth","offset","timeByType","timeMillisecond","utcMillisecond","timeSecond","utcSecond","timeMinute","utcMinute","timeHour","utcHour","timeInterval","step","getDate","start","end","floor","setUTCHours","setUTCDate","getUTCDate","week","timeWeek","utcWeek","sunday","timeSunday","utcSunday","monday","timeMonday","utcMonday","tuesday","timeTuesday","utcTuesday","wednesday","timeWednesday","utcWednesday","thursday","timeThursday","utcThursday","friday","timeFriday","utcFriday","saturday","timeSaturday","utcSaturday","timeMonth","utcMonth","timeYear","utcYear","timeTypes","Object","keys","timeIntervalRegexp","RegExp","join","getScaleTicks","Array","isArray","matches","match","amount","timeType","_timeType$every$range","_timeType$every","_scale$domain","originalStop","stop","every","Number","ticks","interval","isFinite"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/tsconfig.tsbuildinfo b/dist/tsconfig.tsbuildinfo
new file mode 100644
index 0000000000000000000000000000000000000000..a9b418245c43dc680ecddf89a169c6c2122db30f
--- /dev/null
+++ b/dist/tsconfig.tsbuildinfo
@@ -0,0 +1 @@
+{"program":{"fileNames":["../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es5.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2015.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2016.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2017.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2018.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2019.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2020.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.dom.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.dom.iterable.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2015.core.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2015.collection.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2015.generator.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2015.iterable.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2015.promise.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2015.proxy.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2015.reflect.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2015.symbol.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2015.symbol.wellknown.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2016.array.include.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2017.object.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2017.sharedmemory.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2017.string.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2017.intl.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2017.typedarrays.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2018.asyncgenerator.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2018.asynciterable.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2018.intl.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2018.promise.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2018.regexp.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2019.array.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2019.object.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2019.string.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2019.symbol.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2019.intl.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2020.bigint.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2020.date.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2020.promise.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2020.sharedmemory.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2020.string.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2020.symbol.wellknown.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2020.intl.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.es2020.number.d.ts","../../../node_modules/.pnpm/typescript@4.9.5/node_modules/typescript/lib/lib.esnext.intl.d.ts","../../../node_modules/.pnpm/@types+react@18.2.0/node_modules/@types/react/ts5.0/global.d.ts","../../../node_modules/.pnpm/csstype@3.0.10/node_modules/csstype/index.d.ts","../../../node_modules/.pnpm/@types+prop-types@15.7.4/node_modules/@types/prop-types/index.d.ts","../../../node_modules/.pnpm/@types+scheduler@0.16.2/node_modules/@types/scheduler/tracing.d.ts","../../../node_modules/.pnpm/@types+react@18.2.0/node_modules/@types/react/ts5.0/index.d.ts","../../../node_modules/.pnpm/@types+react@18.2.0/node_modules/@types/react/ts5.0/jsx-runtime.d.ts","../../../node_modules/.pnpm/@types+d3-time@1.1.1/node_modules/@types/d3-time/index.d.ts","../../../node_modules/.pnpm/@types+d3-scale@4.0.8/node_modules/@types/d3-scale/index.d.ts","../../../node_modules/.pnpm/@types+d3-time-format@3.0.1/node_modules/@types/d3-time-format/index.d.ts","../src/timehelpers.ts","../src/types.ts","../src/bandscale.ts","../../../node_modules/.pnpm/@types+lodash@4.14.182/node_modules/@types/lodash/common/common.d.ts","../../../node_modules/.pnpm/@types+lodash@4.14.182/node_modules/@types/lodash/common/array.d.ts","../../../node_modules/.pnpm/@types+lodash@4.14.182/node_modules/@types/lodash/common/collection.d.ts","../../../node_modules/.pnpm/@types+lodash@4.14.182/node_modules/@types/lodash/common/date.d.ts","../../../node_modules/.pnpm/@types+lodash@4.14.182/node_modules/@types/lodash/common/function.d.ts","../../../node_modules/.pnpm/@types+lodash@4.14.182/node_modules/@types/lodash/common/lang.d.ts","../../../node_modules/.pnpm/@types+lodash@4.14.182/node_modules/@types/lodash/common/math.d.ts","../../../node_modules/.pnpm/@types+lodash@4.14.182/node_modules/@types/lodash/common/number.d.ts","../../../node_modules/.pnpm/@types+lodash@4.14.182/node_modules/@types/lodash/common/object.d.ts","../../../node_modules/.pnpm/@types+lodash@4.14.182/node_modules/@types/lodash/common/seq.d.ts","../../../node_modules/.pnpm/@types+lodash@4.14.182/node_modules/@types/lodash/common/string.d.ts","../../../node_modules/.pnpm/@types+lodash@4.14.182/node_modules/@types/lodash/common/util.d.ts","../../../node_modules/.pnpm/@types+lodash@4.14.182/node_modules/@types/lodash/index.d.ts","../../../node_modules/.pnpm/@types+lodash@4.14.182/node_modules/@types/lodash/uniq.d.ts","../../../node_modules/.pnpm/@types+lodash@4.14.182/node_modules/@types/lodash/uniqby.d.ts","../../../node_modules/.pnpm/@types+lodash@4.14.182/node_modules/@types/lodash/sortby.d.ts","../../../node_modules/.pnpm/@types+lodash@4.14.182/node_modules/@types/lodash/last.d.ts","../../../node_modules/.pnpm/@types+lodash@4.14.182/node_modules/@types/lodash/isdate.d.ts","../src/linearscale.ts","../src/pointscale.ts","../src/timescale.ts","../src/logscale.ts","../src/symlogscale.ts","../src/compute.ts","../src/ticks.ts","../src/index.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/assert.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/assert/strict.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/globals.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/async_hooks.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/buffer.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/child_process.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/cluster.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/console.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/constants.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/crypto.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/dgram.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/diagnostics_channel.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/dns.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/dns/promises.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/domain.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/events.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/fs.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/fs/promises.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/http.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/http2.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/https.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/inspector.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/module.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/net.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/os.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/path.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/perf_hooks.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/process.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/punycode.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/querystring.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/readline.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/repl.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/stream.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/stream/promises.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/stream/consumers.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/stream/web.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/string_decoder.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/timers.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/timers/promises.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/tls.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/trace_events.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/tty.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/url.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/util.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/v8.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/vm.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/wasi.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/worker_threads.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/zlib.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/globals.global.d.ts","../../../node_modules/.pnpm/@types+node@16.11.16/node_modules/@types/node/index.d.ts","../../../node_modules/.pnpm/@types+cheerio@0.22.30/node_modules/@types/cheerio/index.d.ts","../../../node_modules/.pnpm/@types+enzyme@3.10.10/node_modules/@types/enzyme/index.d.ts","../../../node_modules/.pnpm/@types+eslint@7.29.0/node_modules/@types/eslint/helpers.d.ts","../../../node_modules/.pnpm/@types+eslint@7.29.0/node_modules/@types/eslint/lib/rules/index.d.ts","../../../node_modules/.pnpm/@types+json-schema@7.0.11/node_modules/@types/json-schema/index.d.ts","../../../node_modules/.pnpm/@types+estree@1.0.1/node_modules/@types/estree/index.d.ts","../../../node_modules/.pnpm/@types+eslint@7.29.0/node_modules/@types/eslint/index.d.ts","../../../node_modules/.pnpm/@types+eslint-scope@3.7.4/node_modules/@types/eslint-scope/index.d.ts","../../../node_modules/.pnpm/jest-diff@27.4.2/node_modules/jest-diff/build/cleanupsemantic.d.ts","../../../node_modules/.pnpm/pretty-format@27.4.2/node_modules/pretty-format/build/types.d.ts","../../../node_modules/.pnpm/pretty-format@27.4.2/node_modules/pretty-format/build/index.d.ts","../../../node_modules/.pnpm/jest-diff@27.4.2/node_modules/jest-diff/build/types.d.ts","../../../node_modules/.pnpm/jest-diff@27.4.2/node_modules/jest-diff/build/difflines.d.ts","../../../node_modules/.pnpm/jest-diff@27.4.2/node_modules/jest-diff/build/printdiffs.d.ts","../../../node_modules/.pnpm/jest-diff@27.4.2/node_modules/jest-diff/build/index.d.ts","../../../node_modules/.pnpm/@types+jest@27.0.3/node_modules/@types/jest/index.d.ts","../../../node_modules/.pnpm/@types+prettier@2.4.2/node_modules/@types/prettier/index.d.ts","../../../node_modules/.pnpm/@types+react-dom@18.2.0/node_modules/@types/react-dom/index.d.ts","../../../node_modules/.pnpm/@types+react-test-renderer@18.0.0/node_modules/@types/react-test-renderer/index.d.ts"],"fileInfos":[{"version":"8730f4bf322026ff5229336391a18bcaa1f94d4f82416c8b2f3954e2ccaae2ba","affectsGlobalScope":true,"impliedFormat":1},{"version":"dc47c4fa66b9b9890cf076304de2a9c5201e94b740cffdf09f87296d877d71f6","impliedFormat":1},{"version":"7a387c58583dfca701b6c85e0adaf43fb17d590fb16d5b2dc0a2fbd89f35c467","impliedFormat":1},{"version":"8a12173c586e95f4433e0c6dc446bc88346be73ffe9ca6eec7aa63c8f3dca7f9","impliedFormat":1},{"version":"5f4e733ced4e129482ae2186aae29fde948ab7182844c3a5a51dd346182c7b06","impliedFormat":1},{"version":"4b421cbfb3a38a27c279dec1e9112c3d1da296f77a1a85ddadf7e7a425d45d18","impliedFormat":1},{"version":"1fc5ab7a764205c68fa10d381b08417795fc73111d6dd16b5b1ed36badb743d9","impliedFormat":1},{"version":"3aafcb693fe5b5c3bd277bd4c3a617b53db474fe498fc5df067c5603b1eebde7","affectsGlobalScope":true,"impliedFormat":1},{"version":"f3d4da15233e593eacb3965cde7960f3fddf5878528d882bcedd5cbaba0193c7","affectsGlobalScope":true,"impliedFormat":1},{"version":"adb996790133eb33b33aadb9c09f15c2c575e71fb57a62de8bf74dbf59ec7dfb","affectsGlobalScope":true,"impliedFormat":1},{"version":"8cc8c5a3bac513368b0157f3d8b31cfdcfe78b56d3724f30f80ed9715e404af8","affectsGlobalScope":true,"impliedFormat":1},{"version":"cdccba9a388c2ee3fd6ad4018c640a471a6c060e96f1232062223063b0a5ac6a","affectsGlobalScope":true,"impliedFormat":1},{"version":"c5c05907c02476e4bde6b7e76a79ffcd948aedd14b6a8f56e4674221b0417398","affectsGlobalScope":true,"impliedFormat":1},{"version":"5f406584aef28a331c36523df688ca3650288d14f39c5d2e555c95f0d2ff8f6f","affectsGlobalScope":true,"impliedFormat":1},{"version":"22f230e544b35349cfb3bd9110b6ef37b41c6d6c43c3314a31bd0d9652fcec72","affectsGlobalScope":true,"impliedFormat":1},{"version":"7ea0b55f6b315cf9ac2ad622b0a7813315bb6e97bf4bb3fbf8f8affbca7dc695","affectsGlobalScope":true,"impliedFormat":1},{"version":"3013574108c36fd3aaca79764002b3717da09725a36a6fc02eac386593110f93","affectsGlobalScope":true,"impliedFormat":1},{"version":"eb26de841c52236d8222f87e9e6a235332e0788af8c87a71e9e210314300410a","affectsGlobalScope":true,"impliedFormat":1},{"version":"3be5a1453daa63e031d266bf342f3943603873d890ab8b9ada95e22389389006","affectsGlobalScope":true,"impliedFormat":1},{"version":"17bb1fc99591b00515502d264fa55dc8370c45c5298f4a5c2083557dccba5a2a","affectsGlobalScope":true,"impliedFormat":1},{"version":"7ce9f0bde3307ca1f944119f6365f2d776d281a393b576a18a2f2893a2d75c98","affectsGlobalScope":true,"impliedFormat":1},{"version":"6a6b173e739a6a99629a8594bfb294cc7329bfb7b227f12e1f7c11bc163b8577","affectsGlobalScope":true,"impliedFormat":1},{"version":"81cac4cbc92c0c839c70f8ffb94eb61e2d32dc1c3cf6d95844ca099463cf37ea","affectsGlobalScope":true,"impliedFormat":1},{"version":"b0124885ef82641903d232172577f2ceb5d3e60aed4da1153bab4221e1f6dd4e","affectsGlobalScope":true,"impliedFormat":1},{"version":"0eb85d6c590b0d577919a79e0084fa1744c1beba6fd0d4e951432fa1ede5510a","affectsGlobalScope":true,"impliedFormat":1},{"version":"da233fc1c8a377ba9e0bed690a73c290d843c2c3d23a7bd7ec5cd3d7d73ba1e0","affectsGlobalScope":true,"impliedFormat":1},{"version":"d154ea5bb7f7f9001ed9153e876b2d5b8f5c2bb9ec02b3ae0d239ec769f1f2ae","affectsGlobalScope":true,"impliedFormat":1},{"version":"bb2d3fb05a1d2ffbca947cc7cbc95d23e1d053d6595391bd325deb265a18d36c","affectsGlobalScope":true,"impliedFormat":1},{"version":"c80df75850fea5caa2afe43b9949338ce4e2de086f91713e9af1a06f973872b8","affectsGlobalScope":true,"impliedFormat":1},{"version":"9d57b2b5d15838ed094aa9ff1299eecef40b190722eb619bac4616657a05f951","affectsGlobalScope":true,"impliedFormat":1},{"version":"6c51b5dd26a2c31dbf37f00cfc32b2aa6a92e19c995aefb5b97a3a64f1ac99de","affectsGlobalScope":true,"impliedFormat":1},{"version":"6e7997ef61de3132e4d4b2250e75343f487903ddf5370e7ce33cf1b9db9a63ed","affectsGlobalScope":true,"impliedFormat":1},{"version":"2ad234885a4240522efccd77de6c7d99eecf9b4de0914adb9a35c0c22433f993","affectsGlobalScope":true,"impliedFormat":1},{"version":"5e5e095c4470c8bab227dbbc61374878ecead104c74ab9960d3adcccfee23205","affectsGlobalScope":true,"impliedFormat":1},{"version":"09aa50414b80c023553090e2f53827f007a301bc34b0495bfb2c3c08ab9ad1eb","affectsGlobalScope":true,"impliedFormat":1},{"version":"d7f680a43f8cd12a6b6122c07c54ba40952b0c8aa140dcfcf32eb9e6cb028596","affectsGlobalScope":true,"impliedFormat":1},{"version":"3787b83e297de7c315d55d4a7c546ae28e5f6c0a361b7a1dcec1f1f50a54ef11","affectsGlobalScope":true,"impliedFormat":1},{"version":"e7e8e1d368290e9295ef18ca23f405cf40d5456fa9f20db6373a61ca45f75f40","affectsGlobalScope":true,"impliedFormat":1},{"version":"faf0221ae0465363c842ce6aa8a0cbda5d9296940a8e26c86e04cc4081eea21e","affectsGlobalScope":true,"impliedFormat":1},{"version":"06393d13ea207a1bfe08ec8d7be562549c5e2da8983f2ee074e00002629d1871","affectsGlobalScope":true,"impliedFormat":1},{"version":"2768ef564cfc0689a1b76106c421a2909bdff0acbe87da010785adab80efdd5c","affectsGlobalScope":true,"impliedFormat":1},{"version":"b248e32ca52e8f5571390a4142558ae4f203ae2f94d5bac38a3084d529ef4e58","affectsGlobalScope":true,"impliedFormat":1},{"version":"52d1bb7ab7a3306fd0375c8bff560feed26ed676a5b0457fa8027b563aecb9a4","affectsGlobalScope":true,"impliedFormat":1},{"version":"49a253ec027e56c55c7450a0c331cfe96212b3d1cc215b1710ba94a083404cf3","affectsGlobalScope":true,"impliedFormat":1},{"version":"381899b8d1d4c1be716f18cb5242ba39f66f4b1e31d45af62a32a99f8edcb39d","impliedFormat":1},{"version":"f7b46d22a307739c145e5fddf537818038fdfffd580d79ed717f4d4d37249380","impliedFormat":1},{"version":"f5a8b384f182b3851cec3596ccc96cb7464f8d3469f48c74bf2befb782a19de5","impliedFormat":1},{"version":"278fe30e638dad09488d130287c728f99f61cb315ed86b70c36040e4311f9cf5","affectsGlobalScope":true,"impliedFormat":1},{"version":"af7fd2870746deed40e130fc0a3966de74e8f52a97ec114d0fbb35876ab05ca9","impliedFormat":1},{"version":"420ab1af26cd5bbbdce787413bd70c26220ace1af828d8b8d88ad0a9f13d89d5","impliedFormat":1},{"version":"1ba55e9efbea1dcf7a6563969ff406de1a9a865cbbdaea2714f090fff163e2b5","impliedFormat":1},{"version":"68bb1cebc4ec3f0a3083d4ed22837fab5d38ea761810a4b831e492fabd0bce2f","impliedFormat":1},{"version":"05548ae042186c98dd5de1b9a071e82220d33d2f3c29907ef473ea7c83eb7a89","signature":"f0687fd2d9a57d4647556026fef7b82aac2ceb8247d4feb4302b1219fe923be5","impliedFormat":1},{"version":"8bb4c5cd611e1ae41037328dd8ecf5583ad2b4cf267d7863163b7a2c33b55750","signature":"f29627c69dc10a6b85a96b026f3f11ab89b5481ab8b48b2a94d1b54afb7a3d69","impliedFormat":1},{"version":"443f4f6d4ab7f136d075dc2ba3b8bbf9e7731cc330372d01cd9e3dcd5b704a4e","signature":"d3a353411e44e4b8796222587ecb06911baa1328e07dfd3613c7109ac6e5fe00","impliedFormat":1},{"version":"675e702f2032766a91eeadee64f51014c64688525da99dccd8178f0c599f13a8","impliedFormat":1},{"version":"fe4a2042d087990ebfc7dc0142d5aaf5a152e4baea86b45f283f103ec1e871ea","impliedFormat":1},{"version":"d70c026dd2eeaa974f430ea229230a1897fdb897dc74659deebe2afd4feeb08f","impliedFormat":1},{"version":"187119ff4f9553676a884e296089e131e8cc01691c546273b1d0089c3533ce42","impliedFormat":1},{"version":"febf0b2de54781102b00f61653b21377390a048fbf5262718c91860d11ff34a6","impliedFormat":1},{"version":"ca59fe42b81228a317812e95a2e72ccc8c7f1911b5f0c2a032adf41a0161ec5d","impliedFormat":1},{"version":"9364c7566b0be2f7b70ff5285eb34686f83ccb01bda529b82d23b2a844653bfb","impliedFormat":1},{"version":"00baffbe8a2f2e4875367479489b5d43b5fc1429ecb4a4cc98cfc3009095f52a","impliedFormat":1},{"version":"ae9930989ed57478eb03b9b80ad3efa7a3eacdfeff0f78ecf7894c4963a64f93","impliedFormat":1},{"version":"3c92b6dfd43cc1c2485d9eba5ff0b74a19bb8725b692773ef1d66dac48cda4bd","impliedFormat":1},{"version":"3e59f00ab03c33717b3130066d4debb272da90eeded4935ff0604c2bc25a5cae","impliedFormat":1},{"version":"df996e25faa505f85aeb294d15ebe61b399cf1d1e49959cdfaf2cc0815c203f9","impliedFormat":1},{"version":"f2eff8704452659641164876c1ef0df4174659ce7311b0665798ea3f556fa9ad","affectsGlobalScope":true,"impliedFormat":1},{"version":"2c705ed6e0913da9d7f85665a5f402043def9de30a1595a5cd78cba2ad0f1113","impliedFormat":1},{"version":"991aace368326d6418dfe58b9176461fb73c8a4ae996f148339f91b0f08b341c","impliedFormat":1},{"version":"5b164f09f2872a321760a406908ad71e06b7c07f58c9eb7f096f888e99c2bb70","impliedFormat":1},{"version":"970cb8e2e1dbad4059b3d6d1d57b96398af7d58bb47362bf92ca62c58ea1e663","impliedFormat":1},{"version":"6c19fbb6c5486e152f4ad0879dc09453e03166cdd3f076021727492753b82d28","impliedFormat":1},{"version":"fba6f7f2b4ddb71205f08c0a881f5d79ec4204a502aa9ba16413929ea711b40f","signature":"42e2a371a8e40b24a7cbd886c44ceff1ee38948425af932205d63d0ff60cd97c","impliedFormat":1},{"version":"2c89b8c37637ff8c82a6e9799a177b1c566bbcfc74778ae859d5294340ff8a5c","signature":"caa2e4975e4884c619da4a10e2f52d63d4ba49b300b6a231bc6b7e4629171ab0","impliedFormat":1},{"version":"027b273e440661e9e4cc153540ab5bc1ebb893272abe6e6892b8328ab5f6da44","signature":"cfe3375f2fe455a5a47b9d6ae3edecd65090d7f1dbf7b6c57bb7d233e44e6b14","impliedFormat":1},{"version":"dc5a40d4dbee2695c09484f2ede1c27fa4c26eea6a95942833abb201611e0522","signature":"d566d6622710a57d7029a5bd20454319cb6abadae0293434be7e55a5b6562f71","impliedFormat":1},{"version":"a93c1683b01a3618f765998805375b134fe03630d0093b358fe8641b4dabfd22","signature":"a7155c893a5ad4971bf25731fab4890e2fa0a9076872915216ffff6ffb34b117","impliedFormat":1},{"version":"80f4f279f2b64a58d3329709a9f2887ba628c7767c6c6e6efdaf79c9693afec2","signature":"9205441dd8d313dc7f68014ec9863f009ddf0da841016725d21e8d3cb0d8c207","impliedFormat":1},{"version":"aa2182b15e0001cd930f727ae68f545d63797a6826394b98ba1c458756e666a4","signature":"b708d8aa47b9ff6e11cc79cadcec4b78a852dacd440d24a9065fdd430434e8d0","impliedFormat":1},{"version":"d51261e91ef7e35889cf5e7800250433e02fe4efcd33e5697494592d7b717c97","signature":"15ba0c58a6694aeffbfb769df13bf1d35bd533183dfe3f9bc38ae8eaf9196457","impliedFormat":1},{"version":"0d5a2ee1fdfa82740e0103389b9efd6bfe145a20018a2da3c02b89666181f4d9","impliedFormat":1},{"version":"a69c09dbea52352f479d3e7ac949fde3d17b195abe90b045d619f747b38d6d1a","impliedFormat":1},{"version":"92d63add669d18ebc349efbacd88966d6f2ccdddfb1b880b2db98ae3aa7bf7c4","affectsGlobalScope":true,"impliedFormat":1},{"version":"ccc94049a9841fe47abe5baef6be9a38fc6228807974ae675fb15dc22531b4be","impliedFormat":1},{"version":"9acfe4d1ff027015151ce81d60797b04b52bffe97ad8310bb0ec2e8fd61e1303","affectsGlobalScope":true,"impliedFormat":1},{"version":"95843d5cfafced8f3f8a5ce57d2335f0bcd361b9483587d12a25e4bd403b8216","impliedFormat":1},{"version":"afc6e96061af46bcff47246158caee7e056f5288783f2d83d6858cd25be1c565","impliedFormat":1},{"version":"34f5bcac12b36d70304b73de5f5aab3bb91bd9919f984be80579ebcad03a624e","affectsGlobalScope":true,"impliedFormat":1},{"version":"82408ed3e959ddc60d3e9904481b5a8dc16469928257af22a3f7d1a3bc7fd8c4","impliedFormat":1},{"version":"2f520601649a893e6a49a8851ebfcf4be8ce090dc1281c2a08a871cb04e8251f","impliedFormat":1},{"version":"f50c975ab7b50e25a69e3d8a3773894125b44e9698924105f23b812bf7488baf","impliedFormat":1},{"version":"2b8c764f856a1dd0a9a2bf23e5efddbff157de8138b0754010be561ae5fcaa90","impliedFormat":1},{"version":"76650408392bf49a8fbf3e2b6b302712a92d76af77b06e2da1cc8077359c4409","impliedFormat":1},{"version":"0af3121e68297b2247dd331c0d24dba599e50736a7517a5622d5591aae4a3122","impliedFormat":1},{"version":"6972fca26f6e9bd56197568d4379f99071a90766e06b4fcb5920a0130a9202be","impliedFormat":1},{"version":"4a2628e95962c8ab756121faa3ac2ed348112ff7a87b5c286dd2cc3326546b4c","affectsGlobalScope":true,"impliedFormat":1},{"version":"80793b2277f31baa199234daed806fff0fb11491d1ebd3357e520c3558063f00","impliedFormat":1},{"version":"a049a59a02009fc023684fcfaf0ac526fe36c35dcc5d2b7d620c1750ba11b083","impliedFormat":1},{"version":"b9b963043551b034abd9e7c6d859f7a81d99479fde938d983114d167d0644a78","impliedFormat":1},{"version":"160cc6e3d06938535bc887754afe5798c22d81ce83a9792ebfe2371a70f2ffc2","impliedFormat":1},{"version":"4b9a003b5c556c96784132945bb41c655ea11273b1917f5c8d0c154dd5fd20dd","impliedFormat":1},{"version":"a458dc78104cc80048ac24fdc02fe6dce254838094c2f25641b3f954d9721241","impliedFormat":1},{"version":"e8b18c6385ff784228a6f369694fcf1a6b475355ba89090a88de13587a9391d5","affectsGlobalScope":true,"impliedFormat":1},{"version":"902cd98bf46e95caf4118a0733fb801e9e90eec3edaed6abdad77124afec9ca2","impliedFormat":1},{"version":"abc1c425b2ad6720433f40f1877abfa4223f0f3dd486c9c28c492179ca183cb6","impliedFormat":1},{"version":"945a841f9a591197154c85386bc5a1467d42d325104bb36db51bc566bbb240be","impliedFormat":1},{"version":"94eed4cc2f5f658d5e229ff1ccd38860bddf4233e347bf78edd2154dee1f2b99","impliedFormat":1},{"version":"bd1a08e30569b0fb2f0b21035eb9b039871f68faa9b98accf847e9c878c5e0a9","affectsGlobalScope":true,"impliedFormat":1},{"version":"9f1069b9e2c051737b1f9b4f1baf50e4a63385a6a89c32235549ae87fc3d5492","impliedFormat":1},{"version":"ee18f2da7a037c6ceeb112a084e485aead9ea166980bf433474559eac1b46553","impliedFormat":1},{"version":"29c2706fa0cc49a2bd90c83234da33d08bb9554ecec675e91c1f85087f5a5324","impliedFormat":1},{"version":"0acbf26bf958f9e80c1ffa587b74749d2697b75b484062d36e103c137c562bc3","impliedFormat":1},{"version":"d7838022c7dab596357a9604b9c6adffe37dc34085ce0779c958ce9545bd7139","impliedFormat":1},{"version":"1b952304137851e45bc009785de89ada562d9376177c97e37702e39e60c2f1ff","impliedFormat":1},{"version":"806ef4cac3b3d9fa4a48d849c8e084d7c72fcd7b16d76e06049a9ed742ff79c0","affectsGlobalScope":true,"impliedFormat":1},{"version":"a7971f9fb2a32ec7788ec6cda9d7a33c02023dfe9a62db2030ad1359649d8050","impliedFormat":1},{"version":"c33a6ea7147af60d8e98f1ac127047f4b0d4e2ce28b8f08ff3de07ca7cc00637","impliedFormat":1},{"version":"b42b47e17b8ece2424ae8039feb944c2e3ba4b262986aebd582e51efbdca93dc","affectsGlobalScope":true,"impliedFormat":1},{"version":"664d8f2d59164f2e08c543981453893bc7e003e4dfd29651ce09db13e9457980","impliedFormat":1},{"version":"2408611d9b4146e35d1dbd1f443ccd8e187c74614a54b80300728277529dbf11","impliedFormat":1},{"version":"998a3de5237518c0b3ac00a11b3b4417affb008aa20aedee52f3fdae3cb86151","impliedFormat":1},{"version":"ad41008ffe077206e1811fc873f4d9005b5fd7f6ab52bb6118fef600815a5cb4","impliedFormat":1},{"version":"d88ecca73348e7c337541c4b8b60a50aca5e87384f6b8a422fc6603c637e4c21","impliedFormat":1},{"version":"badae0df9a8016ac36994b0a0e7b82ba6aaa3528e175a8c3cb161e4683eec03e","impliedFormat":1},{"version":"c3db860bcaaaeb3bbc23f353bbda1f8ab82756c8d5e973bebb3953cb09ea68f2","impliedFormat":1},{"version":"235a53595bd20b0b0eeb1a29cb2887c67c48375e92f03749b2488fbd46d0b1a0","impliedFormat":1},{"version":"bc09393cd4cd13f69cf1366d4236fbae5359bb550f0de4e15767e9a91d63dfb1","impliedFormat":1},{"version":"9c266243b01545e11d2733a55ad02b4c00ecdbda99c561cd1674f96e89cdc958","impliedFormat":1},{"version":"c71155c05fc76ff948a4759abc1cb9feec036509f500174bc18dad4c7827a60c","impliedFormat":1},{"version":"ab9b9a36e5284fd8d3bf2f7d5fcbc60052f25f27e4d20954782099282c60d23e","affectsGlobalScope":true,"impliedFormat":1},{"version":"1cdb8f094b969dcc183745dc88404e2d8fcf2a858c6e7cc2441011476573238e","impliedFormat":1},{"version":"42c1b00421aa4d5f03b85a2639c1573d32bd82533f34423bbf1f5fb2b0ddc4d8","affectsGlobalScope":true,"impliedFormat":1},{"version":"c2b9c0122f9f30404c0494867314201c1e82283f3780fc7e4064c54d6e3bb4ec","impliedFormat":1},{"version":"64d4b35c5456adf258d2cf56c341e203a073253f229ef3208fc0d5020253b241","affectsGlobalScope":true,"impliedFormat":1},{"version":"0133ebdd17a823ae56861948870cde4dac18dd8818ab641039c85bbb720429e0","impliedFormat":1},{"version":"f3e604694b624fa3f83f6684185452992088f5efb2cf136b62474aa106d6f1b6","impliedFormat":1},{"version":"bee89e1eb6425eb49894f3f25e4562dc2564e84e5aa7610b7e13d8ecddf8f5db","impliedFormat":1},{"version":"874d84ca5699231d5af2868fef01fc63f948bd83be928881479db48508f92ca0","impliedFormat":1},{"version":"e050a0afcdbb269720a900c85076d18e0c1ab73e580202a2bf6964978181222a","impliedFormat":1},{"version":"d8aab31ba8e618cc3eea10b0945de81cb93b7e8150a013a482332263b9305322","impliedFormat":1},{"version":"462bccdf75fcafc1ae8c30400c9425e1a4681db5d605d1a0edb4f990a54d8094","impliedFormat":1},{"version":"5923d8facbac6ecf7c84739a5c701a57af94a6f6648d6229a6c768cf28f0f8cb","impliedFormat":1},{"version":"7adecb2c3238794c378d336a8182d4c3dd2c4fa6fa1785e2797a3db550edea62","impliedFormat":1},{"version":"dc12dc0e5aa06f4e1a7692149b78f89116af823b9e1f1e4eae140cd3e0e674e6","impliedFormat":1},{"version":"1bfc6565b90c8771615cd8cfcf9b36efc0275e5e83ac7d9181307e96eb495161","impliedFormat":1},{"version":"8a8a96898906f065f296665e411f51010b51372fa260d5373bf9f64356703190","impliedFormat":1},{"version":"e9f2cdc4e98e73a606ff68c470a8cb4f23cd638c47649d71b90a2d9413102080","affectsGlobalScope":true,"impliedFormat":1},{"version":"9d9e658d1d5b805562749ce383ef8c67ccb796394d8734d9c138788d7dab6ee3","impliedFormat":1},{"version":"a95b76aef31395752eb5cb7b386be2e287fdc32dfdf7bdbbb666e333133b1ef7","impliedFormat":1},{"version":"408cc7117448f4994a1f50468648a2d06eff4112a7707dbef6ceea76d2684707","impliedFormat":1}],"options":{"composite":true,"declaration":true,"declarationMap":true,"emitDeclarationOnly":true,"esModuleInterop":true,"jsx":4,"module":6,"noImplicitAny":true,"noImplicitReturns":false,"noImplicitThis":true,"noUnusedLocals":true,"noUnusedParameters":true,"outDir":"./types","rootDir":"../src","skipLibCheck":true,"strict":true,"target":7},"fileIdsList":[[125,132],[50,125],[125],[48,125,133],[125,138,139],[125,135,136,137,138],[125,139],[125,143,147],[56,58,59,60,61,62,63,64,65,66,67,68,125],[56,57,59,60,61,62,63,64,65,66,67,68,125],[57,58,59,60,61,62,63,64,65,66,67,68,125],[56,57,58,60,61,62,63,64,65,66,67,68,125],[56,57,58,59,61,62,63,64,65,66,67,68,125],[56,57,58,59,60,62,63,64,65,66,67,68,125],[56,57,58,59,60,61,63,64,65,66,67,68,125],[56,57,58,59,60,61,62,64,65,66,67,68,125],[56,57,58,59,60,61,62,63,65,66,67,68,125],[56,57,58,59,60,61,62,63,64,66,67,68,125],[56,57,58,59,60,61,62,63,64,65,67,68,125],[56,57,58,59,60,61,62,63,64,65,66,68,125],[56,57,58,59,60,61,62,63,64,65,66,67,125],[68,125],[82,125],[85,125],[86,91,125],[87,97,98,105,114,124,125],[87,88,97,105,125],[89,125],[90,91,98,106,125],[91,114,121,125],[92,94,97,105,125],[93,125],[94,95,125],[96,97,125],[97,125],[97,98,99,114,124,125],[97,98,99,114,125],[100,105,114,124,125],[97,98,100,101,105,114,121,124,125],[100,102,114,121,124,125],[82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131],[97,103,125],[104,124,125],[94,97,105,114,125],[106,125],[107,125],[85,108,125],[109,123,125,129],[110,125],[111,125],[97,112,125],[112,113,125,127],[97,114,115,116,125],[114,116,125],[114,115,125],[117,125],[118,125],[97,119,120,125],[119,120,125],[91,105,121,125],[122,125],[105,123,125],[86,100,111,124,125],[91,125],[114,125,126],[125,127],[125,128],[86,91,97,99,108,114,124,125,127,129],[114,125,130],[48,125],[44,45,46,47,125],[125,141,144],[125,141,144,145,146],[125,143],[125,142],[49,51,54,125],[49,53,54,55,69,70,71,72,73,74,75,76,77,78,125],[49,53,54,55,74,75,76,77,78,79,80,125],[49,50,54,125],[49,52,125],[49,51,53,54,125],[49,51,53,125],[51,54],[53,54,55,74,75,76,77,78,79,80],[54],[51,53]],"referencedMap":[[133,1],[51,2],[52,3],[50,3],[134,4],[140,5],[135,3],[139,6],[136,7],[138,3],[148,8],[137,3],[57,9],[58,10],[56,11],[59,12],[60,13],[61,14],[62,15],[63,16],[64,17],[65,18],[66,19],[67,20],[68,21],[73,22],[72,22],[71,22],[69,22],[70,22],[82,23],[83,23],[85,24],[86,25],[87,26],[88,27],[89,28],[90,29],[91,30],[92,31],[93,32],[94,33],[95,33],[96,34],[97,35],[98,36],[99,37],[84,3],[131,3],[100,38],[101,39],[102,40],[132,41],[103,42],[104,43],[105,44],[106,45],[107,46],[108,47],[109,48],[110,49],[111,50],[112,51],[113,52],[114,53],[116,54],[115,55],[117,56],[118,57],[119,58],[120,59],[121,60],[122,61],[123,62],[124,63],[125,64],[126,65],[127,66],[128,67],[129,68],[130,69],[149,3],[46,3],[150,70],[151,70],[44,3],[48,71],[49,70],[47,3],[45,3],[141,3],[145,72],[147,73],[146,72],[144,74],[143,75],[142,3],[8,3],[9,3],[11,3],[10,3],[2,3],[12,3],[13,3],[14,3],[15,3],[16,3],[17,3],[18,3],[19,3],[3,3],[4,3],[23,3],[20,3],[21,3],[22,3],[24,3],[25,3],[26,3],[5,3],[27,3],[28,3],[29,3],[30,3],[6,3],[34,3],[31,3],[32,3],[33,3],[35,3],[7,3],[36,3],[41,3],[42,3],[37,3],[38,3],[39,3],[40,3],[1,3],[43,3],[55,76],[79,77],[81,78],[74,76],[77,76],[75,76],[78,76],[80,79],[53,80],[76,81],[54,82]],"exportedModulesMap":[[133,1],[51,2],[52,3],[50,3],[134,4],[140,5],[135,3],[139,6],[136,7],[138,3],[148,8],[137,3],[57,9],[58,10],[56,11],[59,12],[60,13],[61,14],[62,15],[63,16],[64,17],[65,18],[66,19],[67,20],[68,21],[73,22],[72,22],[71,22],[69,22],[70,22],[82,23],[83,23],[85,24],[86,25],[87,26],[88,27],[89,28],[90,29],[91,30],[92,31],[93,32],[94,33],[95,33],[96,34],[97,35],[98,36],[99,37],[84,3],[131,3],[100,38],[101,39],[102,40],[132,41],[103,42],[104,43],[105,44],[106,45],[107,46],[108,47],[109,48],[110,49],[111,50],[112,51],[113,52],[114,53],[116,54],[115,55],[117,56],[118,57],[119,58],[120,59],[121,60],[122,61],[123,62],[124,63],[125,64],[126,65],[127,66],[128,67],[129,68],[130,69],[149,3],[46,3],[150,70],[151,70],[44,3],[48,71],[49,70],[47,3],[45,3],[141,3],[145,72],[147,73],[146,72],[144,74],[143,75],[142,3],[8,3],[9,3],[11,3],[10,3],[2,3],[12,3],[13,3],[14,3],[15,3],[16,3],[17,3],[18,3],[19,3],[3,3],[4,3],[23,3],[20,3],[21,3],[22,3],[24,3],[25,3],[26,3],[5,3],[27,3],[28,3],[29,3],[30,3],[6,3],[34,3],[31,3],[32,3],[33,3],[35,3],[7,3],[36,3],[41,3],[42,3],[37,3],[38,3],[39,3],[40,3],[1,3],[43,3],[55,83],[79,83],[81,84],[74,83],[77,85],[75,83],[78,85],[80,85],[76,83],[54,86]],"semanticDiagnosticsPerFile":[133,51,52,50,134,140,135,139,136,138,148,137,57,58,56,59,60,61,62,63,64,65,66,67,68,73,72,71,69,70,82,83,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,84,131,100,101,102,132,103,104,105,106,107,108,109,110,111,112,113,114,116,115,117,118,119,120,121,122,123,124,125,126,127,128,129,130,149,46,150,151,44,48,49,47,45,141,145,147,146,144,143,142,8,9,11,10,2,12,13,14,15,16,17,18,19,3,4,23,20,21,22,24,25,26,5,27,28,29,30,6,34,31,32,33,35,7,36,41,42,37,38,39,40,1,43,55,79,81,74,77,75,78,80,53,76,54],"latestChangedDtsFile":"./types/index.d.ts"},"version":"4.9.5"}
\ No newline at end of file
diff --git a/dist/types/logScale.d.ts b/dist/types/logScale.d.ts
index 65cfd46a7412ccab029a2f3e985fd2103e0ec4bf..1f831a37d20b0a556090e736e567eb74128512ba 100644
--- a/dist/types/logScale.d.ts
+++ b/dist/types/logScale.d.ts
@@ -1,3 +1,3 @@
 import { ComputedSerieAxis, ScaleAxis, ScaleLog, ScaleLogSpec } from './types';
-export declare const createLogScale: ({ base, min, max }: ScaleLogSpec, data: ComputedSerieAxis<number>, size: number, axis: ScaleAxis) => ScaleLog;
+export declare const createLogScale: ({ base, min, max, nice }: ScaleLogSpec, data: ComputedSerieAxis<number>, size: number, axis: ScaleAxis) => ScaleLog;
 //# sourceMappingURL=logScale.d.ts.map
\ No newline at end of file
diff --git a/dist/types/logScale.d.ts.map b/dist/types/logScale.d.ts.map
index 4495dcfde0123b1617c1b2b2464cd6275e4ff366..361e8bdab9b8faeed38501dfa26b687a6d9dfa69 100644
--- a/dist/types/logScale.d.ts.map
+++ b/dist/types/logScale.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"logScale.d.ts","sourceRoot":"","sources":["../../src/logScale.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,iBAAiB,EAAE,SAAS,EAAE,QAAQ,EAAE,YAAY,EAAE,MAAM,SAAS,CAAA;AAE9E,eAAO,MAAM,cAAc,uBACoB,YAAY,QACjD,kBAAkB,MAAM,CAAC,QACzB,MAAM,QACN,SAAS,aAgDlB,CAAA"}
\ No newline at end of file
+{"version":3,"file":"logScale.d.ts","sourceRoot":"","sources":["../../src/logScale.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,iBAAiB,EAAE,SAAS,EAAE,QAAQ,EAAE,YAAY,EAAE,MAAM,SAAS,CAAA;AAE9E,eAAO,MAAM,cAAc,6BACkC,YAAY,QAC/D,kBAAkB,MAAM,CAAC,QACzB,MAAM,QACN,SAAS,aA+ClB,CAAA"}
\ No newline at end of file
diff --git a/dist/types/types.d.ts b/dist/types/types.d.ts
index f6924bae6bc613d4fb20e4ace19ae66ede13442b..754f67fb943784d2583ab234a1eb3df06bb88262 100644
--- a/dist/types/types.d.ts
+++ b/dist/types/types.d.ts
@@ -46,6 +46,7 @@ export interface ScaleLogSpec {
     base?: number;
     min?: 'auto' | number;
     max?: 'auto' | number;
+    nice?: boolean;
 }
 export interface ScaleLog extends D3ScaleLogarithmic<number, number> {
     type: 'log';
diff --git a/dist/types/types.d.ts.map b/dist/types/types.d.ts.map
index f377d9d011be555d4801ad8a391264ec0f931f38..a95182a47aea1cd50bba5fc88dd7841cf98a4a0f 100644
--- a/dist/types/types.d.ts.map
+++ b/dist/types/types.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"types.d.ts","sourceRoot":"","sources":["../../src/types.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"types.d.ts","sourceRoot":"","sources":["../../src/types.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
